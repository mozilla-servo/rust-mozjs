/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

#![allow(non_uppercase_statics, non_camel_case_types, ctypes)]

use jsfriendapi::JSJitInfo;

use jsval::JSVal;
//more custom additions at bottom

/* automatically generated by rust-bindgen */

use libc::*;
pub type Struct_JSContext = JSContext;
pub type jschar = u16; //jdm c_void->u16
pub type MozMallocSizeOf =
    ::std::option::Option<extern "C" fn(arg1: *const c_void) -> size_t>;
pub type Enum_JSVersion = c_int;
pub static JSVERSION_ECMA_3: c_int = 148;
pub static JSVERSION_1_6: c_int = 160;
pub static JSVERSION_1_7: c_int = 170;
pub static JSVERSION_1_8: c_int = 180;
pub static JSVERSION_ECMA_5: c_int = 185;
pub static JSVERSION_DEFAULT: c_int = 0;
pub static JSVERSION_UNKNOWN: c_int = -1;
pub static JSVERSION_LATEST: c_int = 185;
pub type Enum_JSType = c_uint;
pub static JSTYPE_VOID: c_uint = 0;
pub static JSTYPE_OBJECT: c_uint = 1;
pub static JSTYPE_FUNCTION: c_uint = 2;
pub static JSTYPE_STRING: c_uint = 3;
pub static JSTYPE_NUMBER: c_uint = 4;
pub static JSTYPE_BOOLEAN: c_uint = 5;
pub static JSTYPE_NULL: c_uint = 6;
pub static JSTYPE_LIMIT: c_uint = 7;
pub type Enum_JSProtoKey = c_uint;
pub static JSProto_Null: c_uint = 0;
pub static JSProto_Object: c_uint = 1;
pub static JSProto_Function: c_uint = 2;
pub static JSProto_Array: c_uint = 3;
pub static JSProto_Boolean: c_uint = 4;
pub static JSProto_JSON: c_uint = 5;
pub static JSProto_Date: c_uint = 6;
pub static JSProto_Math: c_uint = 7;
pub static JSProto_Number: c_uint = 8;
pub static JSProto_String: c_uint = 9;
pub static JSProto_RegExp: c_uint = 10;
pub static JSProto_Error: c_uint = 11;
pub static JSProto_InternalError: c_uint = 12;
pub static JSProto_EvalError: c_uint = 13;
pub static JSProto_RangeError: c_uint = 14;
pub static JSProto_ReferenceError: c_uint = 15;
pub static JSProto_SyntaxError: c_uint = 16;
pub static JSProto_TypeError: c_uint = 17;
pub static JSProto_URIError: c_uint = 18;
pub static JSProto_Iterator: c_uint = 19;
pub static JSProto_StopIteration: c_uint = 20;
pub static JSProto_ArrayBuffer: c_uint = 21;
pub static JSProto_Int8Array: c_uint = 22;
pub static JSProto_Uint8Array: c_uint = 23;
pub static JSProto_Int16Array: c_uint = 24;
pub static JSProto_Uint16Array: c_uint = 25;
pub static JSProto_Int32Array: c_uint = 26;
pub static JSProto_Uint32Array: c_uint = 27;
pub static JSProto_Float32Array: c_uint = 28;
pub static JSProto_Float64Array: c_uint = 29;
pub static JSProto_Uint8ClampedArray: c_uint = 30;
pub static JSProto_Proxy: c_uint = 31;
pub static JSProto_WeakMap: c_uint = 32;
pub static JSProto_Map: c_uint = 33;
pub static JSProto_Set: c_uint = 34;
pub static JSProto_DataView: c_uint = 35;
pub static JSProto_SharedArrayBuffer: c_uint = 36;
pub static JSProto_Intl: c_uint = 37;
pub static JSProto_TypedObject: c_uint = 38;
pub static JSProto_GeneratorFunction: c_uint = 39;
pub static JSProto_SIMD: c_uint = 40;
pub static JSProto_LIMIT: c_uint = 41;
pub type Enum_JSIterateOp = c_uint;
pub static JSENUMERATE_INIT: c_uint = 0;
pub static JSENUMERATE_INIT_ALL: c_uint = 1;
pub static JSENUMERATE_NEXT: c_uint = 2;
pub static JSENUMERATE_DESTROY: c_uint = 3;
pub type Enum_JSGCTraceKind = c_uint;
pub static JSTRACE_OBJECT: c_uint = 0;
pub static JSTRACE_STRING: c_uint = 1;
pub static JSTRACE_SCRIPT: c_uint = 2;
pub static JSTRACE_LAZY_SCRIPT: c_uint = 3;
pub static JSTRACE_JITCODE: c_uint = 4;
pub static JSTRACE_SHAPE: c_uint = 5;
pub static JSTRACE_BASE_SHAPE: c_uint = 6;
pub static JSTRACE_TYPE_OBJECT: c_uint = 7;
pub static JSTRACE_LAST: c_uint = 7;
pub type Struct_JSCompartment = c_void;
pub type Struct_JSCrossCompartmentCall = c_void;
pub type Struct_JSExceptionState = c_void;
pub type Struct_JSIdArray = c_void;
pub type Struct_JSObjectMap = c_void;
pub type Struct_JSPropertyName = c_void;
pub type Struct_JSRuntime = JSRuntime;
pub type Struct_JSStructuredCloneCallbacks = c_void;
pub type Struct_JSStructuredCloneReader = c_void;
pub type Struct_JSStructuredCloneWriter = c_void;
pub type Struct_PRCallOnceType = c_void;
pub type JSCallOnceType = Struct_PRCallOnceType;
pub type JSInitCallback = ::std::option::Option<extern "C" fn() -> bool>;
pub type JSTraceDataOp =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut c_void)>; //jdm void->jstracer
pub type Enum_JSValueType = c_uchar;
pub static JSVAL_TYPE_DOUBLE: c_uchar = 0;
pub static JSVAL_TYPE_INT32: c_uchar = 1;
pub static JSVAL_TYPE_UNDEFINED: c_uchar = 2;
pub static JSVAL_TYPE_BOOLEAN: c_uchar = 3;
pub static JSVAL_TYPE_MAGIC: c_uchar = 4;
pub static JSVAL_TYPE_STRING: c_uchar = 5;
pub static JSVAL_TYPE_NULL: c_uchar = 6;
pub static JSVAL_TYPE_OBJECT: c_uchar = 7;
pub static JSVAL_TYPE_UNKNOWN: c_uchar = 32;
pub static JSVAL_TYPE_MISSING: c_uchar = 33;
pub type Enum_JSValueTag = c_uint;
pub static JSVAL_TAG_MAX_DOUBLE: c_uint = 131056;
pub static JSVAL_TAG_INT32: c_uint = 131057;
pub static JSVAL_TAG_UNDEFINED: c_uint = 131058;
pub static JSVAL_TAG_STRING: c_uint = 131061;
pub static JSVAL_TAG_BOOLEAN: c_uint = 131059;
pub static JSVAL_TAG_MAGIC: c_uint = 131060;
pub static JSVAL_TAG_NULL: c_uint = 131062;
pub static JSVAL_TAG_OBJECT: c_uint = 131063;
pub type Enum_JSValueShiftedTag = c_ulong;
pub static JSVAL_SHIFTED_TAG_MAX_DOUBLE: c_ulong = -2251795518717953;
pub static JSVAL_SHIFTED_TAG_INT32: c_ulong = -2111062325329920;
pub static JSVAL_SHIFTED_TAG_UNDEFINED: c_ulong = -1970324836974592;
pub static JSVAL_SHIFTED_TAG_STRING: c_ulong = -1548112371908608;
pub static JSVAL_SHIFTED_TAG_BOOLEAN: c_ulong = -1829587348619264;
pub static JSVAL_SHIFTED_TAG_MAGIC: c_ulong = -1688849860263936;
pub static JSVAL_SHIFTED_TAG_NULL: c_ulong = -1407374883553280;
pub static JSVAL_SHIFTED_TAG_OBJECT: c_ulong = -1266637395197952;
pub type Enum_JSWhyMagic = c_uint;
pub static JS_ELEMENTS_HOLE: c_uint = 0;
pub static JS_NATIVE_ENUMERATE: c_uint = 1;
pub static JS_NO_ITER_VALUE: c_uint = 2;
pub static JS_GENERATOR_CLOSING: c_uint = 3;
pub static JS_NO_CONSTANT: c_uint = 4;
pub static JS_THIS_POISON: c_uint = 5;
pub static JS_ARG_POISON: c_uint = 6;
pub static JS_SERIALIZE_NO_NODE: c_uint = 7;
pub static JS_LAZY_ARGUMENTS: c_uint = 8;
pub static JS_OPTIMIZED_ARGUMENTS: c_uint = 9;
pub static JS_IS_CONSTRUCTING: c_uint = 10;
pub static JS_OVERWRITTEN_CALLEE: c_uint = 11;
pub static JS_BLOCK_NEEDS_CLONE: c_uint = 12;
pub static JS_HASH_KEY_EMPTY: c_uint = 13;
pub static JS_ION_ERROR: c_uint = 14;
pub static JS_ION_BAILOUT: c_uint = 15;
pub static JS_OPTIMIZED_OUT: c_uint = 16;
pub static JS_GENERIC_MAGIC: c_uint = 17;
pub type JSWhyMagic = Enum_JSWhyMagic;
/*pub struct Union_jsval_layout { //jdm moved to jsval.rs
    pub data: [u64, ..1u],
}
impl Union_jsval_layout {
    pub fn asBits(&mut self) -> *mut uint64_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn debugView(&mut self) -> *mut Struct_Unnamed1 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn s(&mut self) -> *mut Struct_Unnamed2 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn asDouble(&mut self) -> *mut c_double {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn asPtr(&mut self) -> *mut *mut c_void {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn asWord(&mut self) -> *mut size_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn asUIntPtr(&mut self) -> *mut uintptr_t {
        unsafe { ::std::mem::transmute(self) }
    }
}*/
//pub struct Struct_Unnamed1 {
//    payload47: uint64_t,
//    tag: Enum_JSValueTag,
//}
pub struct Struct_Unnamed2 {
    pub payload: Union_Unnamed3,
}
pub struct Union_Unnamed3 {
    pub data: [u32, ..1u],
}
impl Union_Unnamed3 {
    pub fn i32(&mut self) -> *mut int32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u32(&mut self) -> *mut uint32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn why(&mut self) -> *mut JSWhyMagic {
        unsafe { ::std::mem::transmute(self) }
    }
}
//pub type jsval_layout = Union_jsval_layout;
//pub type jsval = c_void; //jdm
pub type JSNative =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext, arg2: c_uint,
                               arg3: *mut jsval) -> bool>; //jdm c_void->jsval
pub type JSParallelNative =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_ForkJoinContext,
                               arg2: c_uint, arg3: *mut c_void) -> bool>;
pub type JSThreadSafeNative =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_ThreadSafeContext,
                               arg2: c_uint, arg3: *mut c_void) -> bool>;
#[repr(C)]
pub struct Struct_jsid {
    asBits: size_t,
}
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSPropertyOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleId,
                               arg4: MutableHandleValue) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSStrictPropertyOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleId,
                               arg4: bool, arg5: MutableHandleValue)
                              -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSDeletePropertyOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleId,
                               arg4: *mut bool) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSNewEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: Enum_JSIterateOp,
                               arg4: MutableHandleValue,
                               arg5: MutableHandleId) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSResolveOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleId) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSNewResolveOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleId,
                               arg4: c_uint, arg5: MutableHandleObject)
                              -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSConvertOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: Enum_JSType,
                               arg4: MutableHandleValue) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSFinalizeOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSFreeOp,
                               arg2: *mut JSObject)>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSStringFinalizer {
    finalize: ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                                        (arg1: *const Struct_JSStringFinalizer,
                                         arg2: *mut jschar)>,
}
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSHasInstanceOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: MutableHandleValue,
                               arg4: *mut bool) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSTraceOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut JSTracer, arg2: *mut JSObject)>; //jdm c_void->...
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSObjectOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject) -> *mut JSObject>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSIteratorOp =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: bool)
                              -> *mut JSObject>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSWeakmapKeyDelegateOp =
    ::std::option::Option<unsafe extern "C" fn (arg1: *mut JSObject) -> *mut JSObject>; //jdm +unsafe
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSClassInternal = ::std::option::Option<extern "C" fn()>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSClass {
    pub name: *const c_schar,
    pub flags: uint32_t,
    pub addProperty: JSPropertyOp,
    pub delProperty: JSDeletePropertyOp,
    pub getProperty: JSPropertyOp,
    pub setProperty: JSStrictPropertyOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub convert: JSConvertOp,
    pub finalize: JSFinalizeOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
    pub reserved: [*mut c_void, ..31u],
}
//pub struct Struct_JSPrincipals {
//    refcount: c_void,
//}
pub enum Struct_JSPrincipals {}
pub type JSSubsumesOp =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSPrincipals,
                               arg2: *mut Struct_JSPrincipals) -> bool>;
pub type JSCSPEvalChecker =
    ::std::option::Option<extern "C" fn(arg1: *mut Struct_JSContext)
                              -> bool>;
#[repr(C)]
pub struct Struct_JSSecurityCallbacks {
    contentSecurityPolicyAllows: JSCSPEvalChecker,
    subsumes: JSSubsumesOp,
}
pub type JSDestroyPrincipalsOp =
    ::std::option::Option<extern "C" fn(arg1: *mut Struct_JSPrincipals)>;
pub type JSTraceCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut c_void, arg2: *mut *mut c_void,
                               arg3: Enum_JSGCTraceKind)>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSTraceNamePrinter =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut JSTracer, arg2: *mut c_schar,
                               arg3: size_t)>;
pub type Enum_WeakMapTraceKind = c_uint;
pub static DoNotTraceWeakMaps: c_uint = 0;
pub static TraceWeakMapValues: c_uint = 1;
pub static TraceWeakMapKeysValues: c_uint = 2;
//pub struct Struct_JSFreeOp {
//    runtime_: *mut Struct_JSRuntime,
//}
pub enum Struct_JSFreeOp {}
pub type Enum_JSContextOp = c_uint;
pub static JSCONTEXT_NEW: c_uint = 0;
pub static JSCONTEXT_DESTROY: c_uint = 1;
pub type JSContextOp = Enum_JSContextOp;
pub type JSContextCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext, arg2: c_uint,
                               arg3: *mut c_void) -> bool>;
pub type Enum_JSGCStatus = c_uint;
pub static JSGC_BEGIN: c_uint = 0;
pub static JSGC_END: c_uint = 1;
pub type JSGCStatus = Enum_JSGCStatus;
pub type JSGCCallback =
    ::std::option::Option<unsafe extern "C" fn
                              (arg1: *mut Struct_JSRuntime, arg2: JSGCStatus,
                               arg3: *mut c_void)>;
pub type Enum_JSFinalizeStatus = c_uint;
pub static JSFINALIZE_GROUP_START: c_uint = 0;
pub static JSFINALIZE_GROUP_END: c_uint = 1;
pub static JSFINALIZE_COLLECTION_END: c_uint = 2;
pub type JSFinalizeStatus = Enum_JSFinalizeStatus;
pub type JSFinalizeCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSFreeOp,
                               arg2: JSFinalizeStatus, arg3: bool)>;
pub type JSInterruptCallback =
    ::std::option::Option<extern "C" fn(arg1: *mut Struct_JSContext)
                              -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSErrorReporter =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut Struct_JSContext, arg2: *const c_schar,
                               arg3: *mut Struct_JSErrorReport)>;
pub type Enum_JSExnType = c_int;
pub static JSEXN_NONE: c_int = -1;
pub static JSEXN_ERR: c_int = 0;
pub static JSEXN_INTERNALERR: c_int = 1;
pub static JSEXN_EVALERR: c_int = 2;
pub static JSEXN_RANGEERR: c_int = 3;
pub static JSEXN_REFERENCEERR: c_int = 4;
pub static JSEXN_SYNTAXERR: c_int = 5;
pub static JSEXN_TYPEERR: c_int = 6;
pub static JSEXN_URIERR: c_int = 7;
pub static JSEXN_LIMIT: c_int = 8;
pub type JSExnType = Enum_JSExnType;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSErrorFormatString {
    pub format: *const c_schar,
    pub argCount: uint16_t,
    pub exnType: int16_t,
}

pub type JSErrorFormatString = Struct_JSErrorFormatString;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSErrorCallback =
    ::std::option::Option<unsafe extern "C" fn //jdm +unsafe
                              (arg1: *mut c_void, arg2: *const c_schar,
                               arg3: c_uint) -> *const JSErrorFormatString>;
pub type JSLocaleToUpperCase =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleString, arg3: MutableHandleValue)
                              -> bool>;
pub type JSLocaleToLowerCase =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleString, arg3: MutableHandleValue)
                              -> bool>;
pub type JSLocaleCompare =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleString, arg3: HandleString,
                               arg4: MutableHandleValue) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSLocaleToUnicode =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext, arg2: *const c_schar,
                               arg3: MutableHandleValue) -> bool>;
pub type JSWrapObjectCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleObject,
                               arg4: HandleObject, arg5: HandleObject,
                               arg6: c_uint) -> *mut c_void>;
pub type JSPreWrapCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSContext,
                               arg2: HandleObject, arg3: HandleObject,
                               arg4: c_uint) -> *mut c_void>;
#[repr(C)]
pub struct Struct_JSWrapObjectCallbacks {
    pub wrap: JSWrapObjectCallback,
    pub preWrap: JSPreWrapCallback,
}

pub type JSDestroyCompartmentCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSFreeOp,
                               arg2: *mut Struct_JSCompartment)>;
pub type JSZoneCallback =
    ::std::option::Option<extern "C" fn(arg1: *mut Struct_Zone)>;
pub type JSCompartmentNameCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSRuntime,
                               arg2: *mut Struct_JSCompartment,
                               arg3: *mut c_schar, arg4: size_t)>;
pub type Enum_JSUseHelperThreads = c_uint;
pub static JS_NO_HELPER_THREADS: c_uint = 0;
pub static JS_USE_HELPER_THREADS: c_uint = 1;
pub type JSUseHelperThreads = Enum_JSUseHelperThreads;
pub type JS_ICUAllocFn =
    ::std::option::Option<extern "C" fn(arg1: *const c_void, arg2: size_t)
                              -> *mut c_void>;
pub type JS_ICUReallocFn =
    ::std::option::Option<extern "C" fn
                              (arg1: *const c_void, arg2: *mut c_void, arg3: size_t)
                              -> *mut c_void>;
pub type JS_ICUFreeFn =
    ::std::option::Option<extern "C" fn(arg1: *const c_void, arg2: *mut c_void)>;
pub type JSIterateCompartmentCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut Struct_JSRuntime, arg2: *mut c_void,
                               arg3: *mut Struct_JSCompartment)>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSEnumerateDiagnosticMemoryCallback =
    ::std::option::Option<extern "C" fn(arg1: *mut c_void, arg2: size_t)
                              -> bool>;
pub type Enum_JSGCParamKey = c_uint;
pub static JSGC_MAX_BYTES: c_uint = 0;
pub static JSGC_MAX_MALLOC_BYTES: c_uint = 1;
pub static JSGC_BYTES: c_uint = 3;
pub static JSGC_NUMBER: c_uint = 4;
pub static JSGC_MAX_CODE_CACHE_BYTES: c_uint = 5;
pub static JSGC_MODE: c_uint = 6;
pub static JSGC_UNUSED_CHUNKS: c_uint = 7;
pub static JSGC_TOTAL_CHUNKS: c_uint = 8;
pub static JSGC_SLICE_TIME_BUDGET: c_uint = 9;
pub static JSGC_MARK_STACK_LIMIT: c_uint = 10;
pub static JSGC_HIGH_FREQUENCY_TIME_LIMIT: c_uint = 11;
pub static JSGC_HIGH_FREQUENCY_LOW_LIMIT: c_uint = 12;
pub static JSGC_HIGH_FREQUENCY_HIGH_LIMIT: c_uint = 13;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX: c_uint = 14;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN: c_uint = 15;
pub static JSGC_LOW_FREQUENCY_HEAP_GROWTH: c_uint = 16;
pub static JSGC_DYNAMIC_HEAP_GROWTH: c_uint = 17;
pub static JSGC_DYNAMIC_MARK_SLICE: c_uint = 18;
pub static JSGC_ALLOCATION_THRESHOLD: c_uint = 19;
pub static JSGC_DECOMMIT_THRESHOLD: c_uint = 20;
pub type JSGCParamKey = Enum_JSGCParamKey;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSConstDoubleSpec {
    dval: c_double,
    name: *const c_schar,
    flags: uint8_t,
    spare: [uint8_t, ..3u],
}
//pub type Struct_JSJitInfo = c_void; //jdm property defn in jsfriendapi.h
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSStrictPropertyOpWrapper {
    pub op: JSStrictPropertyOp,
    pub info: *const Struct_JSJitInfo,
}
pub type JSStrictPropertyOpWrapper = Struct_JSStrictPropertyOpWrapper;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSPropertyOpWrapper {
    pub op: JSPropertyOp,
    pub info: *const Struct_JSJitInfo,
}
pub type JSPropertyOpWrapper = Struct_JSPropertyOpWrapper;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSNativeWrapper {
    pub op: JSNative,
    pub info: *const Struct_JSJitInfo,
}
pub type JSNativeWrapper = Struct_JSNativeWrapper;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSPropertySpec {
    pub name: *const c_schar,
    pub flags: uint8_t,
    pub getter: JSNativeWrapper, //jdm in practice this is always a native, not a property op
    pub setter: JSNativeWrapper, //jdm in practice this is always a native, not a strict property op
}
//pub struct Struct_SelfHostedWrapper {
//    unused: *mut c_void,
//    funname: *const c_schar,
//}
//pub struct Union_Unnamed4 {
//    data: [u64, ..2u],
//}
//impl Union_Unnamed4 {
//    pub fn propertyOp(&mut self) -> *mut JSPropertyOpWrapper {
//        unsafe { ::std::cast::transmute(self) }
//    }
//    pub fn selfHosted(&mut self) -> *mut Struct_SelfHostedWrapper {
//        unsafe { ::std::cast::transmute(self) }
//    }
//}
//pub struct Union_Unnamed5 {
//    data: [u64, ..2u],
//}
//impl Union_Unnamed5 {
//    pub fn propertyOp(&mut self) -> *mut JSStrictPropertyOpWrapper {
//        unsafe { ::std::cast::transmute(self) }
//    }
//    pub fn selfHosted(&mut self) -> *mut Struct_SelfHostedWrapper {
//        unsafe { ::std::cast::transmute(self) }
//    }
//}
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSFunctionSpec {
    pub name: *const c_schar,
    pub call: JSNativeWrapper,
    pub nargs: uint16_t,
    pub flags: uint16_t,
    pub selfHostedName: *const c_schar,
}
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSPropertyDescriptor {
    pub obj: *mut JSObject,
    pub attrs: c_uint,
    pub getter: JSPropertyOp,
    pub setter: JSStrictPropertyOp,
    pub value: jsval, //jdm c_void->JSVal
}
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type JSONWriteCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *const jschar, arg2: uint32_t,
                               arg3: *mut c_void) -> bool>;
// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSLocaleCallbacks {
    localeToUpperCase: JSLocaleToUpperCase,
    localeToLowerCase: JSLocaleToLowerCase,
    localeCompare: JSLocaleCompare,
    localeToUnicode: JSLocaleToUnicode,
    localeGetErrorMessage: JSErrorCallback,
}

// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
#[repr(C)]
pub struct Struct_JSErrorReport {
    pub filename: *const c_schar,
    pub originPrincipals: *mut Struct_JSPrincipals,
    pub lineno: c_uint,
    pub linebuf: *const c_schar,
    pub tokenptr: *const c_schar,
    pub uclinebuf: *const jschar,
    pub uctokenptr: *const jschar,
    pub flags: c_uint,
    pub errorNumber: c_uint,
    pub ucmessage: *const jschar,
    pub messageArgs: *mut *const jschar,
    pub exnType: int16_t,
    pub column: c_uint,
}

pub static JSREPORT_ERROR: c_uint = 0x0;
pub static JSREPORT_WARNING: c_uint = 0x1;
pub static JSREPORT_EXCEPTION: c_uint = 0x2;
pub static JSREPORT_STRICT: c_uint = 0x4;
pub static JSREPORT_STRICT_MODE_ERROR: c_uint = 0x8;


// Up-to-date mozjs 075904f5f7ee1176f28630d1dff47820020e5928
pub type Enum_JSJitCompilerOption = c_uint;
pub static JSJITCOMPILER_BASELINE_USECOUNT_TRIGGER: c_uint = 0;
pub static JSJITCOMPILER_ION_USECOUNT_TRIGGER: c_uint = 1;
pub static JSJITCOMPILER_ION_ENABLE: c_uint = 2;
pub static JSJITCOMPILER_BASELINE_ENABLE: c_uint = 3;
pub static JSJITCOMPILER_PARALLEL_COMPILATION_ENABLE: c_uint = 4;
pub static JSJITCOMPILER_NOT_AN_OPTION: c_uint = 5;
pub type JSJitCompilerOption = Enum_JSJitCompilerOption;
extern "C" {
    pub static JSVAL_NULL: jsval;
    pub static JSVAL_ZERO: jsval;
    pub static JSVAL_ONE: jsval;
    pub static JSVAL_FALSE: jsval;
    pub static JSVAL_TRUE: jsval;
    pub static JSVAL_VOID: jsval;
    pub static JSID_VOID: Struct_jsid;
    pub static JSID_EMPTY: Struct_jsid;
    pub static JSID_VOIDHANDLE: HandleId<'static>;
    pub static JSID_EMPTYHANDLE: HandleId<'static>;
    pub fn JS_Assert(s: *const c_schar, file: *const c_schar, ln: c_int);
    pub fn JS_Abort();
    pub fn js_FinishGC(rt: *mut Struct_JSRuntime);
    pub fn JS_ComputeThis(cx: *mut Struct_JSContext, vp: *mut jsval) -> jsval; //jdm c_void->jsval
    pub fn JS_THIS(cx: *mut Struct_JSContext, vp: *mut c_void);
    pub fn JS_HoldPrincipals(principals: *mut Struct_JSPrincipals);
    pub fn JS_DropPrincipals(rt: *mut Struct_JSRuntime,
                             principals: *mut Struct_JSPrincipals);
    pub fn JS_SetSecurityCallbacks(rt: *mut Struct_JSRuntime,
                                   callbacks: *const Struct_JSSecurityCallbacks);
    pub fn JS_GetSecurityCallbacks(rt: *mut Struct_JSRuntime) ->
     *const Struct_JSSecurityCallbacks;
    pub fn JS_SetTrustedPrincipals(rt: *mut Struct_JSRuntime,
                                   prin: *const Struct_JSPrincipals);
    pub fn JS_InitDestroyPrincipalsCallback(rt: *mut Struct_JSRuntime,
                                            destroyPrincipals:
                                                JSDestroyPrincipalsOp);
    pub fn JS_CallValueTracer(trc: *mut JSTracer, valuep: *mut jsval, //jdm c_void->JSTracer, c_void->JSVal
                              name: *const c_schar);
    pub fn JS_CallIdTracer(trc: *mut c_void, idp: *mut Struct_jsid,
                           name: *const c_schar);
    pub fn JS_CallObjectTracer(trc: *mut JSTracer, objp: *mut *mut JSObject, //jdm c_void->JSTracer, c_void->JSObject
                               name: *const c_schar);
    pub fn JS_CallStringTracer(trc: *mut c_void, strp: *mut *mut c_void,
                               name: *const c_schar);
    pub fn JS_CallScriptTracer(trc: *mut c_void, scriptp: *mut *mut c_void,
                               name: *const c_schar);
    pub fn JS_CallHeapValueTracer(trc: *mut c_void, valuep: *mut c_void,
                                  name: *const c_schar);
    pub fn JS_CallHeapIdTracer(trc: *mut c_void, idp: *mut c_void,
                               name: *const c_schar);
    pub fn JS_CallHeapObjectTracer(trc: *mut c_void, objp: *mut c_void,
                                   name: *const c_schar);
    pub fn JS_CallHeapStringTracer(trc: *mut c_void, strp: *mut c_void,
                                   name: *const c_schar);
    pub fn JS_CallHeapScriptTracer(trc: *mut c_void, scriptp: *mut c_void,
                                   name: *const c_schar);
    pub fn JS_CallHeapFunctionTracer(trc: *mut c_void, funp: *mut c_void,
                                     name: *const c_schar);
    pub fn JS_CallTenuredObjectTracer(trc: *mut c_void, objp: *mut c_void,
                                      name: *const c_schar);
    pub fn JS_TraceChildren(trc: *mut c_void, thing: *mut c_void,
                            kind: Enum_JSGCTraceKind);
    pub fn JS_TraceRuntime(trc: *mut c_void);
    pub fn JS_GetTraceThingInfo(buf: *mut c_schar, bufsize: size_t,
                                trc: *mut c_void, thing: *mut c_void,
                                kind: Enum_JSGCTraceKind,
                                includeDetails: bool);
    pub fn JS_StringHasBeenInterned(cx: *mut Struct_JSContext,
                                    str: *mut c_void) -> bool;
    pub fn INTERNED_STRING_TO_JSID(cx: *mut Struct_JSContext,
                                   str: *mut c_void) -> Struct_jsid;
    pub fn JS_CallOnce(_once: *mut JSCallOnceType, func: JSInitCallback) ->
     bool;
    pub fn JS_Now() -> int64_t;
    pub fn JS_GetNaNValue(cx: *mut Struct_JSContext) -> jsval;
    pub fn JS_GetNegativeInfinityValue(cx: *mut Struct_JSContext) -> jsval;
    pub fn JS_GetPositiveInfinityValue(cx: *mut Struct_JSContext) -> jsval;
    pub fn JS_GetEmptyStringValue(cx: *mut Struct_JSContext) -> jsval;
    pub fn JS_GetEmptyString(rt: *mut Struct_JSRuntime) -> *mut c_void;
    pub fn JS_ConvertArguments(cx: *mut Struct_JSContext, args: c_void,
                               format: *const c_schar, ...) -> bool;
    pub fn JS_ConvertArgumentsVA(cx: *mut Struct_JSContext, args: c_void,
                                 format: *const c_schar, ap: va_list) -> bool;
    pub fn JS_ConvertValue(cx: *mut Struct_JSContext, v: HandleValue,
                           _type: Enum_JSType, vp: MutableHandleValue) ->
     bool;
    pub fn JS_ValueToObject(cx: *mut Struct_JSContext, v: HandleValue,
                            objp: MutableHandleObject) -> bool;
    pub fn JS_ValueToFunction(cx: *mut Struct_JSContext, v: HandleValue) ->
     *mut c_void;
    pub fn JS_ValueToConstructor(cx: *mut Struct_JSContext, v: HandleValue) ->
     *mut c_void;
    pub fn JS_ValueToSource(cx: *mut Struct_JSContext, v: HandleValue) -> //jdm c_void->HandleValue
     *mut c_void;
    pub fn JS_DoubleIsInt32(d: c_double, ip: *mut int32_t) -> bool;
    pub fn JS_DoubleToInt32(d: c_double) -> int32_t;
    pub fn JS_DoubleToUint32(d: c_double) -> uint32_t;
    pub fn JS_TypeOfValue(cx: *mut Struct_JSContext, v: c_void) ->
     Enum_JSType;
    pub fn JS_GetTypeName(cx: *mut Struct_JSContext, _type: Enum_JSType) ->
     *const c_schar;
    pub fn JS_StrictlyEqual(cx: *mut Struct_JSContext, v1: jsval, v2: jsval,
                            equal: *mut bool) -> bool;
    pub fn JS_LooselyEqual(cx: *mut Struct_JSContext, v1: c_void, v2: c_void,
                           equal: *mut bool) -> bool;
    pub fn JS_SameValue(cx: *mut Struct_JSContext, v1: jsval, v2: jsval,
                        same: *mut bool) -> bool;
    pub fn JS_IsBuiltinEvalFunction(fun: *mut c_void) -> bool;
    pub fn JS_IsBuiltinFunctionConstructor(fun: *mut c_void) -> bool;
    pub fn JS_Init() -> bool;
    pub fn JS_ShutDown();
    pub fn JS_NewRuntime(maxbytes: uint32_t,
                         useHelperThreads: JSUseHelperThreads,
                         parentRuntime: *mut Struct_JSRuntime) ->
     *mut Struct_JSRuntime;
    pub fn JS_DestroyRuntime(rt: *mut Struct_JSRuntime);
    pub fn JS_SetICUMemoryFunctions(allocFn: JS_ICUAllocFn,
                                    reallocFn: JS_ICUReallocFn,
                                    freeFn: JS_ICUFreeFn) -> bool;
    pub fn JS_GetRuntimePrivate(rt: *mut Struct_JSRuntime) -> *mut c_void;
    pub fn JS_GetRuntime(cx: *mut Struct_JSContext) -> *mut Struct_JSRuntime;
    pub fn JS_GetParentRuntime(cx: *mut Struct_JSContext) ->
     *mut Struct_JSRuntime;
    pub fn JS_SetRuntimePrivate(rt: *mut Struct_JSRuntime, data: *mut c_void);
    pub fn JS_BeginRequest(cx: *mut Struct_JSContext);
    pub fn JS_EndRequest(cx: *mut Struct_JSContext);
    pub fn JS_IsInRequest(rt: *mut Struct_JSRuntime) -> bool;
    pub fn JS_SetContextCallback(rt: *mut Struct_JSRuntime,
                                 cxCallback: JSContextCallback,
                                 data: *mut c_void);
    pub fn JS_NewContext(rt: *mut Struct_JSRuntime, stackChunkSize: size_t) ->
     *mut Struct_JSContext;
    pub fn JS_DestroyContext(cx: *mut Struct_JSContext);
    pub fn JS_DestroyContextNoGC(cx: *mut Struct_JSContext);
    pub fn JS_GetContextPrivate(cx: *mut Struct_JSContext) -> *mut c_void;
    pub fn JS_SetContextPrivate(cx: *mut Struct_JSContext, data: *mut c_void);
    pub fn JS_GetSecondContextPrivate(cx: *mut Struct_JSContext) ->
     *mut c_void;
    pub fn JS_SetSecondContextPrivate(cx: *mut Struct_JSContext,
                                      data: *mut c_void);
    pub fn JS_ContextIterator(rt: *mut Struct_JSRuntime,
                              iterp: *mut *mut Struct_JSContext) ->
     *mut Struct_JSContext;
    pub fn JS_GetVersion(cx: *mut Struct_JSContext) -> Enum_JSVersion;
    pub fn JS_SetVersionForCompartment(compartment: *mut Struct_JSCompartment,
                                       version: Enum_JSVersion);
    pub fn JS_VersionToString(version: Enum_JSVersion) -> *const c_schar;
    pub fn JS_StringToVersion(string: *const c_schar) -> Enum_JSVersion;
    pub fn JS_GetImplementationVersion() -> *const c_schar;
    pub fn JS_SetDestroyCompartmentCallback(rt: *mut Struct_JSRuntime,
                                            callback:
                                                JSDestroyCompartmentCallback);
    pub fn JS_SetDestroyZoneCallback(rt: *mut Struct_JSRuntime,
                                     callback: JSZoneCallback);
    pub fn JS_SetSweepZoneCallback(rt: *mut Struct_JSRuntime,
                                   callback: JSZoneCallback);
    pub fn JS_SetCompartmentNameCallback(rt: *mut Struct_JSRuntime,
                                         callback: JSCompartmentNameCallback);
    pub fn JS_SetWrapObjectCallbacks(rt: *mut Struct_JSRuntime,
                                     callbacks:
                                         *const Struct_JSWrapObjectCallbacks);
    pub fn JS_SetCompartmentPrivate(compartment: *mut Struct_JSCompartment,
                                    data: *mut c_void);
    pub fn JS_GetCompartmentPrivate(compartment: *mut Struct_JSCompartment) ->
     *mut c_void;
    pub fn JS_SetZoneUserData(zone: *mut Struct_Zone, data: *mut c_void);
    pub fn JS_GetZoneUserData(zone: *mut Struct_Zone) -> *mut c_void;
    pub fn JS_WrapObject(cx: *mut Struct_JSContext, objp: MutableHandleObject)
     -> bool;
    pub fn JS_WrapValue(cx: *mut Struct_JSContext, vp: MutableHandleValue) ->
     bool;
    pub fn JS_WrapId(cx: *mut Struct_JSContext, idp: MutableHandleId) ->
     bool;
    pub fn JS_TransplantObject(cx: *mut Struct_JSContext,
                               origobj: HandleObject, target: HandleObject) ->
     *mut c_void;
    pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut Struct_JSContext,
                                              obj: c_void) -> bool;
    pub fn JS_EnterCompartment(cx: *mut Struct_JSContext, target: *mut JSObject) //jdm c_void->JSObject
     -> *mut Struct_JSCompartment;
    pub fn JS_LeaveCompartment(cx: *mut Struct_JSContext,
                               oldCompartment: *mut Struct_JSCompartment);
    pub fn JS_IterateCompartments(rt: *mut Struct_JSRuntime,
                                  data: *mut c_void,
                                  compartmentCallback:
                                      JSIterateCompartmentCallback);
    pub fn JS_InitStandardClasses(cx: *mut Struct_JSContext, obj: JSHandleObject) -> //jdm c_void->JSHandleObject
     bool;
    pub fn JS_ResolveStandardClass(cx: *mut Struct_JSContext,
                                   obj: HandleObject, id: HandleId,
                                   resolved: *mut bool) -> bool;
    pub fn JS_EnumerateStandardClasses(cx: *mut Struct_JSContext,
                                       obj: HandleObject) -> bool;
    pub fn JS_GetClassObject(cx: *mut Struct_JSContext, key: Enum_JSProtoKey,
                             objp: c_void) -> bool;
    pub fn JS_GetClassPrototype(cx: *mut Struct_JSContext,
                                key: Enum_JSProtoKey, objp: c_void) -> bool;
    pub fn JS_IdToProtoKey(cx: *mut Struct_JSContext, id: HandleId) ->
     Enum_JSProtoKey;
    pub fn JS_GetFunctionPrototype(cx: *mut Struct_JSContext,
                                   forObj: HandleObject) -> *mut c_void;
    pub fn JS_GetObjectPrototype(cx: *mut Struct_JSContext,
                                 forObj: HandleObject) -> *mut JSObject; //jdm c_void->JSObject
    pub fn JS_GetArrayPrototype(cx: *mut Struct_JSContext,
                                forObj: HandleObject) -> *mut c_void;
    pub fn JS_GetGlobalForObject(cx: *mut Struct_JSContext, obj: *mut c_void)
     -> *mut c_void;
    pub fn JS_IsGlobalObject(obj: *mut c_void) -> bool;
    pub fn JS_GetGlobalForCompartmentOrNull(cx: *mut Struct_JSContext,
                                            c: *mut Struct_JSCompartment) ->
     *mut c_void;
    pub fn JS_InitReflect(cx: *mut Struct_JSContext, global: HandleObject) ->
     *mut c_void;
    pub fn JS_EnumerateDiagnosticMemoryRegions(callback:
                                                   JSEnumerateDiagnosticMemoryCallback);
    pub fn JS_malloc(cx: *mut Struct_JSContext, nbytes: size_t) ->
     *mut c_void;
    pub fn JS_realloc(cx: *mut Struct_JSContext, p: *mut c_void,
                      nbytes: size_t) -> *mut c_void;
    pub fn JS_free(cx: *mut Struct_JSContext, p: *mut c_void);
    pub fn JS_freeop(fop: *mut Struct_JSFreeOp, p: *mut c_void);
    pub fn JS_GetDefaultFreeOp(rt: *mut Struct_JSRuntime) ->
     *mut Struct_JSFreeOp;
    pub fn JS_updateMallocCounter(cx: *mut Struct_JSContext, nbytes: size_t);
    pub fn JS_strdup(rt: *mut Struct_JSRuntime, s: *const c_schar) -> *mut c_schar;
    pub fn JS_AddExtraGCRootsTracer(rt: *mut Struct_JSRuntime,
                                    traceOp: JSTraceDataOp, data: *mut c_void)
     -> bool;
    pub fn JS_RemoveExtraGCRootsTracer(rt: *mut Struct_JSRuntime,
                                       traceOp: JSTraceDataOp,
                                       data: *mut c_void);
    pub fn JS_GC(rt: *mut Struct_JSRuntime);
    pub fn JS_MaybeGC(cx: *mut Struct_JSContext);
    pub fn JS_SetGCCallback(rt: *mut Struct_JSRuntime, cb: JSGCCallback,
                            data: *mut c_void);
    pub fn JS_SetFinalizeCallback(rt: *mut Struct_JSRuntime,
                                  cb: JSFinalizeCallback);
    pub fn JS_IsGCMarkingTracer(trc: *mut c_void) -> bool;
    pub fn JS_IsAboutToBeFinalized(objp: *mut c_void) -> bool;
    pub fn JS_IsAboutToBeFinalizedUnbarriered(objp: *mut *mut c_void) ->
     bool;
    pub fn JS_SetGCParameter(rt: *mut Struct_JSRuntime, key: JSGCParamKey,
                             value: uint32_t);
    pub fn JS_GetGCParameter(rt: *mut Struct_JSRuntime, key: JSGCParamKey) ->
     uint32_t;
    pub fn JS_SetGCParameterForThread(cx: *mut Struct_JSContext,
                                      key: JSGCParamKey, value: uint32_t);
    pub fn JS_GetGCParameterForThread(cx: *mut Struct_JSContext,
                                      key: JSGCParamKey) -> uint32_t;
    pub fn JS_SetGCParametersBasedOnAvailableMemory(rt: *mut Struct_JSRuntime,
                                                    availMem: uint32_t);
    pub fn JS_NewExternalString(cx: *mut Struct_JSContext, chars: *const jschar,
                                length: size_t,
                                fin: *const Struct_JSStringFinalizer) ->
     *mut c_void;
    pub fn JS_IsExternalString(str: *mut c_void) -> bool;
    pub fn JS_GetExternalStringFinalizer(str: *mut c_void) ->
     *const Struct_JSStringFinalizer;
    pub fn JS_SetNativeStackQuota(cx: *mut Struct_JSRuntime,
                                  systemCodeStackSize: size_t,
                                  trustedScriptStackSize: size_t,
                                  untrustedScriptStackSize: size_t);
    pub fn JS_IdArrayLength(cx: *mut Struct_JSContext,
                            ida: *mut Struct_JSIdArray) -> c_int;
    pub fn JS_IdArrayGet(cx: *mut Struct_JSContext,
                         ida: *mut Struct_JSIdArray, index: c_int) ->
     Struct_jsid;
    pub fn JS_DestroyIdArray(cx: *mut Struct_JSContext,
                             ida: *mut Struct_JSIdArray);
    pub fn JS_ValueToId(cx: *mut Struct_JSContext, v: HandleValue,
                        idp: MutableHandleId) -> bool;
    pub fn JS_StringToId(cx: *mut Struct_JSContext, s: HandleString,
                         idp: MutableHandleId) -> bool;
    pub fn JS_IdToValue(cx: *mut Struct_JSContext, id: Struct_jsid,
                        vp: c_void) -> bool;
    pub fn JS_DefaultValue(cx: *mut Struct_JSContext, obj: c_void,
                           hint: Enum_JSType, vp: c_void) -> bool;
    pub fn JS_PropertyStub(cx: *mut Struct_JSContext, obj: HandleObject,
                           id: HandleId, vp: MutableHandleValue) -> bool;
    pub fn JS_StrictPropertyStub(cx: *mut Struct_JSContext, obj: HandleObject,
                                 id: HandleId, strict: bool,
                                 vp: MutableHandleValue) -> bool;
    pub fn JS_DeletePropertyStub(cx: *mut Struct_JSContext, obj: HandleObject,
                                 id: HandleId, succeeded: *mut bool) ->
     bool;
    pub fn JS_EnumerateStub(cx: *mut Struct_JSContext, obj: HandleObject) ->
     bool;
    pub fn JS_ResolveStub(cx: *mut Struct_JSContext, obj: HandleObject,
                          id: HandleId) -> bool;
    pub fn JS_ConvertStub(cx: *mut Struct_JSContext, obj: HandleObject,
                          _type: Enum_JSType, vp: MutableHandleValue) ->
     bool;
    pub fn JS_InitClass(cx: *mut Struct_JSContext, obj: HandleObject,
                        parent_proto: HandleObject, clasp: *const Struct_JSClass,
                        constructor: JSNative, nargs: c_uint,
                        ps: *const Struct_JSPropertySpec,
                        fs: *const Struct_JSFunctionSpec,
                        static_ps: *const Struct_JSPropertySpec,
                        static_fs: *const Struct_JSFunctionSpec) -> *mut c_void;
    pub fn JS_LinkConstructorAndPrototype(cx: *mut Struct_JSContext,
                                          ctor: JSHandleObject, proto: JSHandleObject) -> //jdm c_void->JSHandleObject
     bool;
    pub fn JS_GetClass(obj: *mut JSObject) -> *const Struct_JSClass; //jdm c_void->JSObject
    pub fn JS_InstanceOf(cx: *mut Struct_JSContext, obj: c_void,
                         clasp: *const Struct_JSClass, args: *mut c_void) -> bool;
    pub fn JS_HasInstance(cx: *mut Struct_JSContext, obj: c_void, v: c_void,
                          bp: *mut bool) -> bool;
    pub fn JS_GetPrivate(obj: *mut c_void) -> *mut c_void;
    pub fn JS_SetPrivate(obj: *mut c_void, data: *mut c_void);
    pub fn JS_GetInstancePrivate(cx: *mut Struct_JSContext, obj: c_void,
                                 clasp: *const Struct_JSClass, args: *mut c_void) ->
     *mut c_void;
    pub fn JS_GetPrototype(cx: *mut Struct_JSContext, obj: HandleObject,
                           protop: MutableHandleObject) -> bool;
    pub fn JS_SetPrototype(cx: *mut Struct_JSContext, obj: HandleObject,
                           proto: HandleObject) -> bool;
    pub fn JS_GetParent(obj: *mut c_void) -> *mut c_void;
    pub fn JS_SetParent(cx: *mut Struct_JSContext, obj: HandleObject,
                        parent: HandleObject) -> bool;
    pub fn JS_GetConstructor(cx: *mut Struct_JSContext, proto: c_void) ->
     *mut c_void;
    pub fn JS_NewGlobalObject(cx: *mut Struct_JSContext,
                              clasp: *const Struct_JSClass,
                              principals: *mut Struct_JSPrincipals,
                              hookOption: Enum_OnNewGlobalHookOption,
                              options: c_void) -> *mut c_void;
    pub fn JS_GlobalObjectTraceHook(trc: *mut JSTracer, global: *mut JSObject); //jdm c_void->JSTracer, c_void->JSObject
    pub fn JS_FireOnNewGlobalObject(cx: *mut Struct_JSContext,
                                    global: HandleObject);
    pub fn JS_NewObject(cx: *mut Struct_JSContext, clasp: *const Struct_JSClass,
                        proto: HandleObject, parent: HandleObject) -> *mut JSObject; //jdm c_void->HandleObject, c_void->JSObject
    pub fn JS_IsExtensible(cx: *mut Struct_JSContext, obj: HandleObject,
                           extensible: *mut bool) -> bool;
    pub fn JS_IsNative(obj: *mut c_void) -> bool;
    pub fn JS_GetObjectRuntime(obj: *mut c_void) -> *mut Struct_JSRuntime;
    pub fn JS_NewObjectWithGivenProto(cx: *mut Struct_JSContext,
                                      clasp: *const Struct_JSClass, proto: HandleObject, //jdm c_void->HandleObject
                                      parent: HandleObject) -> *mut JSObject; //jdm c_void->HandleObject,c_void->JSObject
    pub fn JS_DeepFreezeObject(cx: *mut Struct_JSContext, obj: c_void) ->
     bool;
    pub fn JS_FreezeObject(cx: *mut Struct_JSContext, obj: c_void) -> bool;
    pub fn JS_PreventExtensions(cx: *mut Struct_JSContext, obj: HandleObject)
     -> bool;
    pub fn JS_New(cx: *mut Struct_JSContext, ctor: HandleObject, args: c_void)
     -> *mut c_void;
    pub fn JS_DefineObject(cx: *mut Struct_JSContext, obj: *mut c_void,
                           name: *const c_schar, clasp: *const Struct_JSClass,
                           proto: *mut c_void, attrs: c_uint) -> *mut c_void;
    pub fn JS_DefineConstDoubles(cx: *mut Struct_JSContext, obj: HandleObject,
                                 cds: *const Struct_JSConstDoubleSpec) -> bool;
    pub fn JS_DefineProperties(cx: *mut Struct_JSContext, obj: HandleObject,
                               ps: *const Struct_JSPropertySpec) -> bool;
    pub fn JS_DefineProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                             name: *const c_schar, value: HandleValue,
                             attrs: c_uint, getter: JSPropertyOp,
                             setter: JSStrictPropertyOp) -> bool;
    pub fn JS_DefinePropertyById(cx: *mut Struct_JSContext, obj: *mut JSObject, //jdm c_void->JSObject
                                 id: Struct_jsid, value: jsval,
                                 getter: JSPropertyOp,
                                 setter: JSStrictPropertyOp, attrs: c_uint) ->
     bool;
    pub fn JS_DefineOwnProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                                id: HandleId, descriptor: HandleValue,
                                bp: *mut bool) -> bool;
    pub fn JS_AlreadyHasOwnProperty(cx: *mut Struct_JSContext,
                                    obj: HandleObject, name: *const c_schar,
                                    foundp: *mut bool) -> bool;
    pub fn JS_AlreadyHasOwnPropertyById(cx: *mut Struct_JSContext,
                                        obj: HandleObject, id: HandleId,
                                        foundp: *mut bool) -> bool;
    pub fn JS_HasProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                          name: *const c_schar, foundp: *mut bool) -> bool;
    pub fn JS_HasPropertyById(cx: *mut Struct_JSContext, obj: HandleObject,
                              id: HandleId, foundp: *mut bool) -> bool;
    pub fn JS_LookupProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                             name: *const c_schar, vp: MutableHandleValue) -> bool;
    pub fn JS_LookupPropertyById(cx: *mut Struct_JSContext, obj: HandleObject,
                                 id: HandleId, vp: MutableHandleValue) ->
     bool;
    pub fn JS_LookupPropertyWithFlags(cx: *mut Struct_JSContext,
                                      obj: HandleObject, name: *const c_schar,
                                      flags: c_uint, vp: MutableHandleValue)
     -> bool;
    pub fn JS_LookupPropertyWithFlagsById(cx: *mut Struct_JSContext,
                                          obj: HandleObject, id: HandleId,
                                          flags: c_uint,
                                          objp: MutableHandleObject,
                                          vp: MutableHandleValue) -> bool;
    pub fn JS_GetOwnPropertyDescriptorById(cx: *mut Struct_JSContext,
                                           obj: HandleObject, id: HandleId,
                                           flags: c_uint, desc: c_void) ->
     bool;
    pub fn JS_GetOwnPropertyDescriptor(cx: *mut Struct_JSContext,
                                       obj: HandleObject, name: *const c_schar,
                                       flags: c_uint, desc: c_void) -> bool;
    pub fn JS_GetPropertyDescriptorById(cx: *mut Struct_JSContext,
                                        obj: HandleObject, id: HandleId,
                                        flags: c_uint, desc: MutableHandle<JSPropertyDescriptor>) -> bool; //jdm c_void->JSMutableHandle
    pub fn JS_GetPropertyDescriptor(cx: *mut Struct_JSContext,
                                    obj: HandleObject, name: *const c_schar,
                                    flags: c_uint, desc: c_void) -> bool;
    pub fn JS_GetProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                          name: *const c_schar, vp: MutableHandleValue) -> bool;
    pub fn JS_GetPropertyById(cx: *mut Struct_JSContext, obj: HandleObject,
                              id: HandleId, vp: MutableHandleValue) -> bool;
    pub fn JS_ForwardGetPropertyTo(cx: *mut Struct_JSContext,
                                   obj: HandleObject, id: HandleId,
                                   onBehalfOf: HandleObject,
                                   vp: MutableHandleValue) -> bool;
    pub fn JS_SetProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                          name: *const c_schar, v: HandleValue) -> bool;
    pub fn JS_SetPropertyById(cx: *mut Struct_JSContext, obj: HandleObject,
                              id: HandleId, v: HandleValue) -> bool;
    pub fn JS_DeleteProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                             name: *const c_schar) -> bool;
    pub fn JS_DeleteProperty2(cx: *mut Struct_JSContext, obj: HandleObject,
                              name: *const c_schar, succeeded: *mut bool) -> bool;
    pub fn JS_DeletePropertyById(cx: *mut Struct_JSContext, obj: HandleObject,
                                 id: Struct_jsid) -> bool;
    pub fn JS_DeletePropertyById2(cx: *mut Struct_JSContext,
                                  obj: HandleObject, id: HandleId,
                                  succeeded: *mut bool) -> bool;
    pub fn JS_DefineUCProperty(cx: *mut Struct_JSContext, obj: *mut c_void,
                               name: *const jschar, namelen: size_t, value: jsval,
                               getter: JSPropertyOp,
                               setter: JSStrictPropertyOp, attrs: c_uint) ->
     bool;
    pub fn JS_AlreadyHasOwnUCProperty(cx: *mut Struct_JSContext,
                                      obj: HandleObject, name: *const jschar,
                                      namelen: size_t, foundp: *mut bool) ->
     bool;
    pub fn JS_HasUCProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                            name: *const jschar, namelen: size_t, vp: *mut bool) ->
     bool;
    pub fn JS_LookupUCProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                               name: *const jschar, namelen: size_t,
                               vp: MutableHandleValue) -> bool;
    pub fn JS_GetUCProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                            name: *const jschar, namelen: size_t,
                            vp: MutableHandleValue) -> bool;
    pub fn JS_SetUCProperty(cx: *mut Struct_JSContext, obj: HandleObject,
                            name: *const jschar, namelen: size_t, v: HandleValue) ->
     bool;
    pub fn JS_DeleteUCProperty2(cx: *mut Struct_JSContext, obj: HandleObject,
                                name: *const jschar, namelen: size_t,
                                succeeded: *mut bool) -> bool;
    pub fn JS_NewArrayObject(cx: *mut Struct_JSContext, length: size_t) ->
     *mut c_void;
    pub fn JS_IsArrayObject(cx: *mut Struct_JSContext, obj: HandleObject) ->
     bool;
    pub fn JS_GetArrayLength(cx: *mut Struct_JSContext, obj: c_void,
                             lengthp: *mut uint32_t) -> bool;
    pub fn JS_SetArrayLength(cx: *mut Struct_JSContext, obj: c_void,
                             length: uint32_t) -> bool;
    pub fn JS_DefineElement(cx: *mut Struct_JSContext, obj: *mut c_void,
                            index: uint32_t, value: jsval,
                            getter: JSPropertyOp, setter: JSStrictPropertyOp,
                            attrs: c_uint) -> bool;
    pub fn JS_AlreadyHasOwnElement(cx: *mut Struct_JSContext,
                                   obj: HandleObject, index: uint32_t,
                                   foundp: *mut bool) -> bool;
    pub fn JS_HasElement(cx: *mut Struct_JSContext, obj: HandleObject,
                         index: uint32_t, foundp: *mut bool) -> bool;
    pub fn JS_LookupElement(cx: *mut Struct_JSContext, obj: HandleObject,
                            index: uint32_t, vp: MutableHandleValue) -> bool;
    pub fn JS_GetElement(cx: *mut Struct_JSContext, obj: HandleObject,
                         index: uint32_t, vp: MutableHandleValue) -> bool;
    pub fn JS_ForwardGetElementTo(cx: *mut Struct_JSContext,
                                  obj: HandleObject, index: uint32_t,
                                  onBehalfOf: HandleObject,
                                  vp: MutableHandleValue) -> bool;
    pub fn JS_SetElement(cx: *mut Struct_JSContext, obj: HandleObject,
                         index: uint32_t, v: HandleObject) -> bool;
    pub fn JS_DeleteElement(cx: *mut Struct_JSContext, obj: HandleObject,
                            index: uint32_t) -> bool;
    pub fn JS_DeleteElement2(cx: *mut Struct_JSContext, obj: HandleObject,
                             index: uint32_t, succeeded: *mut bool) -> bool;
    pub fn JS_ClearNonGlobalObject(cx: *mut Struct_JSContext,
                                   obj: HandleObject);
    pub fn JS_SetAllNonReservedSlotsToUndefined(cx: *mut Struct_JSContext,
                                                objArg: *mut c_void);
    pub fn JS_NewArrayBufferWithContents(cx: *mut Struct_JSContext,
                                         nbytes: size_t,
                                         contents: *mut c_void) ->
     *mut c_void;
    pub fn JS_StealArrayBufferContents(cx: *mut Struct_JSContext,
                                       obj: HandleObject) -> *mut c_void;
    pub fn JS_AllocateArrayBufferContents(maybecx: *mut Struct_JSContext,
                                          nbytes: uint32_t) -> *mut c_void;
    pub fn JS_ReallocateArrayBufferContents(cx: *mut Struct_JSContext,
                                            nbytes: uint32_t,
                                            oldContents: *mut c_void,
                                            oldNbytes: uint32_t) ->
     *mut c_void;
    pub fn JS_NewMappedArrayBufferWithContents(cx: *mut Struct_JSContext,
                                               nbytes: size_t,
                                               contents: *mut c_void) ->
     *mut c_void;
    pub fn JS_CreateMappedArrayBufferContents(fd: c_int, offset: size_t,
                                              length: size_t) -> *mut c_void;
    pub fn JS_ReleaseMappedArrayBufferContents(contents: *mut c_void,
                                               length: size_t);
    pub fn JS_Enumerate(cx: *mut Struct_JSContext, obj: HandleObject) ->
     *mut Struct_JSIdArray;
    pub fn JS_NewPropertyIterator(cx: *mut Struct_JSContext, obj: c_void) ->
     *mut c_void;
    pub fn JS_NextProperty(cx: *mut Struct_JSContext, iterobj: c_void,
                           idp: *mut Struct_jsid) -> bool;
    pub fn JS_GetReservedSlot(obj: *mut JSObject, index: uint32_t) -> jsval;
    pub fn JS_SetReservedSlot(obj: *mut JSObject, index: uint32_t, v: jsval);
    pub fn JS_NewFunction(cx: *mut Struct_JSContext, call: JSNative,
                          nargs: c_uint, flags: c_uint, parent: JSHandleObject, //jdm c_void->JSHandleObject
                          name: *const c_schar) -> *mut JSFunction; //jdm c_void->JSFunction
    pub fn JS_NewFunctionById(cx: *mut Struct_JSContext, call: JSNative,
                              nargs: c_uint, flags: c_uint, parent: c_void,
                              id: c_void) -> *mut c_void;
    pub fn JS_GetFunctionObject(fun: *mut JSFunction) -> *mut JSObject; //jdm c_void->JSFunction,c_void->JSObject
    pub fn JS_GetFunctionId(fun: *mut c_void) -> *mut c_void;
    pub fn JS_GetFunctionDisplayId(fun: *mut c_void) -> *mut c_void;
    pub fn JS_GetFunctionArity(fun: *mut c_void) -> uint16_t;
    pub fn JS_ObjectIsFunction(cx: *mut Struct_JSContext, obj: *mut c_void) ->
     bool;
    pub fn JS_ObjectIsCallable(cx: *mut Struct_JSContext, obj: *mut JSObject) -> //jdm c_void->JSObject
     bool;
    pub fn JS_IsNativeFunction(funobj: *mut c_void, call: JSNative) -> bool;
    pub fn JS_IsConstructor(fun: *mut c_void) -> bool;
    pub fn JS_BindCallable(cx: *mut Struct_JSContext, callable: c_void,
                           newThis: c_void) -> *mut c_void;
    pub fn JS_DefineFunctions(cx: *mut Struct_JSContext, obj: JSHandleObject, //jdm c_void->JSHandleObject
                              fs: *const Struct_JSFunctionSpec) -> bool;
    pub fn JS_DefineFunction(cx: *mut Struct_JSContext, obj: c_void,
                             name: *const c_schar, call: JSNative, nargs: c_uint,
                             attrs: c_uint) -> *mut c_void;
    pub fn JS_DefineUCFunction(cx: *mut Struct_JSContext, obj: c_void,
                               name: *const jschar, namelen: size_t, call: JSNative,
                               nargs: c_uint, attrs: c_uint) -> *mut c_void;
    pub fn JS_DefineFunctionById(cx: *mut Struct_JSContext, obj: c_void,
                                 id: c_void, call: JSNative, nargs: c_uint,
                                 attrs: c_uint) -> *mut c_void;
    pub fn JS_CloneFunctionObject(cx: *mut Struct_JSContext, funobj: JSHandleObject,
                                  parent: JSHandleObject) -> *mut JSObject; //jdm +handles, c_void->JSObject
    pub fn JS_BufferIsCompilableUnit(cx: *mut Struct_JSContext, obj: c_void,
                                     utf8: *const c_schar, length: size_t) -> bool;
    pub fn JS_CompileScript(cx: *mut Struct_JSContext, obj: HandleObject,
                            ascii: *const c_schar, length: size_t, options: c_void)
     -> *mut c_void;
    pub fn JS_CompileUCScript(cx: *mut Struct_JSContext, obj: HandleObject,
                              chars: *const jschar, length: size_t, options: c_void)
     -> *mut c_void;
    pub fn JS_GetGlobalFromScript(script: *mut c_void) -> *mut c_void;
    pub fn JS_CompileFunction(cx: *mut Struct_JSContext, obj: HandleObject,
                              name: *const c_schar, nargs: c_uint,
                              argnames: *const *const c_schar, bytes: *const c_schar,
                              length: size_t, options: c_void) -> *mut c_void;
    pub fn JS_CompileUCFunction(cx: *mut Struct_JSContext, obj: HandleObject,
                                name: *const c_schar, nargs: c_uint,
                                argnames: *const *const c_schar, chars: *const jschar,
                                length: size_t, options: c_void) ->
     *mut c_void;
    pub fn JS_DecompileScript(cx: *mut Struct_JSContext, script: c_void,
                              name: *const c_schar, indent: c_uint) -> *mut c_void;
    pub fn JS_DecompileFunction(cx: *mut Struct_JSContext, fun: c_void,
                                indent: c_uint) -> *mut c_void;
    pub fn JS_DecompileFunctionBody(cx: *mut Struct_JSContext, fun: c_void,
                                    indent: c_uint) -> *mut c_void;
    pub fn JS_ExecuteScript(cx: *mut Struct_JSContext, obj: HandleObject,
                            script: HandleScript, rval: MutableHandleValue) ->
     bool;
    pub fn JS_ExecuteScriptVersion(cx: *mut Struct_JSContext,
                                   obj: HandleObject, script: HandleScript,
                                   rval: MutableHandleValue,
                                   version: Enum_JSVersion) -> bool;
    pub fn JS_EvaluateScript(cx: *mut Struct_JSContext, obj: HandleObject,
                             bytes: *const c_schar, length: c_uint,
                             filename: *const c_schar, lineno: c_uint,
                             rval: MutableHandleValue) -> bool;
    pub fn JS_EvaluateUCScript(cx: *mut Struct_JSContext, obj: HandleObject, //jdm c_void->HandleObject
                               chars: *const jschar, length: c_uint,
                               filename: *const c_schar, lineno: c_uint,
                               rval: JSMutableHandleValue) -> bool; //jdm c_void->JSMutableHandleValue
    pub fn JS_CallFunction(cx: *mut Struct_JSContext, obj: HandleObject,
                           fun: HandleFunction, args: c_void,
                           rval: MutableHandleValue) -> bool;
    pub fn JS_CallFunctionName(cx: *mut Struct_JSContext, obj: HandleObject,
                               name: *const c_schar, args: c_void,
                               rval: MutableHandleValue) -> bool;
    pub fn JS_CallFunctionValue(cx: *mut Struct_JSContext, obj: HandleObject,
                                fval: HandleValue, args: c_void,
                                rval: MutableHandleValue) -> bool;
    pub fn JS_SetInterruptCallback(rt: *mut Struct_JSRuntime,
                                   callback: JSInterruptCallback) ->
     JSInterruptCallback;
    pub fn JS_GetInterruptCallback(rt: *mut Struct_JSRuntime) ->
     JSInterruptCallback;
    pub fn JS_RequestInterruptCallback(rt: *mut Struct_JSRuntime);
    pub fn JS_IsRunning(cx: *mut Struct_JSContext) -> bool;
    pub fn JS_SaveFrameChain(cx: *mut Struct_JSContext) -> bool;
    pub fn JS_RestoreFrameChain(cx: *mut Struct_JSContext);
    pub fn JS_NewStringCopyN(cx: *mut Struct_JSContext, s: *const c_schar,
                             n: size_t) -> *mut JSString; //jdm c_void->JSString
    pub fn JS_NewStringCopyZ(cx: *mut Struct_JSContext, s: *const c_schar) ->
     *mut c_void;
    pub fn JS_InternJSString(cx: *mut Struct_JSContext, str: HandleString) ->
     *mut c_void;
    pub fn JS_InternStringN(cx: *mut Struct_JSContext, s: *const c_schar,
                            length: size_t) -> *mut c_void;
    pub fn JS_InternString(cx: *mut Struct_JSContext, s: *const c_schar) ->
     *mut c_void;
    pub fn JS_NewUCString(cx: *mut Struct_JSContext, chars: *mut jschar,
                          length: size_t) -> *mut JSString; //jdm c_void->JSString
    pub fn JS_NewUCStringCopyN(cx: *mut Struct_JSContext, s: *const jschar,
                               n: size_t) -> *mut JSString; //jdm -> c_void->JSString
    pub fn JS_NewUCStringCopyZ(cx: *mut Struct_JSContext, s: *const jschar) ->
     *mut c_void;
    pub fn JS_InternUCStringN(cx: *mut Struct_JSContext, s: *const jschar,
                              length: size_t) -> *mut c_void;
    pub fn JS_InternUCString(cx: *mut Struct_JSContext, s: *const jschar) ->
     *mut c_void;
    pub fn JS_CompareStrings(cx: *mut Struct_JSContext, str1: *mut c_void,
                             str2: *mut c_void, result: *mut int32_t) ->
     bool;
    pub fn JS_StringEqualsAscii(cx: *mut Struct_JSContext, str: *mut c_void,
                                asciiBytes: *const c_schar, _match: *mut bool) ->
     bool;
    pub fn JS_PutEscapedString(cx: *mut Struct_JSContext,
                               buffer: *mut c_schar, size: size_t,
                               str: *mut c_void, quote: c_schar) -> size_t;
    pub fn JS_FileEscapedString(fp: *mut FILE, str: *mut c_void,
                                quote: c_schar) -> bool;
    pub fn JS_GetStringLength(str: *mut c_void) -> size_t;
    pub fn JS_GetStringCharsAndLength(cx: *mut Struct_JSContext,
                                      str: *mut JSString, length: *mut size_t) //jdm c_void->JSString
     -> *const jschar;
    pub fn JS_GetInternedStringChars(str: *mut c_void) -> *const jschar;
    pub fn JS_GetInternedStringCharsAndLength(str: *mut c_void,
                                              length: *mut size_t) -> *const jschar;
    pub fn JS_GetStringCharsZ(cx: *mut Struct_JSContext, str: *mut c_void) ->
     *const jschar;
    pub fn JS_GetStringCharsZAndLength(cx: *mut Struct_JSContext,
                                       str: *mut c_void, length: *mut size_t)
     -> *const jschar;
    pub fn JS_FlattenString(cx: *mut Struct_JSContext, str: *mut c_void) ->
     *mut c_void;
    pub fn JS_GetFlatStringChars(str: *mut c_void) -> *const jschar;
    pub fn JS_FlatStringEqualsAscii(str: *mut c_void, asciiBytes: *const c_schar) ->
     bool;
    pub fn JS_PutEscapedFlatString(buffer: *mut c_schar, size: size_t,
                                   str: *mut c_void, quote: c_schar) ->
     size_t;
    pub fn JS_NewDependentString(cx: *mut Struct_JSContext, str: HandleString,
                                 start: size_t, length: size_t) ->
     *mut c_void;
    pub fn JS_ConcatStrings(cx: *mut Struct_JSContext, left: HandleString,
                            right: HandleString) -> *mut c_void;
    pub fn JS_DecodeBytes(cx: *mut Struct_JSContext, src: *const c_schar,
                          srclen: size_t, dst: *mut jschar,
                          dstlenp: *mut size_t) -> bool;
    pub fn JS_EncodeString(cx: *mut Struct_JSContext, str: *mut c_void) ->
     *mut c_schar;
    pub fn JS_EncodeStringToUTF8(cx: *mut Struct_JSContext, str: HandleString)
     -> *mut c_schar;
    pub fn JS_GetStringEncodingLength(cx: *mut Struct_JSContext,
                                      str: *mut c_void) -> size_t;
    pub fn JS_EncodeStringToBuffer(cx: *mut Struct_JSContext,
                                   str: *mut c_void, buffer: *mut c_schar,
                                   length: size_t) -> size_t;
    pub fn JS_Stringify(cx: *mut Struct_JSContext, value: MutableHandleValue,
                        replacer: HandleObject, space: HandleValue,
                        callback: JSONWriteCallback, data: *mut c_void) ->
     bool;
    pub fn JS_ParseJSON(cx: *mut Struct_JSContext, chars: *const jschar,
                        len: uint32_t, vp: MutableHandleValue) -> bool;
    pub fn JS_ParseJSONWithReviver(cx: *mut Struct_JSContext, chars: *const jschar,
                                   len: uint32_t, reviver: HandleValue,
                                   vp: MutableHandleValue) -> bool;
    pub fn JS_SetDefaultLocale(rt: *mut Struct_JSRuntime, locale: *const c_schar) ->
     bool;
    pub fn JS_ResetDefaultLocale(rt: *mut Struct_JSRuntime);
    pub fn JS_SetLocaleCallbacks(rt: *mut Struct_JSRuntime,
                                 callbacks: *mut Struct_JSLocaleCallbacks);
    pub fn JS_GetLocaleCallbacks(rt: *mut Struct_JSRuntime) ->
     *mut Struct_JSLocaleCallbacks;
    pub fn JS_ReportError(cx: *mut Struct_JSContext, format: *const c_schar, ...);
    pub fn JS_ReportErrorNumber(cx: *mut Struct_JSContext,
                                errorCallback: JSErrorCallback,
                                userRef: *mut c_void,
                                errorNumber: c_uint, ...);
    pub fn JS_ReportErrorNumberVA(cx: *mut Struct_JSContext,
                                  errorCallback: JSErrorCallback,
                                  userRef: *mut c_void, errorNumber: c_uint,
                                  ap: va_list);
    pub fn JS_ReportErrorNumberUC(cx: *mut Struct_JSContext,
                                  errorCallback: JSErrorCallback,
                                  userRef: *mut c_void,
                                  errorNumber: c_uint, ...);
    pub fn JS_ReportErrorNumberUCArray(cx: *mut Struct_JSContext,
                                       errorCallback: JSErrorCallback,
                                       userRef: *mut c_void,
                                       errorNumber: c_uint,
                                       args: *mut *const jschar);
    pub fn JS_ReportWarning(cx: *mut Struct_JSContext, format: *const c_schar, ...)
     -> bool;
    pub fn JS_ReportErrorFlagsAndNumber(cx: *mut Struct_JSContext,
                                        flags: c_uint,
                                        errorCallback: JSErrorCallback,
                                        userRef: *mut c_void,
                                        errorNumber: c_uint, ...) -> bool;
    pub fn JS_ReportErrorFlagsAndNumberUC(cx: *mut Struct_JSContext,
                                          flags: c_uint,
                                          errorCallback: JSErrorCallback,
                                          userRef: *mut c_void,
                                          errorNumber: c_uint, ...) -> bool;
    pub fn JS_ReportOutOfMemory(cx: *mut Struct_JSContext);
    pub fn JS_ReportAllocationOverflow(cx: *mut Struct_JSContext);
    pub fn JS_GetErrorReporter(cx: *mut Struct_JSContext) -> JSErrorReporter;
    pub fn JS_SetErrorReporter(cx: *mut Struct_JSContext, er: JSErrorReporter)
     -> JSErrorReporter;
    pub fn JS_NewDateObject(cx: *mut Struct_JSContext, year: c_int,
                            mon: c_int, mday: c_int, hour: c_int, min: c_int,
                            sec: c_int) -> *mut c_void;
    pub fn JS_NewDateObjectMsec(cx: *mut Struct_JSContext, msec: c_double) ->
     *mut c_void;
    pub fn JS_ObjectIsDate(cx: *mut Struct_JSContext, obj: HandleObject) ->
     bool;
    pub fn JS_ClearDateCaches(cx: *mut Struct_JSContext);
    pub fn JS_NewRegExpObject(cx: *mut Struct_JSContext, obj: HandleObject,
                              bytes: *mut c_schar, length: size_t,
                              flags: c_uint) -> *mut c_void;
    pub fn JS_NewUCRegExpObject(cx: *mut Struct_JSContext, obj: HandleObject,
                                chars: *mut jschar, length: size_t,
                                flags: c_uint) -> *mut c_void;
    pub fn JS_SetRegExpInput(cx: *mut Struct_JSContext, obj: HandleObject,
                             input: HandleString, multiline: bool);
    pub fn JS_ClearRegExpStatics(cx: *mut Struct_JSContext,
                                 obj: HandleObject);
    pub fn JS_ExecuteRegExp(cx: *mut Struct_JSContext, obj: HandleObject,
                            reobj: HandleObject, chars: *mut jschar,
                            length: size_t, indexp: *mut size_t, test: bool,
                            rval: MutableHandleValue) -> bool;
    pub fn JS_NewRegExpObjectNoStatics(cx: *mut Struct_JSContext,
                                       bytes: *mut c_schar, length: size_t,
                                       flags: c_uint) -> *mut c_void;
    pub fn JS_NewUCRegExpObjectNoStatics(cx: *mut Struct_JSContext,
                                         chars: *mut jschar, length: size_t,
                                         flags: c_uint) -> *mut c_void;
    pub fn JS_ExecuteRegExpNoStatics(cx: *mut Struct_JSContext,
                                     reobj: HandleObject, chars: *mut jschar,
                                     length: size_t, indexp: *mut size_t,
                                     test: bool, rval: MutableHandleValue) ->
     bool;
    pub fn JS_ObjectIsRegExp(cx: *mut Struct_JSContext, obj: HandleObject) ->
     bool;
    pub fn JS_GetRegExpFlags(cx: *mut Struct_JSContext, obj: HandleObject) ->
     c_uint;
    pub fn JS_GetRegExpSource(cx: *mut Struct_JSContext, obj: HandleObject) ->
     *mut c_void;
    pub fn JS_IsExceptionPending(cx: *mut Struct_JSContext) -> bool;
    pub fn JS_GetPendingException(cx: *mut Struct_JSContext,
                                  vp: MutableHandleValue) -> bool;
    pub fn JS_SetPendingException(cx: *mut Struct_JSContext, v: HandleValue);
    pub fn JS_ClearPendingException(cx: *mut Struct_JSContext);
    pub fn JS_ReportPendingException(cx: *mut Struct_JSContext) -> bool;
    pub fn JS_SaveExceptionState(cx: *mut Struct_JSContext) ->
     *mut Struct_JSExceptionState;
    pub fn JS_RestoreExceptionState(cx: *mut Struct_JSContext,
                                    state: *mut Struct_JSExceptionState);
    pub fn JS_DropExceptionState(cx: *mut Struct_JSContext,
                                 state: *mut Struct_JSExceptionState);
    pub fn JS_ErrorFromException(cx: *mut Struct_JSContext, obj: HandleObject)
     -> *mut Struct_JSErrorReport;
    pub fn JS_ThrowStopIteration(cx: *mut Struct_JSContext) -> bool;
    pub fn JS_IsStopIteration(v: jsval) -> bool;
    pub fn JS_GetCurrentThread() -> intptr_t;
    pub fn JS_AbortIfWrongThread(rt: *mut Struct_JSRuntime);
    pub fn JS_SetNativeStackBounds(rt: *mut Struct_JSRuntime,
                                   minValue: uintptr_t, maxValue: uintptr_t);
    pub fn JS_NewObjectForConstructor(cx: *mut Struct_JSContext,
                                      clasp: *const Struct_JSClass, args: c_void) ->
     *mut c_void;
    pub fn JS_SetGCZeal(cx: *mut Struct_JSContext, zeal: uint8_t,
                        frequency: uint32_t);
    pub fn JS_ScheduleGC(cx: *mut Struct_JSContext, count: uint32_t);
    pub fn JS_SetParallelParsingEnabled(rt: *mut Struct_JSRuntime,
                                        enabled: bool);
    pub fn JS_SetParallelIonCompilationEnabled(rt: *mut Struct_JSRuntime,
                                               enabled: bool);
    pub fn JS_SetGlobalJitCompilerOption(rt: *mut Struct_JSRuntime,
                                         opt: JSJitCompilerOption,
                                         value: uint32_t);
    pub fn JS_GetGlobalJitCompilerOption(rt: *mut Struct_JSRuntime,
                                         opt: JSJitCompilerOption) -> bool;
    pub fn JS_IndexToId(cx: *mut Struct_JSContext, index: uint32_t,
                        arg1: MutableHandleId) -> bool;
    pub fn JS_CharsToId(cx: *mut Struct_JSContext, chars: c_void,
                        arg1: MutableHandleId) -> bool;
    pub fn JS_IsIdentifier(cx: *mut Struct_JSContext, str: HandleString,
                           isIdentifier: *mut bool) -> bool;
    pub fn JS_EncodeScript(cx: *mut Struct_JSContext, script: HandleScript,
                           lengthp: *mut uint32_t) -> *mut c_void;
    pub fn JS_EncodeInterpretedFunction(cx: *mut Struct_JSContext,
                                        funobj: HandleObject,
                                        lengthp: *mut uint32_t) ->
     *mut c_void;
    pub fn JS_DecodeScript(cx: *mut Struct_JSContext, data: *const c_void,
                           length: uint32_t,
                           originPrincipals: *mut Struct_JSPrincipals) ->
     *mut c_void;
    pub fn JS_DecodeInterpretedFunction(cx: *mut Struct_JSContext,
                                        data: *const c_void, length: uint32_t,
                                        originPrincipals:
                                            *mut Struct_JSPrincipals) ->
     *mut c_void;
}

/* end automatically generated code */

#[repr(C)]
pub struct MutableHandle<'a, T: 'a> {
    pub unnamed_field1: &'a mut T,
}

#[repr(C)]
pub struct Handle<'a, T: 'a> {
    pub unnamed_field1: &'a T,
}

pub type HandleFunction<'a> = Handle<'a, *mut JSFunction>;
pub type HandleId<'a> = Handle<'a, jsid>;
pub type HandleObject<'a> = Handle<'a, *mut JSObject>;
pub type HandleScript<'a> = Handle<'a, *mut JSScript>;
pub type HandleString<'a> = Handle<'a, *mut JSString>;
pub type HandleValue<'a> = Handle<'a, JSVal>;
pub type MutableHandleId<'a> = MutableHandle<'a, jsid>;
pub type MutableHandleObject<'a> = MutableHandle<'a, *mut JSObject>;
pub type MutableHandleValue<'a> = MutableHandle<'a, JSVal>;
pub type JSHandleFunction<'a> = Handle<'a, *mut JSFunction>;
pub type JSHandleId<'a> = Handle<'a, jsid>;
pub type JSHandleObject<'a> = Handle<'a, *mut JSObject>;
pub type JSHandleScript<'a> = Handle<'a, *mut JSScript>;
pub type JSHandleString<'a> = Handle<'a, *mut JSString>;
pub type JSHandleValue<'a> = Handle<'a, JSVal>;
pub type JSMutableHandleId<'a> = MutableHandle<'a, jsid>;
pub type JSMutableHandleObject<'a> = MutableHandle<'a, *mut JSObject>;
pub type JSMutableHandleValue<'a> = MutableHandle<'a, JSVal>;

#[repr(C)]
pub struct JSTracer(c_void);
#[repr(C)]
pub struct JSRuntime;
#[repr(C)]
pub struct JSContext;
#[repr(C)]
pub struct JSObject;
//pub type jsid = ptrdiff_t;
pub type jsid = Struct_jsid;
pub type JSFunctionSpec = Struct_JSFunctionSpec;
pub type JSPropertyDescriptor = Struct_JSPropertyDescriptor;
pub enum JSFunction {}
pub type JSFreeOp = Struct_JSFreeOp;
pub enum JSString {}
pub type JSErrorReport = Struct_JSErrorReport;
pub type JSClass = Struct_JSClass;
pub type JSPropertySpec = Struct_JSPropertySpec;
pub type Struct_ForkJoinContext= c_void;
pub type Struct_ThreadSafeContext= c_void;
pub type Struct_Zone= c_void;
pub type va_list= c_void;
pub type Enum_OnNewGlobalHookOption = uint;
pub type JSVersion = Enum_JSVersion;
pub type JSScript= c_void;
pub type jsval = JSVal;
pub type JSPrincipals = Struct_JSPrincipals;
pub type Struct_JSJitInfo = JSJitInfo;
pub type JSGCTraceKind = Enum_JSGCTraceKind;

impl<'a, T> Deref<T> for Handle<'a, T> {
    fn deref<'b>(&'b self) -> &'b T {
        &*self.unnamed_field1
    }
}

impl<'a, T> MutableHandle<'a, T> {
    pub fn immut<'b>(&'b self) -> Handle<'b, T> {
        Handle {
            unnamed_field1: &*self.unnamed_field1
        }
    }

    pub fn clone<'b>(&'b mut self) -> MutableHandle<'b, T> {
        MutableHandle {
            unnamed_field1: &mut *self.unnamed_field1
        }
    }
}

impl<'a, T> Deref<T> for MutableHandle<'a, T> {
    fn deref<'b>(&'b self) -> &'b T {
        &*self.unnamed_field1
    }
}

impl<'a, T> DerefMut<T> for MutableHandle<'a, T> {
    fn deref_mut<'b>(&'b mut self) -> &'b mut T {
        &mut *self.unnamed_field1
    }
}

/* automatically generated by rust-bindgen */

#[derive(Copy, Debug)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
pub const JSVAL_INT_BITS: ::std::os::raw::c_uint = 32;
pub const JSVAL_TAG_SHIFT: ::std::os::raw::c_uint = 47;
pub const JSID_TYPE_STRING: ::std::os::raw::c_uint = 0;
pub const JSID_TYPE_INT: ::std::os::raw::c_uint = 1;
pub const JSID_TYPE_VOID: ::std::os::raw::c_uint = 2;
pub const JSID_TYPE_SYMBOL: ::std::os::raw::c_uint = 4;
pub const JSID_TYPE_MASK: ::std::os::raw::c_uint = 7;
pub const JSID_INT_MIN: ::std::os::raw::c_uint = 0;
pub const JSCLASS_RESERVED_SLOTS_SHIFT: ::std::os::raw::c_uint = 8;
pub const JSCLASS_RESERVED_SLOTS_WIDTH: ::std::os::raw::c_uint = 8;
pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: ::std::os::raw::c_uint = 5;
pub const JSCLASS_NO_OPTIONAL_MEMBERS: ::std::os::raw::c_uint = 0;
pub const JS_STRUCTURED_CLONE_VERSION: ::std::os::raw::c_uint = 6;
pub const JS_SCERR_RECURSION: ::std::os::raw::c_uint = 0;
pub const JS_SCERR_TRANSFERABLE: ::std::os::raw::c_uint = 1;
pub const JS_SCERR_DUP_TRANSFERABLE: ::std::os::raw::c_uint = 2;
pub const JSPROP_ENUMERATE: ::std::os::raw::c_uint = 1;
pub const JSPROP_READONLY: ::std::os::raw::c_uint = 2;
pub const JSPROP_PERMANENT: ::std::os::raw::c_uint = 4;
pub const JSPROP_PROPOP_ACCESSORS: ::std::os::raw::c_uint = 8;
pub const JSPROP_GETTER: ::std::os::raw::c_uint = 16;
pub const JSPROP_SETTER: ::std::os::raw::c_uint = 32;
pub const JSPROP_SHARED: ::std::os::raw::c_uint = 64;
pub const JSPROP_INTERNAL_USE_BIT: ::std::os::raw::c_uint = 128;
pub const JSFUN_STUB_GSOPS: ::std::os::raw::c_uint = 512;
pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
pub const JSFUN_GENERIC_NATIVE: ::std::os::raw::c_uint = 2048;
pub const JSFUN_HAS_REST: ::std::os::raw::c_uint = 4096;
pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 7680;
pub const JSPROP_REDEFINE_NONCONFIGURABLE: ::std::os::raw::c_uint = 4096;
pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8192;
pub const JSPROP_IGNORE_ENUMERATE: ::std::os::raw::c_uint = 16384;
pub const JSPROP_IGNORE_READONLY: ::std::os::raw::c_uint = 32768;
pub const JSPROP_IGNORE_PERMANENT: ::std::os::raw::c_uint = 65536;
pub const JSPROP_IGNORE_VALUE: ::std::os::raw::c_uint = 131072;
pub const JSREPORT_ERROR: ::std::os::raw::c_uint = 0;
pub const JSREPORT_WARNING: ::std::os::raw::c_uint = 1;
pub const JSREPORT_EXCEPTION: ::std::os::raw::c_uint = 2;
pub const JSREPORT_STRICT: ::std::os::raw::c_uint = 4;
pub const JSREPORT_STRICT_MODE_ERROR: ::std::os::raw::c_uint = 8;
pub const JS_DEFAULT_ZEAL_FREQ: ::std::os::raw::c_uint = 100;
pub const JSITER_ENUMERATE: ::std::os::raw::c_uint = 1;
pub const JSITER_FOREACH: ::std::os::raw::c_uint = 2;
pub const JSITER_KEYVALUE: ::std::os::raw::c_uint = 4;
pub const JSITER_OWNONLY: ::std::os::raw::c_uint = 8;
pub const JSITER_HIDDEN: ::std::os::raw::c_uint = 16;
pub const JSITER_SYMBOLS: ::std::os::raw::c_uint = 32;
pub const JSITER_SYMBOLSONLY: ::std::os::raw::c_uint = 64;
pub const JITINFO_OP_TYPE_BITS: ::std::os::raw::c_uint = 4;
pub const JITINFO_ALIAS_SET_BITS: ::std::os::raw::c_uint = 4;
pub const JITINFO_RETURN_TYPE_BITS: ::std::os::raw::c_uint = 8;
pub const JITINFO_SLOT_INDEX_BITS: ::std::os::raw::c_uint = 10;
pub type HashNumber = u32;
pub type MallocSizeOf =
    ::std::option::Option<unsafe extern "C" fn(p:
                                                   *const ::std::os::raw::c_void)
                              -> usize>;
pub type MozMallocSizeOf =
    ::std::option::Option<unsafe extern "C" fn(p:
                                                   *const ::std::os::raw::c_void)
                              -> usize>;
#[repr(C)]
pub struct EnumeratedArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangedPtr<T> {
    pub mPtr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Range<T> {
    pub mStart: RangedPtr<T>,
    pub mEnd: RangedPtr<T>,
}
pub enum JSContext { }
pub enum JSFunction { }
pub enum JSObject { }
pub enum JSScript { }
pub enum JSString { }
pub enum JSAddonId { }
pub type Latin1Char = ::std::os::raw::c_uchar;
pub enum Symbol { }
pub type HandleFunction = Handle<*mut JSFunction>;
pub type HandleId = Handle<jsid>;
pub type HandleObject = Handle<*mut JSObject>;
pub type HandleScript = Handle<*mut JSScript>;
pub type HandleString = Handle<*mut JSString>;
pub type HandleSymbol = Handle<*mut Symbol>;
pub type HandleValue = Handle<Value>;
pub type MutableHandleFunction = MutableHandle<*mut JSFunction>;
pub type MutableHandleId = MutableHandle<jsid>;
pub type MutableHandleObject = MutableHandle<*mut JSObject>;
pub type MutableHandleScript = MutableHandle<*mut JSScript>;
pub type MutableHandleString = MutableHandle<*mut JSString>;
pub type MutableHandleSymbol = MutableHandle<*mut Symbol>;
pub type MutableHandleValue = MutableHandle<Value>;
pub type RootedObject = Rooted<*mut JSObject>;
pub type RootedFunction = Rooted<*mut JSFunction>;
pub type RootedScript = Rooted<*mut JSScript>;
pub type RootedString = Rooted<*mut JSString>;
pub type RootedSymbol = Rooted<*mut Symbol>;
pub type RootedId = Rooted<jsid>;
pub type RootedValue = Rooted<Value>;
pub type PersistentRootedFunction = PersistentRooted<*mut JSFunction>;
pub type PersistentRootedId = PersistentRooted<jsid>;
pub type PersistentRootedObject = PersistentRooted<*mut JSObject>;
pub type PersistentRootedScript = PersistentRooted<*mut JSScript>;
pub type PersistentRootedString = PersistentRooted<*mut JSString>;
pub type PersistentRootedSymbol = PersistentRooted<*mut Symbol>;
pub type PersistentRootedValue = PersistentRooted<Value>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AllocFunction { Malloc = 0, Calloc = 1, Realloc = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SystemAllocPolicy;
impl ::std::clone::Clone for SystemAllocPolicy {
    fn clone(&self) -> Self { *self }
}
pub enum ExclusiveContext { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TempAllocPolicy {
    pub cx_: *mut ContextFriendFields,
}
impl ::std::clone::Clone for TempAllocPolicy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TempAllocPolicy() {
    assert_eq!(::std::mem::size_of::<TempAllocPolicy>() , 8usize);
    assert_eq!(::std::mem::align_of::<TempAllocPolicy>() , 8usize);
}
extern "C" {
    #[link_name = "?reportAllocOverflow@TempAllocPolicy@js@@QEBAXXZ"]
    fn _reportAllocOverflow_TempAllocPolicy_js__QEBAXXZ_(this:
                                                             *mut TempAllocPolicy);
}
impl TempAllocPolicy {
    #[inline]
    pub unsafe fn reportAllocOverflow(&mut self) {
        _reportAllocOverflow_TempAllocPolicy_js__QEBAXXZ_(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct LinkedListElement<T> {
    pub mNext: *mut LinkedListElement<T>,
    pub mPrev: *mut LinkedListElement<T>,
    pub mIsSentinel: bool,
}
pub const NODE_KIND_SENTINEL: LinkedListElement_NodeKind =
    LinkedListElement_NodeKind::NODE_KIND_NORMAL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum LinkedListElement_NodeKind { NODE_KIND_NORMAL = 0, }
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct LinkedList<T> {
    pub sentinel: LinkedListElement<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedList_Iterator<T> {
    pub mCurrent: *mut T,
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCleanLinkedList<T> {
    pub _base: LinkedList<T>,
}
pub enum LazyScript { }
pub enum JitCode { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TraceKind {
    Object = 0,
    String = 1,
    Symbol = 2,
    Script = 3,
    Shape = 4,
    ObjectGroup = 5,
    Null = 6,
    BaseShape = 15,
    JitCode = 31,
    LazyScript = 47,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapTypeToTraceKind<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum RootKind {
    BaseShape = 0,
    JitCode = 1,
    LazyScript = 2,
    Object = 3,
    ObjectGroup = 4,
    Script = 5,
    Shape = 6,
    String = 7,
    Symbol = 8,
    Id = 9,
    Value = 10,
    Traceable = 11,
    Limit = 12,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapTypeToRootKind<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
pub type AutoIdVector = AutoVectorRooter<jsid>;
pub const JSVERSION_LATEST: JSVersion = JSVersion::JSVERSION_ECMA_5;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSVersion {
    JSVERSION_ECMA_3 = 148,
    JSVERSION_1_6 = 160,
    JSVERSION_1_7 = 170,
    JSVERSION_1_8 = 180,
    JSVERSION_ECMA_5 = 185,
    JSVERSION_DEFAULT = 0,
    JSVERSION_UNKNOWN = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSType {
    JSTYPE_VOID = 0,
    JSTYPE_OBJECT = 1,
    JSTYPE_FUNCTION = 2,
    JSTYPE_STRING = 3,
    JSTYPE_NUMBER = 4,
    JSTYPE_BOOLEAN = 5,
    JSTYPE_NULL = 6,
    JSTYPE_SYMBOL = 7,
    JSTYPE_LIMIT = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSProtoKey {
    JSProto_Null = 0,
    JSProto_Object = 1,
    JSProto_Function = 2,
    JSProto_Array = 3,
    JSProto_Boolean = 4,
    JSProto_JSON = 5,
    JSProto_Date = 6,
    JSProto_Math = 7,
    JSProto_Number = 8,
    JSProto_String = 9,
    JSProto_RegExp = 10,
    JSProto_Error = 11,
    JSProto_InternalError = 12,
    JSProto_EvalError = 13,
    JSProto_RangeError = 14,
    JSProto_ReferenceError = 15,
    JSProto_SyntaxError = 16,
    JSProto_TypeError = 17,
    JSProto_URIError = 18,
    JSProto_DebuggeeWouldRun = 19,
    JSProto_Iterator = 20,
    JSProto_StopIteration = 21,
    JSProto_ArrayBuffer = 22,
    JSProto_Int8Array = 23,
    JSProto_Uint8Array = 24,
    JSProto_Int16Array = 25,
    JSProto_Uint16Array = 26,
    JSProto_Int32Array = 27,
    JSProto_Uint32Array = 28,
    JSProto_Float32Array = 29,
    JSProto_Float64Array = 30,
    JSProto_Uint8ClampedArray = 31,
    JSProto_Proxy = 32,
    JSProto_WeakMap = 33,
    JSProto_Map = 34,
    JSProto_Set = 35,
    JSProto_DataView = 36,
    JSProto_Symbol = 37,
    JSProto_SharedArrayBuffer = 38,
    JSProto_Intl = 39,
    JSProto_TypedObject = 40,
    JSProto_Reflect = 41,
    JSProto_SIMD = 42,
    JSProto_WeakSet = 43,
    JSProto_TypedArray = 44,
    JSProto_Atomics = 45,
    JSProto_SavedFrame = 46,
    JSProto_Wasm = 47,
    JSProto_Promise = 48,
    JSProto_LIMIT = 49,
}
pub enum JSCompartment { }
pub enum JSCrossCompartmentCall { }
pub enum JSExceptionState { }
pub enum JSObjectMap { }
pub enum JSPropertyName { }
pub enum JSRuntime { }
pub enum JSStructuredCloneReader { }
pub enum JSStructuredCloneWriter { }
pub enum JSFlatString { }
pub enum PRCallOnceType { }
pub type JSCallOnceType = PRCallOnceType;
pub type JSInitCallback =
    ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type JSConstDoubleSpec = JSConstScalarSpec<f64>;
pub type JSConstIntegerSpec = JSConstScalarSpec<::std::os::raw::c_int>;
pub type JSTraceDataOp =
    ::std::option::Option<unsafe extern "C" fn(trc: *mut JSTracer,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub enum AutoTraceSession { }
pub enum StoreBuffer { }
pub type OffThreadCompileCallback =
    ::std::option::Option<unsafe extern "C" fn(token:
                                                   *mut ::std::os::raw::c_void,
                                               callbackData:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum HeapState {
    Idle = 0,
    Tracing = 1,
    MajorCollecting = 2,
    MinorCollecting = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Runtime {
    pub heapState_: HeapState,
    pub gcStoreBufferPtr_: *mut StoreBuffer,
}
impl ::std::clone::Clone for Runtime {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Runtime() {
    assert_eq!(::std::mem::size_of::<Runtime>() , 16usize);
    assert_eq!(::std::mem::align_of::<Runtime>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoGCRooter {
    pub down: *mut AutoGCRooter,
    pub tag_: isize,
    pub stackTop: *mut *mut AutoGCRooter,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AutoGCRooter_jspubtd_h_unnamed_1 {
    VALARRAY = -2,
    PARSER = -3,
    VALVECTOR = -10,
    IDVECTOR = -11,
    OBJVECTOR = -14,
    IONMASM = -19,
    WRAPVECTOR = -20,
    WRAPPER = -21,
    CUSTOM = -26,
}
#[test]
fn bindgen_test_layout_AutoGCRooter() {
    assert_eq!(::std::mem::size_of::<AutoGCRooter>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoGCRooter>() , 8usize);
}
extern "C" {
    #[link_name = "?trace@AutoGCRooter@JS@@QEAAXPEAVJSTracer@@@Z"]
    fn _trace_AutoGCRooter_JS__QEAAXPEAVJSTracer___Z_(this: *mut AutoGCRooter,
                                                      trc: *mut JSTracer);
    #[link_name = "?traceAll@AutoGCRooter@JS@@SAXPEAVJSTracer@@@Z"]
    fn _traceAll_AutoGCRooter_JS__SAXPEAVJSTracer___Z_(trc: *mut JSTracer);
    #[link_name = "?traceAllWrappers@AutoGCRooter@JS@@SAXPEAVJSTracer@@@Z"]
    fn _traceAllWrappers_AutoGCRooter_JS__SAXPEAVJSTracer___Z_(trc:
                                                                   *mut JSTracer);
    #[link_name = "?GetTag@AutoGCRooter@JS@@KA_JAEBVValue@2@@Z"]
    fn _GetTag_AutoGCRooter_JS__KA_JAEBVValue_2__Z_(value: *const Value)
     -> isize;
    #[link_name = "?GetTag@AutoGCRooter@JS@@KA_JAEBUjsid@@@Z"]
    fn _GetTag_AutoGCRooter_JS__KA_JAEBUjsid___Z_(id: *const jsid) -> isize;
    #[link_name = "?GetTag@AutoGCRooter@JS@@KA_JPEAVJSObject@@@Z"]
    fn _GetTag_AutoGCRooter_JS__KA_JPEAVJSObject___Z_(obj: *mut JSObject)
     -> isize;
}
impl AutoGCRooter {
    #[inline]
    pub unsafe fn trace(&mut self, trc: *mut JSTracer) {
        _trace_AutoGCRooter_JS__QEAAXPEAVJSTracer___Z_(&mut *self, trc)
    }
    #[inline]
    pub unsafe fn traceAll(trc: *mut JSTracer) {
        _traceAll_AutoGCRooter_JS__SAXPEAVJSTracer___Z_(trc)
    }
    #[inline]
    pub unsafe fn traceAllWrappers(trc: *mut JSTracer) {
        _traceAllWrappers_AutoGCRooter_JS__SAXPEAVJSTracer___Z_(trc)
    }
    #[inline]
    pub unsafe fn GetTag(value: *const Value) -> isize {
        _GetTag_AutoGCRooter_JS__KA_JAEBVValue_2__Z_(value)
    }
    #[inline]
    pub unsafe fn GetTag1(id: *const jsid) -> isize {
        _GetTag_AutoGCRooter_JS__KA_JAEBUjsid___Z_(id)
    }
    #[inline]
    pub unsafe fn GetTag2(obj: *mut JSObject) -> isize {
        _GetTag_AutoGCRooter_JS__KA_JPEAVJSObject___Z_(obj)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum StackKind {
    StackForSystemCode = 0,
    StackForTrustedScript = 1,
    StackForUntrustedScript = 2,
    StackKindCount = 3,
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct RootLists {
    pub stackRoots_: [u64; 12usize],
    pub autoGCRooters_: *mut AutoGCRooter,
    pub heapRoots_: [u64; 36usize],
}
#[test]
fn bindgen_test_layout_RootLists() {
    assert_eq!(::std::mem::size_of::<RootLists>() , 392usize);
    assert_eq!(::std::mem::align_of::<RootLists>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ContextFriendFields {
    pub runtime_: *mut JSRuntime,
    pub compartment_: *mut JSCompartment,
    pub zone_: *mut Zone,
    pub roots: RootLists,
}
#[test]
fn bindgen_test_layout_ContextFriendFields() {
    assert_eq!(::std::mem::size_of::<ContextFriendFields>() , 416usize);
    assert_eq!(::std::mem::align_of::<ContextFriendFields>() , 8usize);
}
pub enum PerThreadData { }
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct PerThreadDataFriendFields {
    pub roots: RootLists,
    pub nativeStackLimit: [usize; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerThreadDataFriendFields_RuntimeDummy {
    pub _base: Runtime,
    pub mainThread: PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy {
    pub field1: *mut ::std::os::raw::c_void,
    pub field2: usize,
    pub field3: u64,
}
impl ::std::clone::Clone for
 PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy>()
               , 24usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields_RuntimeDummy_PerThreadDummy>()
               , 8usize);
}
impl ::std::clone::Clone for PerThreadDataFriendFields_RuntimeDummy {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields_RuntimeDummy() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields_RuntimeDummy>()
               , 40usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields_RuntimeDummy>()
               , 8usize);
}
#[test]
fn bindgen_test_layout_PerThreadDataFriendFields() {
    assert_eq!(::std::mem::size_of::<PerThreadDataFriendFields>() , 416usize);
    assert_eq!(::std::mem::align_of::<PerThreadDataFriendFields>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MallocAllocPolicy;
impl ::std::clone::Clone for MallocAllocPolicy {
    fn clone(&self) -> Self { *self }
}
pub enum VectorTesting { }
pub enum Cell { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Zone {
    pub runtime_: *mut JSRuntime,
    pub barrierTracer_: *mut JSTracer,
    pub needsIncrementalBarrier_: bool,
}
impl ::std::clone::Clone for Zone {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Zone() {
    assert_eq!(::std::mem::size_of::<Zone>() , 24usize);
    assert_eq!(::std::mem::align_of::<Zone>() , 8usize);
}
/**
 * A GC pointer, tagged with the trace kind.
 *
 * In general, a GC pointer should be stored with an exact type. This class
 * is for use when that is not possible because a single pointer must point
 * to several kinds of GC thing.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCCellPtr {
    pub ptr: usize,
}
impl ::std::clone::Clone for GCCellPtr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCCellPtr() {
    assert_eq!(::std::mem::size_of::<GCCellPtr>() , 8usize);
    assert_eq!(::std::mem::align_of::<GCCellPtr>() , 8usize);
}
extern "C" {
    #[link_name = "?kind@GCCellPtr@JS@@QEBA?AW4TraceKind@2@XZ"]
    fn _kind_GCCellPtr_JS__QEBA_AW4TraceKind_2_XZ_(this: *mut GCCellPtr)
     -> TraceKind;
    #[link_name = "?asCell@GCCellPtr@JS@@QEBAPEAUCell@gc@js@@XZ"]
    fn _asCell_GCCellPtr_JS__QEBAPEAUCell_gc_js__XZ_(this: *mut GCCellPtr)
     -> *mut Cell;
    #[link_name = "?unsafeAsInteger@GCCellPtr@JS@@QEBA_KXZ"]
    fn _unsafeAsInteger_GCCellPtr_JS__QEBA_KXZ_(this: *mut GCCellPtr) -> u64;
    #[link_name = "?unsafeAsUIntPtr@GCCellPtr@JS@@QEBA_KXZ"]
    fn _unsafeAsUIntPtr_GCCellPtr_JS__QEBA_KXZ_(this: *mut GCCellPtr)
     -> usize;
    #[link_name = "?mayBeOwnedByOtherRuntime@GCCellPtr@JS@@QEBA_NXZ"]
    fn _mayBeOwnedByOtherRuntime_GCCellPtr_JS__QEBA_NXZ_(this: *mut GCCellPtr)
     -> bool;
}
impl GCCellPtr {
    #[inline]
    pub unsafe fn kind(&mut self) -> TraceKind {
        _kind_GCCellPtr_JS__QEBA_AW4TraceKind_2_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn asCell(&mut self) -> *mut Cell {
        _asCell_GCCellPtr_JS__QEBAPEAUCell_gc_js__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn unsafeAsInteger(&mut self) -> u64 {
        _unsafeAsInteger_GCCellPtr_JS__QEBA_KXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn unsafeAsUIntPtr(&mut self) -> usize {
        _unsafeAsUIntPtr_GCCellPtr_JS__QEBA_KXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn mayBeOwnedByOtherRuntime(&mut self) -> bool {
        _mayBeOwnedByOtherRuntime_GCCellPtr_JS__QEBA_NXZ_(&mut *self)
    }
}
pub enum GCRuntime { }
pub enum Statistics { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCMode {
    JSGC_MODE_GLOBAL = 0,
    JSGC_MODE_COMPARTMENT = 1,
    JSGC_MODE_INCREMENTAL = 2,
}
/**
 * Kinds of js_GC invocation.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCInvocationKind { GC_NORMAL = 0, GC_SHRINK = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Reason {
    API = 0,
    EAGER_ALLOC_TRIGGER = 1,
    DESTROY_RUNTIME = 2,
    DESTROY_CONTEXT = 3,
    LAST_DITCH = 4,
    TOO_MUCH_MALLOC = 5,
    ALLOC_TRIGGER = 6,
    DEBUG_GC = 7,
    COMPARTMENT_REVIVED = 8,
    RESET = 9,
    OUT_OF_NURSERY = 10,
    EVICT_NURSERY = 11,
    FULL_STORE_BUFFER = 12,
    SHARED_MEMORY_LIMIT = 13,
    PERIODIC_FULL_GC = 14,
    INCREMENTAL_TOO_SLOW = 15,
    ABORT_GC = 16,
    RESERVED0 = 17,
    RESERVED1 = 18,
    RESERVED2 = 19,
    RESERVED3 = 20,
    RESERVED4 = 21,
    RESERVED5 = 22,
    RESERVED6 = 23,
    RESERVED7 = 24,
    RESERVED8 = 25,
    RESERVED9 = 26,
    RESERVED10 = 27,
    RESERVED11 = 28,
    RESERVED12 = 29,
    RESERVED13 = 30,
    RESERVED14 = 31,
    RESERVED15 = 32,
    DOM_WINDOW_UTILS = 33,
    COMPONENT_UTILS = 34,
    MEM_PRESSURE = 35,
    CC_WAITING = 36,
    CC_FORCED = 37,
    LOAD_END = 38,
    POST_COMPARTMENT = 39,
    PAGE_HIDE = 40,
    NSJSCONTEXT_DESTROY = 41,
    SET_NEW_DOCUMENT = 42,
    SET_DOC_SHELL = 43,
    DOM_UTILS = 44,
    DOM_IPC = 45,
    DOM_WORKER = 46,
    INTER_SLICE_GC = 47,
    REFRESH_FRAME = 48,
    FULL_GC_TIMER = 49,
    SHUTDOWN_CC = 50,
    FINISH_LARGE_EVALUATE = 51,
    USER_INACTIVE = 52,
    XPCONNECT_SHUTDOWN = 53,
    NO_REASON = 54,
    NUM_REASONS = 55,
    NUM_TELEMETRY_REASONS = 100,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum GCProgress {
    GC_CYCLE_BEGIN = 0,
    GC_SLICE_BEGIN = 1,
    GC_SLICE_END = 2,
    GC_CYCLE_END = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCDescription {
    pub isCompartment_: bool,
    pub invocationKind_: JSGCInvocationKind,
    pub reason_: Reason,
}
impl ::std::clone::Clone for GCDescription {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCDescription() {
    assert_eq!(::std::mem::size_of::<GCDescription>() , 12usize);
    assert_eq!(::std::mem::align_of::<GCDescription>() , 4usize);
}
extern "C" {
    #[link_name =
          "?formatSliceMessage@GCDescription@JS@@QEBAPEA_SPEAUJSRuntime@@@Z"]
    fn _formatSliceMessage_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___Z_(this:
                                                                             *mut GCDescription,
                                                                         rt:
                                                                             *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort;
    #[link_name =
          "?formatSummaryMessage@GCDescription@JS@@QEBAPEA_SPEAUJSRuntime@@@Z"]
    fn _formatSummaryMessage_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___Z_(this:
                                                                               *mut GCDescription,
                                                                           rt:
                                                                               *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort;
    #[link_name =
          "?formatJSON@GCDescription@JS@@QEBAPEA_SPEAUJSRuntime@@_K@Z"]
    fn _formatJSON_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___K_Z_(this:
                                                                       *mut GCDescription,
                                                                   rt:
                                                                       *mut JSRuntime,
                                                                   timestamp:
                                                                       u64)
     -> *mut ::std::os::raw::c_ushort;
}
impl GCDescription {
    #[inline]
    pub unsafe fn formatSliceMessage(&mut self, rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort {
        _formatSliceMessage_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___Z_(&mut *self,
                                                                          rt)
    }
    #[inline]
    pub unsafe fn formatSummaryMessage(&mut self, rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_ushort {
        _formatSummaryMessage_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___Z_(&mut *self,
                                                                            rt)
    }
    #[inline]
    pub unsafe fn formatJSON(&mut self, rt: *mut JSRuntime, timestamp: u64)
     -> *mut ::std::os::raw::c_ushort {
        _formatJSON_GCDescription_JS__QEBAPEA_SPEAUJSRuntime___K_Z_(&mut *self,
                                                                    rt,
                                                                    timestamp)
    }
}
pub type GCSliceCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               progress: GCProgress,
                                               desc: *const GCDescription)>;
/**
 * Describes the progress of an observed nursery collection.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum GCNurseryProgress {
    GC_NURSERY_COLLECTION_START = 0,
    GC_NURSERY_COLLECTION_END = 1,
}
/**
 * A nursery collection callback receives the progress of the nursery collection
 * and the reason for the collection.
 */
pub type GCNurseryCollectionCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               progress: GCNurseryProgress,
                                               reason: Reason)>;
/** Ensure that generational GC is disabled within some scope. */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoDisableGenerationalGC {
    pub gc: *mut GCRuntime,
}
#[test]
fn bindgen_test_layout_AutoDisableGenerationalGC() {
    assert_eq!(::std::mem::size_of::<AutoDisableGenerationalGC>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoDisableGenerationalGC>() , 8usize);
}
/**
 * Assert if a GC occurs while this class is live. This class does not disable
 * the static rooting hazard analysis.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoAssertOnGC;
extern "C" {
    #[link_name = "?VerifyIsSafeToGC@AutoAssertOnGC@JS@@SAXPEAUJSRuntime@@@Z"]
    fn _VerifyIsSafeToGC_AutoAssertOnGC_JS__SAXPEAUJSRuntime___Z_(rt:
                                                                      *mut JSRuntime);
}
impl AutoAssertOnGC {
    #[inline]
    pub unsafe fn VerifyIsSafeToGC(rt: *mut JSRuntime) {
        _VerifyIsSafeToGC_AutoAssertOnGC_JS__SAXPEAUJSRuntime___Z_(rt)
    }
}
/**
 * Assert if an allocation of a GC thing occurs while this class is live. This
 * class does not disable the static rooting hazard analysis.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoAssertNoAlloc {
    pub gc: *mut GCRuntime,
}
#[test]
fn bindgen_test_layout_AutoAssertNoAlloc() {
    assert_eq!(::std::mem::size_of::<AutoAssertNoAlloc>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoAssertNoAlloc>() , 8usize);
}
extern "C" {
    #[link_name =
          "?disallowAlloc@AutoAssertNoAlloc@JS@@QEAAXPEAUJSRuntime@@@Z"]
    fn _disallowAlloc_AutoAssertNoAlloc_JS__QEAAXPEAUJSRuntime___Z_(this:
                                                                        *mut AutoAssertNoAlloc,
                                                                    rt:
                                                                        *mut JSRuntime);
}
impl AutoAssertNoAlloc {
    #[inline]
    pub unsafe fn disallowAlloc(&mut self, rt: *mut JSRuntime) {
        _disallowAlloc_AutoAssertNoAlloc_JS__QEAAXPEAUJSRuntime___Z_(&mut *self,
                                                                     rt)
    }
}
/**
 * Disable the static rooting hazard analysis in the live region and assert if
 * any allocation that could potentially trigger a GC occurs while this guard
 * object is live. This is most useful to help the exact rooting hazard analysis
 * in complex regions, since it cannot understand dataflow.
 *
 * Note: GC behavior is unpredictable even when deterministic and is generally
 *       non-deterministic in practice. The fact that this guard has not
 *       asserted is not a guarantee that a GC cannot happen in the guarded
 *       region. As a rule, anyone performing a GC unsafe action should
 *       understand the GC properties of all code in that region and ensure
 *       that the hazard analysis is correct for that code, rather than relying
 *       on this class.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSuppressGCAnalysis {
    pub _base: AutoAssertNoAlloc,
}
#[test]
fn bindgen_test_layout_AutoSuppressGCAnalysis() {
    assert_eq!(::std::mem::size_of::<AutoSuppressGCAnalysis>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoSuppressGCAnalysis>() , 8usize);
}
#[repr(C)]
pub struct AutoAssertGCCallback {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_AutoAssertGCCallback() {
    assert_eq!(::std::mem::size_of::<AutoAssertGCCallback>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoAssertGCCallback>() , 8usize);
}
/**
 * Place AutoCheckCannotGC in scopes that you believe can never GC. These
 * annotations will be verified both dynamically via AutoAssertOnGC, and
 * statically with the rooting hazard analysis (implemented by making the
 * analysis consider AutoCheckCannotGC to be a GC pointer, and therefore
 * complain if it is live across a GC call.) It is useful when dealing with
 * internal pointers to GC things where the GC thing itself may not be present
 * for the static analysis: e.g. acquiring inline chars from a JSString* on the
 * heap.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCheckCannotGC {
    pub _base: AutoAssertOnGC,
}
/**
 * Opaque<T> is a replacement for integral T in cases where only comparisons
 * must be supported, and it's desirable to prevent accidental dependency on
 * exact values.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Opaque<T> {
    pub mValue: T,
}
/*****************************************************************************/
pub type Generation = Opaque<::std::os::raw::c_ulonglong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CStringHasher;
impl ::std::clone::Clone for CStringHasher {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashMapEntry<Key, Value> {
    pub key_: Key,
    pub value_: Value,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum WeakMapTraceKind {
    DoNotTraceWeakMaps = 0,
    ExpandWeakMaps = 1,
    TraceWeakMapValues = 2,
    TraceWeakMapKeysValues = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSTracer {
    pub runtime_: *mut JSRuntime,
    pub weakMapAction_: WeakMapTraceKind,
    pub tag_: JSTracer_TracerKindTag,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSTracer_TracerKindTag {
    Marking = 0,
    WeakMarking = 1,
    Tenuring = 2,
    Callback = 3,
}
impl ::std::clone::Clone for JSTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSTracer() {
    assert_eq!(::std::mem::size_of::<JSTracer>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSTracer>() , 8usize);
}
extern "C" {
    #[link_name = "?runtime@JSTracer@@QEBAPEAUJSRuntime@@XZ"]
    fn _runtime_JSTracer__QEBAPEAUJSRuntime__XZ_(this: *mut JSTracer)
     -> *mut JSRuntime;
    #[link_name = "?weakMapAction@JSTracer@@QEBA?AW4WeakMapTraceKind@@XZ"]
    fn _weakMapAction_JSTracer__QEBA_AW4WeakMapTraceKind__XZ_(this:
                                                                  *mut JSTracer)
     -> WeakMapTraceKind;
    #[link_name = "?isMarkingTracer@JSTracer@@QEBA_NXZ"]
    fn _isMarkingTracer_JSTracer__QEBA_NXZ_(this: *mut JSTracer) -> bool;
    #[link_name = "?isWeakMarkingTracer@JSTracer@@QEBA_NXZ"]
    fn _isWeakMarkingTracer_JSTracer__QEBA_NXZ_(this: *mut JSTracer) -> bool;
    #[link_name = "?isTenuringTracer@JSTracer@@QEBA_NXZ"]
    fn _isTenuringTracer_JSTracer__QEBA_NXZ_(this: *mut JSTracer) -> bool;
    #[link_name = "?isCallbackTracer@JSTracer@@QEBA_NXZ"]
    fn _isCallbackTracer_JSTracer__QEBA_NXZ_(this: *mut JSTracer) -> bool;
    #[link_name = "?asCallbackTracer@JSTracer@@QEAAPEAVCallbackTracer@JS@@XZ"]
    fn _asCallbackTracer_JSTracer__QEAAPEAVCallbackTracer_JS__XZ_(this:
                                                                      *mut JSTracer)
     -> *mut CallbackTracer;
}
impl JSTracer {
    #[inline]
    pub unsafe fn runtime(&mut self) -> *mut JSRuntime {
        _runtime_JSTracer__QEBAPEAUJSRuntime__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn weakMapAction(&mut self) -> WeakMapTraceKind {
        _weakMapAction_JSTracer__QEBA_AW4WeakMapTraceKind__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn isMarkingTracer(&mut self) -> bool {
        _isMarkingTracer_JSTracer__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn isWeakMarkingTracer(&mut self) -> bool {
        _isWeakMarkingTracer_JSTracer__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn isTenuringTracer(&mut self) -> bool {
        _isTenuringTracer_JSTracer__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn isCallbackTracer(&mut self) -> bool {
        _isCallbackTracer_JSTracer__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn asCallbackTracer(&mut self) -> *mut CallbackTracer {
        _asCallbackTracer_JSTracer__QEAAPEAVCallbackTracer_JS__XZ_(&mut *self)
    }
}
pub enum AutoTracingCallback { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackTracer {
    pub _vftable: *const _vftable_CallbackTracer,
    pub _base: JSTracer,
    pub contextName_: *const ::std::os::raw::c_char,
    pub contextIndex_: usize,
    pub contextFunctor_: *mut CallbackTracer_ContextFunctor,
}
#[repr(C)]
pub struct _vftable_CallbackTracer {
    pub onObjectEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           objp: *mut *mut JSObject),
    pub onStringEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           strp: *mut *mut JSString),
    pub onSymbolEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           symp: *mut *mut Symbol),
    pub onScriptEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                           scriptp: *mut *mut JSScript),
    pub onShapeEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                          shapep: *mut *mut Shape),
    pub onObjectGroupEdge: unsafe extern "C" fn(this:
                                                    *mut ::std::os::raw::c_void,
                                                groupp:
                                                    *mut *mut ObjectGroup),
    pub onBaseShapeEdge: unsafe extern "C" fn(this:
                                                  *mut ::std::os::raw::c_void,
                                              basep: *mut *mut BaseShape),
    pub onJitCodeEdge: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                            codep: *mut *mut JitCode),
    pub onLazyScriptEdge: unsafe extern "C" fn(this:
                                                   *mut ::std::os::raw::c_void,
                                               lazyp: *mut *mut LazyScript),
    pub onChild: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                      thing: *const GCCellPtr),
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallbackTracer_ContextFunctor {
    pub _vftable: *const _vftable_CallbackTracer_ContextFunctor,
}
#[repr(C)]
pub struct _vftable_CallbackTracer_ContextFunctor {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for CallbackTracer_ContextFunctor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CallbackTracer_ContextFunctor() {
    assert_eq!(::std::mem::size_of::<CallbackTracer_ContextFunctor>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<CallbackTracer_ContextFunctor>() ,
               8usize);
}
impl ::std::clone::Clone for CallbackTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CallbackTracer() {
    assert_eq!(::std::mem::size_of::<CallbackTracer>() , 48usize);
    assert_eq!(::std::mem::align_of::<CallbackTracer>() , 8usize);
}
extern "C" {
    #[link_name = "?contextName@CallbackTracer@JS@@QEBAPEBDXZ"]
    fn _contextName_CallbackTracer_JS__QEBAPEBDXZ_(this: *mut CallbackTracer)
     -> *const ::std::os::raw::c_char;
    #[link_name = "?contextIndex@CallbackTracer@JS@@QEBA_KXZ"]
    fn _contextIndex_CallbackTracer_JS__QEBA_KXZ_(this: *mut CallbackTracer)
     -> usize;
    #[link_name = "?getTracingEdgeName@CallbackTracer@JS@@QEAAXPEAD_K@Z"]
    fn _getTracingEdgeName_CallbackTracer_JS__QEAAXPEAD_K_Z_(this:
                                                                 *mut CallbackTracer,
                                                             buffer:
                                                                 *mut ::std::os::raw::c_char,
                                                             bufferSize:
                                                                 usize);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVJSObject@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSObject___Z_(this:
                                                                          *mut CallbackTracer,
                                                                      objp:
                                                                          *mut *mut JSObject);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVJSString@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSString___Z_(this:
                                                                          *mut CallbackTracer,
                                                                      strp:
                                                                          *mut *mut JSString);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVSymbol@2@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVSymbol_2__Z_(this:
                                                                         *mut CallbackTracer,
                                                                     symp:
                                                                         *mut *mut Symbol);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVJSScript@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSScript___Z_(this:
                                                                          *mut CallbackTracer,
                                                                      scriptp:
                                                                          *mut *mut JSScript);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVShape@js@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVShape_js___Z_(this:
                                                                          *mut CallbackTracer,
                                                                      shapep:
                                                                          *mut *mut Shape);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVObjectGroup@js@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVObjectGroup_js___Z_(this:
                                                                                *mut CallbackTracer,
                                                                            groupp:
                                                                                *mut *mut ObjectGroup);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVBaseShape@js@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVBaseShape_js___Z_(this:
                                                                              *mut CallbackTracer,
                                                                          basep:
                                                                              *mut *mut BaseShape);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVJitCode@jit@js@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJitCode_jit_js___Z_(this:
                                                                                *mut CallbackTracer,
                                                                            codep:
                                                                                *mut *mut JitCode);
    #[link_name =
          "?dispatchToOnEdge@CallbackTracer@JS@@QEAAXPEAPEAVLazyScript@js@@@Z"]
    fn _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVLazyScript_js___Z_(this:
                                                                               *mut CallbackTracer,
                                                                           lazyp:
                                                                               *mut *mut LazyScript);
}
impl CallbackTracer {
    #[inline]
    pub unsafe fn contextName(&mut self) -> *const ::std::os::raw::c_char {
        _contextName_CallbackTracer_JS__QEBAPEBDXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn contextIndex(&mut self) -> usize {
        _contextIndex_CallbackTracer_JS__QEBA_KXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn getTracingEdgeName(&mut self,
                                     buffer: *mut ::std::os::raw::c_char,
                                     bufferSize: usize) {
        _getTracingEdgeName_CallbackTracer_JS__QEAAXPEAD_K_Z_(&mut *self,
                                                              buffer,
                                                              bufferSize)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge(&mut self, objp: *mut *mut JSObject) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSObject___Z_(&mut *self,
                                                                       objp)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge1(&mut self, strp: *mut *mut JSString) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSString___Z_(&mut *self,
                                                                       strp)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge2(&mut self, symp: *mut *mut Symbol) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVSymbol_2__Z_(&mut *self,
                                                                      symp)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge3(&mut self, scriptp: *mut *mut JSScript) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJSScript___Z_(&mut *self,
                                                                       scriptp)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge4(&mut self, shapep: *mut *mut Shape) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVShape_js___Z_(&mut *self,
                                                                       shapep)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge5(&mut self,
                                    groupp: *mut *mut ObjectGroup) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVObjectGroup_js___Z_(&mut *self,
                                                                             groupp)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge6(&mut self, basep: *mut *mut BaseShape) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVBaseShape_js___Z_(&mut *self,
                                                                           basep)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge7(&mut self, codep: *mut *mut JitCode) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVJitCode_jit_js___Z_(&mut *self,
                                                                             codep)
    }
    #[inline]
    pub unsafe fn dispatchToOnEdge8(&mut self, lazyp: *mut *mut LazyScript) {
        _dispatchToOnEdge_CallbackTracer_JS__QEAAXPEAPEAVLazyScript_js___Z_(&mut *self,
                                                                            lazyp)
    }
}
extern "C" {
    #[link_name = "?InvalidIndex@CallbackTracer@JS@@2_KB"]
    pub static CallbackTracer_consts_InvalidIndex:
               ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingName {
    pub trc_: *mut CallbackTracer,
    pub prior_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AutoTracingName() {
    assert_eq!(::std::mem::size_of::<AutoTracingName>() , 16usize);
    assert_eq!(::std::mem::align_of::<AutoTracingName>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingIndex {
    pub trc_: *mut CallbackTracer,
}
#[test]
fn bindgen_test_layout_AutoTracingIndex() {
    assert_eq!(::std::mem::size_of::<AutoTracingIndex>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoTracingIndex>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoTracingDetails {
    pub trc_: *mut CallbackTracer,
}
#[test]
fn bindgen_test_layout_AutoTracingDetails() {
    assert_eq!(::std::mem::size_of::<AutoTracingDetails>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoTracingDetails>() , 8usize);
}
pub enum JSAtom { }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StructGCPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GCPolicy<T> {
    pub _base: StructGCPolicy<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IgnoreGCPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GCPointerPolicy<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierMethods<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootedBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HandleBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableHandleBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PersistentRootedBase<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PersistentRootedMarker<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
/**
 * The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 * encapsulates the GC concerns of an on-heap reference to a JS object. However,
 * it has two important differences:
 *
 *  1) Pointers which are statically known to only reference "tenured" objects
 *     can avoid the extra overhead of SpiderMonkey's write barriers.
 *
 *  2) Objects in the "tenured" heap have stronger alignment restrictions than
 *     those in the "nursery", so it is possible to store flags in the lower
 *     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
 *     pointer with a nice API for accessing the flag bits and adds various
 *     assertions to ensure that it is not mis-used.
 *
 * GC things are said to be "tenured" when they are located in the long-lived
 * heap: e.g. they have gained tenure as an object by surviving past at least
 * one GC. For performance, SpiderMonkey allocates some things which are known
 * to normally be long lived directly into the tenured generation; for example,
 * global objects. Additionally, SpiderMonkey does not visit individual objects
 * when deleting non-tenured objects, so object with finalizers are also always
 * tenured; for instance, this includes most DOM objects.
 *
 * The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 * Heap<T> are:
 *
 *  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
 *  - It is however valid for a Heap<T> to refer to a tenured thing.
 *  - It is not possible to store flag bits in a Heap<T>.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TenuredHeap<T> {
    pub _base: HeapBase<T>,
    pub bits: usize,
}
pub const flagsMask: TenuredHeap_RootingAPI_h_unnamed_4 =
    TenuredHeap_RootingAPI_h_unnamed_4::maskBits;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TenuredHeap_RootingAPI_h_unnamed_4 { maskBits = 0, }
/**
 * Reference to a T that has been rooted elsewhere. This is most useful
 * as a parameter type, which guarantees that the T lvalue is properly
 * rooted. See "Move GC Stack Rooting" above.
 *
 * If you want to add additional methods to Handle for a specific
 * specialization, define a HandleBase<T> specialization containing them.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Handle<T> {
    pub _base: HandleBase<T>,
    pub ptr: *const T,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Handle_Disambiguator { DeliberatelyChoosingThisOverload = 0, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Handle_CallerIdentity {
    ImUsingThisOnlyInFromFromMarkedLocation = 0,
}
/**
 * Similar to a handle, but the underlying storage can be changed. This is
 * useful for outparams.
 *
 * If you want to add additional methods to MutableHandle for a specific
 * specialization, define a MutableHandleBase<T> specialization containing
 * them.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableHandle<T> {
    pub _base: MutableHandleBase<T>,
    pub ptr: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MovableCellHasher<T> {
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DispatchWrapper<T> {
    pub tracer: ::std::option::Option<unsafe extern "C" fn()>,
    pub storage: T,
}
/**
 * Local variable of type T whose value is always rooted. This is typically
 * used for local variables, or for non-rooted values being passed to a
 * function that requires a handle, e.g. Foo(Root<T>(cx, x)).
 *
 * If you want to add additional methods to Rooted for a specific
 * specialization, define a RootedBase<T> specialization containing them.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct Rooted<T> {
    pub _base: RootedBase<T>,
    pub stack: *mut *mut Rooted<*mut ::std::os::raw::c_void>,
    pub prev: *mut Rooted<*mut ::std::os::raw::c_void>,
    pub ptr: T,
}
/** Interface substitute for Rooted<T> which does not root the variable's memory. */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FakeRooted<T> {
    pub _base: RootedBase<T>,
    pub ptr: T,
}
/** Interface substitute for MutableHandle<T> which is not required to point to rooted memory. */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FakeMutableHandle<T> {
    pub _base: MutableHandleBase<T>,
    pub ptr: *mut T,
}
/**
 * Types for a variable that either should or shouldn't be rooted, depending on
 * the template parameter allowGC. Used for implementing functions that can
 * operate on either rooted or unrooted data.
 *
 * The toHandle() and toMutableHandle() functions are for calling functions
 * which require handle types and are only called in the CanGC case. These
 * allow the calling code to type check.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AllowGC { NoGC = 0, CanGC = 1, }
/**
 * A copyable, assignable global GC root type with arbitrary lifetime, an
 * infallible constructor, and automatic unrooting on destruction.
 *
 * These roots can be used in heap-allocated data structures, so they are not
 * associated with any particular JSContext or stack. They are registered with
 * the JSRuntime itself, without locking, so they require a full JSContext to be
 * initialized, not one of its more restricted superclasses. Initialization may
 * take place on construction, or in two phases if the no-argument constructor
 * is called followed by init().
 *
 * Note that you must not use an PersistentRooted in an object owned by a JS
 * object:
 *
 * Whenever one object whose lifetime is decided by the GC refers to another
 * such object, that edge must be traced only if the owning JS object is traced.
 * This applies not only to JS objects (which obviously are managed by the GC)
 * but also to C++ objects owned by JS objects.
 *
 * If you put a PersistentRooted in such a C++ object, that is almost certainly
 * a leak. When a GC begins, the referent of the PersistentRooted is treated as
 * live, unconditionally (because a PersistentRooted is a *root*), even if the
 * JS object that owns it is unreachable. If there is any path from that
 * referent back to the JS object, then the C++ object containing the
 * PersistentRooted will not be destructed, and the whole blob of objects will
 * not be freed, even if there are no references to them from the outside.
 *
 * In the context of Firefox, this is a severe restriction: almost everything in
 * Firefox is owned by some JS object or another, so using PersistentRooted in
 * such objects would introduce leaks. For these kinds of edges, Heap<T> or
 * TenuredHeap<T> would be better types. It's up to the implementor of the type
 * containing Heap<T> or TenuredHeap<T> members to make sure their referents get
 * marked when the object itself is marked.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct PersistentRooted<T> {
    pub _base: PersistentRootedBase<T>,
    pub _base1: LinkedListElement<T>,
    pub ptr: T,
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ObjectPtr {
    pub value: Heap<*mut JSObject>,
}
#[test]
fn bindgen_test_layout_ObjectPtr() {
    assert_eq!(::std::mem::size_of::<ObjectPtr>() , 8usize);
    assert_eq!(::std::mem::align_of::<ObjectPtr>() , 8usize);
}
extern "C" {
    #[link_name = "?finalize@ObjectPtr@JS@@QEAAXPEAUJSRuntime@@@Z"]
    fn _finalize_ObjectPtr_JS__QEAAXPEAUJSRuntime___Z_(this: *mut ObjectPtr,
                                                       rt: *mut JSRuntime);
    #[link_name = "?init@ObjectPtr@JS@@QEAAXPEAVJSObject@@@Z"]
    fn _init_ObjectPtr_JS__QEAAXPEAVJSObject___Z_(this: *mut ObjectPtr,
                                                  obj: *mut JSObject);
    #[link_name = "?get@ObjectPtr@JS@@QEBAPEAVJSObject@@XZ"]
    fn _get_ObjectPtr_JS__QEBAPEAVJSObject__XZ_(this: *mut ObjectPtr)
     -> *mut JSObject;
    #[link_name = "?writeBarrierPre@ObjectPtr@JS@@QEAAXPEAUJSRuntime@@@Z"]
    fn _writeBarrierPre_ObjectPtr_JS__QEAAXPEAUJSRuntime___Z_(this:
                                                                  *mut ObjectPtr,
                                                              rt:
                                                                  *mut JSRuntime);
    #[link_name = "?updateWeakPointerAfterGC@ObjectPtr@JS@@QEAAXXZ"]
    fn _updateWeakPointerAfterGC_ObjectPtr_JS__QEAAXXZ_(this: *mut ObjectPtr);
    #[link_name = "?trace@ObjectPtr@JS@@QEAAXPEAVJSTracer@@PEBD@Z"]
    fn _trace_ObjectPtr_JS__QEAAXPEAVJSTracer__PEBD_Z_(this: *mut ObjectPtr,
                                                       trc: *mut JSTracer,
                                                       name:
                                                           *const ::std::os::raw::c_char);
}
impl ObjectPtr {
    #[inline]
    pub unsafe fn finalize(&mut self, rt: *mut JSRuntime) {
        _finalize_ObjectPtr_JS__QEAAXPEAUJSRuntime___Z_(&mut *self, rt)
    }
    #[inline]
    pub unsafe fn init(&mut self, obj: *mut JSObject) {
        _init_ObjectPtr_JS__QEAAXPEAVJSObject___Z_(&mut *self, obj)
    }
    #[inline]
    pub unsafe fn get(&mut self) -> *mut JSObject {
        _get_ObjectPtr_JS__QEBAPEAVJSObject__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn writeBarrierPre(&mut self, rt: *mut JSRuntime) {
        _writeBarrierPre_ObjectPtr_JS__QEAAXPEAUJSRuntime___Z_(&mut *self, rt)
    }
    #[inline]
    pub unsafe fn updateWeakPointerAfterGC(&mut self) {
        _updateWeakPointerAfterGC_ObjectPtr_JS__QEAAXXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn trace(&mut self, trc: *mut JSTracer,
                        name: *const ::std::os::raw::c_char) {
        _trace_ObjectPtr_JS__QEAAXPEAVJSTracer__PEBD_Z_(&mut *self, trc, name)
    }
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueType {
    JSVAL_TYPE_DOUBLE = 0,
    JSVAL_TYPE_INT32 = 1,
    JSVAL_TYPE_UNDEFINED = 2,
    JSVAL_TYPE_BOOLEAN = 3,
    JSVAL_TYPE_MAGIC = 4,
    JSVAL_TYPE_STRING = 5,
    JSVAL_TYPE_SYMBOL = 6,
    JSVAL_TYPE_NULL = 7,
    JSVAL_TYPE_OBJECT = 8,
    JSVAL_TYPE_UNKNOWN = 32,
    JSVAL_TYPE_MISSING = 33,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueTag {
    JSVAL_TAG_MAX_DOUBLE = 131056,
    JSVAL_TAG_INT32 = 131057,
    JSVAL_TAG_UNDEFINED = 131058,
    JSVAL_TAG_STRING = 131061,
    JSVAL_TAG_SYMBOL = 131062,
    JSVAL_TAG_BOOLEAN = 131059,
    JSVAL_TAG_MAGIC = 131060,
    JSVAL_TAG_NULL = 131063,
    JSVAL_TAG_OBJECT = 131064,
}
#[repr(i64)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSValueShiftedTag {
    JSVAL_SHIFTED_TAG_MAX_DOUBLE = -2251795518717953,
    JSVAL_SHIFTED_TAG_INT32 = -2111062325329920,
    JSVAL_SHIFTED_TAG_UNDEFINED = -1970324836974592,
    JSVAL_SHIFTED_TAG_STRING = -1548112371908608,
    JSVAL_SHIFTED_TAG_SYMBOL = -1407374883553280,
    JSVAL_SHIFTED_TAG_BOOLEAN = -1829587348619264,
    JSVAL_SHIFTED_TAG_MAGIC = -1688849860263936,
    JSVAL_SHIFTED_TAG_NULL = -1266637395197952,
    JSVAL_SHIFTED_TAG_OBJECT = -1125899906842624,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSWhyMagic {
    JS_ELEMENTS_HOLE = 0,
    JS_NO_ITER_VALUE = 1,
    JS_GENERATOR_CLOSING = 2,
    JS_NO_CONSTANT = 3,
    JS_THIS_POISON = 4,
    JS_ARG_POISON = 5,
    JS_SERIALIZE_NO_NODE = 6,
    JS_LAZY_ARGUMENTS = 7,
    JS_OPTIMIZED_ARGUMENTS = 8,
    JS_IS_CONSTRUCTING = 9,
    JS_OVERWRITTEN_CALLEE = 10,
    JS_BLOCK_NEEDS_CLONE = 11,
    JS_HASH_KEY_EMPTY = 12,
    JS_ION_ERROR = 13,
    JS_ION_BAILOUT = 14,
    JS_OPTIMIZED_OUT = 15,
    JS_UNINITIALIZED_LEXICAL = 16,
    JS_GENERIC_MAGIC = 17,
    JS_WHY_MAGIC_COUNT = 18,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout {
    pub asBits: __BindgenUnionField<u64>,
    pub s: __BindgenUnionField<jsval_layout_Value_h_unnamed_5>,
    pub asDouble: __BindgenUnionField<f64>,
    pub asPtr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub _bindgen_data_: u64,
}
impl jsval_layout {
    pub unsafe fn asBits(&mut self) -> *mut u64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s(&mut self) -> *mut jsval_layout_Value_h_unnamed_5 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asDouble(&mut self) -> *mut f64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asPtr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for jsval_layout {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout() {
    assert_eq!(::std::mem::size_of::<jsval_layout>() , 8usize);
    assert_eq!(::std::mem::align_of::<jsval_layout>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_Value_h_unnamed_5 {
    pub payload: jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6 {
    pub i32: __BindgenUnionField<i32>,
    pub u32: __BindgenUnionField<u32>,
    pub why: __BindgenUnionField<JSWhyMagic>,
    pub _bindgen_data_: u32,
}
impl jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6 {
    pub unsafe fn i32(&mut self) -> *mut i32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn u32(&mut self) -> *mut u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn why(&mut self) -> *mut JSWhyMagic {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6() {
    assert_eq!(::std::mem::size_of::<jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_Value_h_unnamed_5_Value_h_unnamed_6>()
               , 4usize);
}
impl ::std::clone::Clone for jsval_layout_Value_h_unnamed_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_Value_h_unnamed_5() {
    assert_eq!(::std::mem::size_of::<jsval_layout_Value_h_unnamed_5>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_Value_h_unnamed_5>() ,
               4usize);
}
/**
 * JS::Value is the interface for a single JavaScript Engine value.  A few
 * general notes on JS::Value:
 *
 * - JS::Value has setX() and isX() members for X in
 *
 *     { Int32, Double, String, Symbol, Boolean, Undefined, Null, Object, Magic }
 *
 *   JS::Value also contains toX() for each of the non-singleton types.
 *
 * - Magic is a singleton type whose payload contains either a JSWhyMagic "reason" for
 *   the magic value or a uint32_t value. By providing JSWhyMagic values when
 *   creating and checking for magic values, it is possible to assert, at
 *   runtime, that only magic values with the expected reason flow through a
 *   particular value. For example, if cx->exception has a magic value, the
 *   reason must be JS_GENERATOR_CLOSING.
 *
 * - The JS::Value operations are preferred.  The JSVAL_* operations remain for
 *   compatibility; they may be removed at some point.  These operations mostly
 *   provide similar functionality.  But there are a few key differences.  One
 *   is that JS::Value gives null a separate type.
 *   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
 *   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
 *   JSObject&.)  A convenience member Value::setObjectOrNull is provided.
 *
 * - JSVAL_VOID is the same as the singleton value of the Undefined type.
 *
 * - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
 *   32-bit user code should avoid copying jsval/JS::Value as much as possible,
 *   preferring to pass by const Value&.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value {
    pub data: jsval_layout,
}
impl ::std::clone::Clone for Value {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 8usize);
    assert_eq!(::std::mem::align_of::<Value>() , 8usize);
}
/**
 * A class designed for CRTP use in implementing the non-mutating parts of the
 * Value interface in Value-like classes.  Outer must be a class inheriting
 * ValueOperations<Outer> with a visible get() method returning a const
 * reference to the Value abstracted by Outer.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueOperations<Outer> {
    pub _phantom0: ::std::marker::PhantomData<Outer>,
}
/**
 * A class designed for CRTP use in implementing all the mutating parts of the
 * Value interface in Value-like classes.  Outer must be a class inheriting
 * MutableValueOperations<Outer> with visible get() methods returning const and
 * non-const references to the Value abstracted by Outer.
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutableValueOperations<Outer> {
    pub _base: ValueOperations<Outer>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoidDefaultAdaptor<S> {
    pub _phantom0: ::std::marker::PhantomData<S>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentityDefaultAdaptor<S> {
    pub _phantom0: ::std::marker::PhantomData<S>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ValueAlignmentTester {
    pub c: ::std::os::raw::c_char,
    pub v: Value,
}
impl ::std::clone::Clone for ValueAlignmentTester {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ValueAlignmentTester() {
    assert_eq!(::std::mem::size_of::<ValueAlignmentTester>() , 16usize);
    assert_eq!(::std::mem::align_of::<ValueAlignmentTester>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LayoutAlignmentTester {
    pub c: ::std::os::raw::c_char,
    pub l: jsval_layout,
}
impl ::std::clone::Clone for LayoutAlignmentTester {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_LayoutAlignmentTester() {
    assert_eq!(::std::mem::size_of::<LayoutAlignmentTester>() , 16usize);
    assert_eq!(::std::mem::align_of::<LayoutAlignmentTester>() , 8usize);
}
pub type JSNative =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               argc: ::std::os::raw::c_uint,
                                               vp: *mut Value) -> bool>;
pub type CallReceiver = CallReceiverBase<IncludeUsedRval>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UsedRvalBase;
impl ::std::clone::Clone for UsedRvalBase {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IncludeUsedRval {
    pub _base: UsedRvalBase,
    pub usedRval_: bool,
}
impl ::std::clone::Clone for IncludeUsedRval {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_IncludeUsedRval() {
    assert_eq!(::std::mem::size_of::<IncludeUsedRval>() , 1usize);
    assert_eq!(::std::mem::align_of::<IncludeUsedRval>() , 1usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NoUsedRval {
    pub _base: UsedRvalBase,
}
impl ::std::clone::Clone for NoUsedRval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallReceiverBase<WantUsedRval> {
    pub _base: WantUsedRval,
    pub argv_: *mut Value,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallArgsBase<WantUsedRval> {
    pub _base: CallReceiverBase<WantUsedRval>,
    pub argc_: ::std::os::raw::c_uint,
    pub constructing_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallArgs {
    pub _base: CallArgsBase<IncludeUsedRval>,
}
impl ::std::clone::Clone for CallArgs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsid {
    pub asBits: usize,
}
impl ::std::clone::Clone for jsid {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsid() {
    assert_eq!(::std::mem::size_of::<jsid>() , 8usize);
    assert_eq!(::std::mem::align_of::<jsid>() , 8usize);
}
pub enum JSAtomState { }
pub enum FreeOp { }
/**
 * The answer to a successful query as to whether an object is an Array per
 * ES6's internal |IsArray| operation (as exposed by |Array.isArray|).
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum IsArrayAnswer { Array = 0, NotArray = 1, RevokedProxy = 2, }
/**
 * Per ES6, the [[DefineOwnProperty]] internal method has three different
 * possible outcomes:
 *
 * -   It can throw an exception (which we indicate by returning false).
 *
 * -   It can return true, indicating unvarnished success.
 *
 * -   It can return false, indicating "strict failure". The property could
 *     not be defined. It's an error, but no exception was thrown.
 *
 * It's not just [[DefineOwnProperty]]: all the mutating internal methods have
 * the same three outcomes. (The other affected internal methods are [[Set]],
 * [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)
 *
 * If you think this design is awful, you're not alone.  But as it's the
 * standard, we must represent these boolean "success" values somehow.
 * ObjectOpSuccess is the class for this. It's like a bool, but when it's false
 * it also stores an error code.
 *
 * Typical usage:
 *
 *     ObjectOpResult result;
 *     if (!DefineProperty(cx, obj, id, ..., result))
 *         return false;
 *     if (!result)
 *         return result.reportError(cx, obj, id);
 *
 * Users don't have to call `result.report()`; another possible ending is:
 *
 *     argv.rval().setBoolean(bool(result));
 *     return true;
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectOpResult {
    /**
     * code_ is either one of the special codes OkCode or Uninitialized, or
     * an error code. For now the error codes are private to the JS engine;
     * they're defined in js/src/js.msg.
     *
     * code_ is uintptr_t (rather than uint32_t) for the convenience of the
     * JITs, which would otherwise have to deal with either padding or stack
     * alignment on 64-bit platforms.
     */
    pub code_: usize,
}
#[repr(i64)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ObjectOpResult_SpecialCodes { OkCode = 0, Uninitialized = -1, }
impl ::std::clone::Clone for ObjectOpResult {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectOpResult() {
    assert_eq!(::std::mem::size_of::<ObjectOpResult>() , 8usize);
    assert_eq!(::std::mem::align_of::<ObjectOpResult>() , 8usize);
}
extern "C" {
    #[link_name = "?failCantRedefineProp@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantRedefineProp_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                              *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failReadOnly@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failReadOnly_ObjectOpResult_JS__QEAA_NXZ_(this: *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failGetterOnly@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failGetterOnly_ObjectOpResult_JS__QEAA_NXZ_(this: *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantDelete@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantDelete_ObjectOpResult_JS__QEAA_NXZ_(this: *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantSetInterposed@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantSetInterposed_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                               *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantDefineWindowElement@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantDefineWindowElement_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                                     *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantDeleteWindowElement@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantDeleteWindowElement_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                                     *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "?failCantDeleteWindowNamedProperty@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantDeleteWindowNamedProperty_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                                           *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantPreventExtensions@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantPreventExtensions_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                                   *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failCantSetProto@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failCantSetProto_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                          *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failNoNamedSetter@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failNoNamedSetter_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                           *mut ObjectOpResult)
     -> bool;
    #[link_name = "?failNoIndexedSetter@ObjectOpResult@JS@@QEAA_NXZ"]
    fn _failNoIndexedSetter_ObjectOpResult_JS__QEAA_NXZ_(this:
                                                             *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "?reportStrictErrorOrWarning@ObjectOpResult@JS@@QEAA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@2@V?$Handle@Ujsid@@@2@_N@Z"]
    fn _reportStrictErrorOrWarning_ObjectOpResult_JS__QEAA_NPEAUJSContext__V__Handle_PEAVJSObject___2_V__Handle_Ujsid___2__N_Z_(this:
                                                                                                                                    *mut ObjectOpResult,
                                                                                                                                cx:
                                                                                                                                    *mut JSContext,
                                                                                                                                obj:
                                                                                                                                    HandleObject,
                                                                                                                                id:
                                                                                                                                    HandleId,
                                                                                                                                strict:
                                                                                                                                    bool)
     -> bool;
    #[link_name =
          "?reportStrictErrorOrWarning@ObjectOpResult@JS@@QEAA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@2@_N@Z"]
    fn _reportStrictErrorOrWarning_ObjectOpResult_JS__QEAA_NPEAUJSContext__V__Handle_PEAVJSObject___2__N_Z_(this:
                                                                                                                *mut ObjectOpResult,
                                                                                                            cx:
                                                                                                                *mut JSContext,
                                                                                                            obj:
                                                                                                                HandleObject,
                                                                                                            strict:
                                                                                                                bool)
     -> bool;
}
impl ObjectOpResult {
    #[inline]
    pub unsafe fn failCantRedefineProp(&mut self) -> bool {
        _failCantRedefineProp_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failReadOnly(&mut self) -> bool {
        _failReadOnly_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failGetterOnly(&mut self) -> bool {
        _failGetterOnly_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDelete(&mut self) -> bool {
        _failCantDelete_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantSetInterposed(&mut self) -> bool {
        _failCantSetInterposed_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDefineWindowElement(&mut self) -> bool {
        _failCantDefineWindowElement_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDeleteWindowElement(&mut self) -> bool {
        _failCantDeleteWindowElement_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantDeleteWindowNamedProperty(&mut self) -> bool {
        _failCantDeleteWindowNamedProperty_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantPreventExtensions(&mut self) -> bool {
        _failCantPreventExtensions_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failCantSetProto(&mut self) -> bool {
        _failCantSetProto_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failNoNamedSetter(&mut self) -> bool {
        _failNoNamedSetter_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn failNoIndexedSetter(&mut self) -> bool {
        _failNoIndexedSetter_ObjectOpResult_JS__QEAA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn reportStrictErrorOrWarning(&mut self, cx: *mut JSContext,
                                             obj: HandleObject, id: HandleId,
                                             strict: bool) -> bool {
        _reportStrictErrorOrWarning_ObjectOpResult_JS__QEAA_NPEAUJSContext__V__Handle_PEAVJSObject___2_V__Handle_Ujsid___2__N_Z_(&mut *self,
                                                                                                                                 cx,
                                                                                                                                 obj,
                                                                                                                                 id,
                                                                                                                                 strict)
    }
    #[inline]
    pub unsafe fn reportStrictErrorOrWarning1(&mut self, cx: *mut JSContext,
                                              obj: HandleObject, strict: bool)
     -> bool {
        _reportStrictErrorOrWarning_ObjectOpResult_JS__QEAA_NPEAUJSContext__V__Handle_PEAVJSObject___2__N_Z_(&mut *self,
                                                                                                             cx,
                                                                                                             obj,
                                                                                                             strict)
    }
}
/**
 * Get a property named by id in obj.  Note the jsid id type -- id may
 * be a string (Unicode property identifier) or an int (element index).  The
 * *vp out parameter, on success, is the new property value after the action.
 */
pub type JSGetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               vp: MutableHandleValue)
                              -> bool>;
/** Add a property named by id to obj. */
pub type JSAddPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId, v: HandleValue)
                              -> bool>;
/**
 * Set a property named by id in obj, treating the assignment as strict
 * mode code if strict is true. Note the jsid id type -- id may be a string
 * (Unicode property identifier) or an int (element index). The *vp out
 * parameter, on success, is the new property value after the
 * set.
 */
pub type JSSetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               vp: MutableHandleValue,
                                               result: *mut ObjectOpResult)
                              -> bool>;
/**
 * Delete a property named by id in obj.
 *
 * If an error occurred, return false as per normal JSAPI error practice.
 *
 * If no error occurred, but the deletion attempt wasn't allowed (perhaps
 * because the property was non-configurable), call result.fail() and
 * return true.  This will cause |delete obj[id]| to evaluate to false in
 * non-strict mode code, and to throw a TypeError in strict mode code.
 *
 * If no error occurred and the deletion wasn't disallowed (this is *not* the
 * same as saying that a deletion actually occurred -- deleting a non-existent
 * property, or an inherited property, is allowed -- it's just pointless),
 * call result.succeed() and return true.
 */
pub type JSDeletePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               result: *mut ObjectOpResult)
                              -> bool>;
/**
 * The type of ObjectOps::enumerate. This callback overrides a portion of
 * SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object
 * is enumerated, that object and each object on its prototype chain is tested
 * for an enumerate op, and those ops are called in order. The properties each
 * op adds to the 'properties' vector are added to the set of values the for-in
 * loop will iterate over. All of this is nonstandard.
 *
 * An object is "enumerated" when it's the target of a for-in loop or
 * JS_Enumerate(). The callback's job is to populate 'properties' with the
 * object's property keys. If `enumerableOnly` is true, the callback should only
 * add enumerable properties.
 */
pub type JSNewEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               properties: *mut AutoIdVector,
                                               enumerableOnly: bool) -> bool>;
/**
 * The old-style JSClass.enumerate op should define all lazy properties not
 * yet reflected in obj.
 */
pub type JSEnumerateOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject) -> bool>;
/**
 * The type of ObjectOps::funToString.  This callback allows an object to
 * provide a custom string to use when Function.prototype.toString is invoked on
 * that object.  A null return value means OOM.
 */
pub type JSFunToStringOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               indent: ::std::os::raw::c_uint)
                              -> *mut JSString>;
/**
 * Resolve a lazy property named by id in obj by defining it directly in obj.
 * Lazy properties are those reflected from some peer native property space
 * (e.g., the DOM attributes for a given node reflected as obj) on demand.
 *
 * JS looks for a property in an object, and if not found, tries to resolve
 * the given id. *resolvedp should be set to true iff the property was defined
 * on |obj|.
 */
pub type JSResolveOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               resolvedp: *mut bool) -> bool>;
/**
 * A class with a resolve hook can optionally have a mayResolve hook. This hook
 * must have no side effects and must return true for a given id if the resolve
 * hook may resolve this id. This is useful when we're doing a "pure" lookup: if
 * mayResolve returns false, we know we don't have to call the effectful resolve
 * hook.
 *
 * maybeObj, if non-null, is the object on which we're doing the lookup. This
 * can be nullptr: during JIT compilation we sometimes know the Class but not
 * the object.
 */
pub type JSMayResolveOp =
    ::std::option::Option<unsafe extern "C" fn(names: *const JSAtomState,
                                               id: jsid,
                                               maybeObj: *mut JSObject)
                              -> bool>;
/**
 * Finalize obj, which the garbage collector has determined to be unreachable
 * from other live objects or from GC roots.  Obviously, finalizers must never
 * store a reference to obj.
 */
pub type JSFinalizeOp =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               obj: *mut JSObject)>;
/** Finalizes external strings created by JS_NewExternalString. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStringFinalizer {
    pub finalize: ::std::option::Option<unsafe extern "C" fn(fin:
                                                                 *const JSStringFinalizer,
                                                             chars:
                                                                 *mut ::std::os::raw::c_ushort)>,
}
impl ::std::clone::Clone for JSStringFinalizer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSStringFinalizer() {
    assert_eq!(::std::mem::size_of::<JSStringFinalizer>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSStringFinalizer>() , 8usize);
}
/**
 * Check whether v is an instance of obj.  Return false on error or exception,
 * true on success with true in *bp if v is an instance of obj, false in
 * *bp otherwise.
 */
pub type JSHasInstanceOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               vp: MutableHandleValue,
                                               bp: *mut bool) -> bool>;
/**
 * Function type for trace operation of the class called to enumerate all
 * traceable things reachable from obj's private data structure. For each such
 * thing, a trace implementation must call one of the JS_Call*Tracer variants
 * on the thing.
 *
 * JSTraceOp implementation can assume that no other threads mutates object
 * state. It must not change state of the object or corresponding native
 * structures. The only exception for this rule is the case when the embedding
 * needs a tight integration with GC. In that case the embedding can check if
 * the traversal is a part of the marking phase through calling
 * JS_IsGCMarkingTracer and apply a special code like emptying caches or
 * marking its native structures.
 */
pub type JSTraceOp =
    ::std::option::Option<unsafe extern "C" fn(trc: *mut JSTracer,
                                               obj: *mut JSObject)>;
pub type JSWeakmapKeyDelegateOp =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut JSObject)
                              -> *mut JSObject>;
pub type JSObjectMovedOp =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut JSObject,
                                               old: *const JSObject)>;
pub type LookupPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               objp: MutableHandleObject,
                                               propp:
                                                   MutableHandle<*mut Shape>)
                              -> bool>;
pub type DefinePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               desc:
                                                   Handle<PropertyDescriptor>,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type HasPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               foundp: *mut bool) -> bool>;
pub type GetPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               receiver: HandleValue,
                                               id: HandleId,
                                               vp: MutableHandleValue)
                              -> bool>;
pub type SetPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId, v: HandleValue,
                                               receiver: HandleValue,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type GetOwnPropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               desc:
                                                   MutableHandle<PropertyDescriptor>)
                              -> bool>;
pub type DeletePropertyOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               result: *mut ObjectOpResult)
                              -> bool>;
pub type WatchOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId,
                                               callable: HandleObject)
                              -> bool>;
pub type UnwatchOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject,
                                               id: HandleId) -> bool>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct ElementAdder {
    pub resObj_: RootedObject,
    pub vp_: *mut Value,
    pub index_: u32,
    pub getBehavior_: ElementAdder_GetBehavior,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ElementAdder_GetBehavior {
    CheckHasElemPreserveHoles = 0,
    GetElement = 1,
}
#[test]
fn bindgen_test_layout_ElementAdder() {
    assert_eq!(::std::mem::size_of::<ElementAdder>() , 40usize);
    assert_eq!(::std::mem::align_of::<ElementAdder>() , 8usize);
}
extern "C" {
    #[link_name = "?getBehavior@ElementAdder@js@@QEBA?AW4GetBehavior@12@XZ"]
    fn _getBehavior_ElementAdder_js__QEBA_AW4GetBehavior_12_XZ_(this:
                                                                    *mut ElementAdder)
     -> ElementAdder_GetBehavior;
    #[link_name =
          "?append@ElementAdder@js@@QEAA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    fn _append_ElementAdder_js__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS___Z_(this:
                                                                                       *mut ElementAdder,
                                                                                   cx:
                                                                                       *mut JSContext,
                                                                                   v:
                                                                                       HandleValue)
     -> bool;
    #[link_name = "?appendHole@ElementAdder@js@@QEAAXXZ"]
    fn _appendHole_ElementAdder_js__QEAAXXZ_(this: *mut ElementAdder);
}
impl ElementAdder {
    #[inline]
    pub unsafe fn getBehavior(&mut self) -> ElementAdder_GetBehavior {
        _getBehavior_ElementAdder_js__QEBA_AW4GetBehavior_12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn append(&mut self, cx: *mut JSContext, v: HandleValue)
     -> bool {
        _append_ElementAdder_js__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS___Z_(&mut *self,
                                                                                    cx,
                                                                                    v)
    }
    #[inline]
    pub unsafe fn appendHole(&mut self) {
        _appendHole_ElementAdder_js__QEAAXXZ_(&mut *self)
    }
}
pub type GetElementsOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject, begin: u32,
                                               end: u32,
                                               adder: *mut ElementAdder)
                              -> bool>;
pub type FinalizeOp =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut FreeOp,
                                               obj: *mut JSObject)>;
/** Callback for the creation of constructor and prototype objects. */
pub type ClassObjectCreationOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               key: JSProtoKey)
                              -> *mut JSObject>;
/** Callback for custom post-processing after class initialization via ClassSpec. */
pub type FinishClassInitOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               ctor: HandleObject,
                                               proto: HandleObject) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassSpec {
    pub createConstructor_: ClassObjectCreationOp,
    pub createPrototype_: ClassObjectCreationOp,
    pub constructorFunctions_: *const JSFunctionSpec,
    pub constructorProperties_: *const JSPropertySpec,
    pub prototypeFunctions_: *const JSFunctionSpec,
    pub prototypeProperties_: *const JSPropertySpec,
    pub finishInit_: FinishClassInitOp,
    pub flags: usize,
}
impl ::std::clone::Clone for ClassSpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassSpec() {
    assert_eq!(::std::mem::size_of::<ClassSpec>() , 64usize);
    assert_eq!(::std::mem::align_of::<ClassSpec>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassExtension {
    /**
     * isWrappedNative is true only if the class is an XPCWrappedNative.
     * WeakMaps use this to override the wrapper disposal optimization.
     */
    pub isWrappedNative: bool,
    /**
     * If an object is used as a key in a weakmap, it may be desirable for the
     * garbage collector to keep that object around longer than it otherwise
     * would. A common case is when the key is a wrapper around an object in
     * another compartment, and we want to avoid collecting the wrapper (and
     * removing the weakmap entry) as long as the wrapped object is alive. In
     * that case, the wrapped object is returned by the wrapper's
     * weakmapKeyDelegateOp hook. As long as the wrapper is used as a weakmap
     * key, it will not be collected (and remain in the weakmap) until the
     * wrapped object is collected.
     */
    pub weakmapKeyDelegateOp: JSWeakmapKeyDelegateOp,
    /**
     * Optional hook called when an object is moved by a compacting GC.
     *
     * There may exist weak pointers to an object that are not traced through
     * when the normal trace APIs are used, for example objects in the wrapper
     * cache. This hook allows these pointers to be updated.
     *
     * Note that this hook can be called before JS_NewObject() returns if a GC
     * is triggered during construction of the object. This can happen for
     * global objects for example.
     */
    pub objectMovedOp: JSObjectMovedOp,
}
impl ::std::clone::Clone for ClassExtension {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassExtension() {
    assert_eq!(::std::mem::size_of::<ClassExtension>() , 24usize);
    assert_eq!(::std::mem::align_of::<ClassExtension>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectOps {
    pub lookupProperty: LookupPropertyOp,
    pub defineProperty: DefinePropertyOp,
    pub hasProperty: HasPropertyOp,
    pub getProperty: GetPropertyOp,
    pub setProperty: SetPropertyOp,
    pub getOwnPropertyDescriptor: GetOwnPropertyOp,
    pub deleteProperty: DeletePropertyOp,
    pub watch: WatchOp,
    pub unwatch: UnwatchOp,
    pub getElements: GetElementsOp,
    pub enumerate: JSNewEnumerateOp,
    pub funToString: JSFunToStringOp,
}
impl ::std::clone::Clone for ObjectOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectOps() {
    assert_eq!(::std::mem::size_of::<ObjectOps>() , 96usize);
    assert_eq!(::std::mem::align_of::<ObjectOps>() , 8usize);
}
pub type JSClassInternal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSClass {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub addProperty: JSAddPropertyOp,
    pub delProperty: JSDeletePropertyOp,
    pub getProperty: JSGetterOp,
    pub setProperty: JSSetterOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub mayResolve: JSMayResolveOp,
    pub finalize: JSFinalizeOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
    pub reserved: [*mut ::std::os::raw::c_void; 23usize],
}
impl ::std::clone::Clone for JSClass {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSClass() {
    assert_eq!(::std::mem::size_of::<JSClass>() , 296usize);
    assert_eq!(::std::mem::align_of::<JSClass>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Class {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub addProperty: JSAddPropertyOp,
    pub delProperty: JSDeletePropertyOp,
    pub getProperty: JSGetterOp,
    pub setProperty: JSSetterOp,
    pub enumerate: JSEnumerateOp,
    pub resolve: JSResolveOp,
    pub mayResolve: JSMayResolveOp,
    pub finalize: FinalizeOp,
    pub call: JSNative,
    pub hasInstance: JSHasInstanceOp,
    pub construct: JSNative,
    pub trace: JSTraceOp,
    pub spec: ClassSpec,
    pub ext: ClassExtension,
    pub ops: ObjectOps,
}
impl ::std::clone::Clone for Class {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Class() {
    assert_eq!(::std::mem::size_of::<Class>() , 296usize);
    assert_eq!(::std::mem::align_of::<Class>() , 8usize);
}
/**
 * Enumeration describing possible values of the [[Class]] internal property
 * value of objects.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ESClassValue {
    ESClass_Object = 0,
    ESClass_Array = 1,
    ESClass_Number = 2,
    ESClass_String = 3,
    ESClass_Boolean = 4,
    ESClass_RegExp = 5,
    ESClass_ArrayBuffer = 6,
    ESClass_SharedArrayBuffer = 7,
    ESClass_Date = 8,
    ESClass_Set = 9,
    ESClass_Map = 10,
    ESClass_Promise = 11,
    ESClass_Other = 12,
}
pub const SCTAG_TMO_ALLOC_DATA: TransferableOwnership =
    TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TransferableOwnership {
    SCTAG_TMO_UNFILLED = 0,
    SCTAG_TMO_UNOWNED = 1,
    SCTAG_TMO_FIRST_OWNED = 2,
    SCTAG_TMO_SHARED_BUFFER = 3,
    SCTAG_TMO_MAPPED_DATA = 4,
    SCTAG_TMO_CUSTOM = 5,
    SCTAG_TMO_USER_MIN = 6,
}
/**
 * Read structured data from the reader r. This hook is used to read a value
 * previously serialized by a call to the WriteStructuredCloneOp hook.
 *
 * tag and data are the pair of uint32_t values from the header. The callback
 * may use the JS_Read* APIs to read any other relevant parts of the object
 * from the reader r. closure is any value passed to the JS_ReadStructuredClone
 * function. Return the new object on success, nullptr on error/exception.
 */
pub type ReadStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               r:
                                                   *mut JSStructuredCloneReader,
                                               tag: u32, data: u32,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut JSObject>;
/**
 * Structured data serialization hook. The engine can write primitive values,
 * Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,
 * and SharedTypedArrays. Any other type of object requires application support.
 * This callback must first use the JS_WriteUint32Pair API to write an object
 * header, passing a value greater than JS_SCTAG_USER to the tag parameter.
 * Then it can use the JS_Write* APIs to write any other relevant parts of
 * the value v to the writer w. closure is any value passed to the
 * JS_WriteStructuredClone function.
 *
 * Return true on success, false on error/exception.
 */
pub type WriteStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               w:
                                                   *mut JSStructuredCloneWriter,
                                               obj: HandleObject,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
/**
 * This is called when JS_WriteStructuredClone is given an invalid transferable.
 * To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException
 * with error set to one of the JS_SCERR_* values.
 */
pub type StructuredCloneErrorOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               errorid: u32)>;
/**
 * This is called when JS_ReadStructuredClone receives a transferable object
 * not known to the engine. If this hook does not exist or returns false, the
 * JS engine calls the reportError op if set, otherwise it throws a
 * DATA_CLONE_ERR DOM Exception. This method is called before any other
 * callback and must return a non-null object in returnObject on success.
 */
pub type ReadTransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               r:
                                                   *mut JSStructuredCloneReader,
                                               tag: u32,
                                               content:
                                                   *mut ::std::os::raw::c_void,
                                               extraData: u64,
                                               closure:
                                                   *mut ::std::os::raw::c_void,
                                               returnObject:
                                                   MutableHandleObject)
                              -> bool>;
/**
 * Called when JS_WriteStructuredClone receives a transferable object not
 * handled by the engine. If this hook does not exist or returns false, the JS
 * engine will call the reportError hook or fall back to throwing a
 * DATA_CLONE_ERR DOM Exception. This method is called before any other
 * callback.
 *
 *  tag: indicates what type of transferable this is. Must be greater than
 *       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)
 *
 *  ownership: see TransferableOwnership, above. Used to communicate any needed
 *       ownership info to the FreeTransferStructuredCloneOp.
 *
 *  content, extraData: what the ReadTransferStructuredCloneOp will receive
 */
pub type TransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: Handle<*mut JSObject>,
                                               closure:
                                                   *mut ::std::os::raw::c_void,
                                               tag: *mut u32,
                                               ownership:
                                                   *mut TransferableOwnership,
                                               content:
                                                   *mut *mut ::std::os::raw::c_void,
                                               extraData: *mut u64) -> bool>;
/**
 * Called when JS_ClearStructuredClone has to free an unknown transferable
 * object. Note that it should never trigger a garbage collection (and will
 * assert in a debug build if it does.)
 */
pub type FreeTransferStructuredCloneOp =
    ::std::option::Option<unsafe extern "C" fn(tag: u32,
                                               ownership:
                                                   TransferableOwnership,
                                               content:
                                                   *mut ::std::os::raw::c_void,
                                               extraData: u64,
                                               closure:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSStructuredCloneCallbacks {
    pub read: ReadStructuredCloneOp,
    pub write: WriteStructuredCloneOp,
    pub reportError: StructuredCloneErrorOp,
    pub readTransfer: ReadTransferStructuredCloneOp,
    pub writeTransfer: TransferStructuredCloneOp,
    pub freeTransfer: FreeTransferStructuredCloneOp,
}
impl ::std::clone::Clone for JSStructuredCloneCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSStructuredCloneCallbacks() {
    assert_eq!(::std::mem::size_of::<JSStructuredCloneCallbacks>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSStructuredCloneCallbacks>() , 8usize);
}
/** RAII sugar for JS_WriteStructuredClone. */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoStructuredCloneBuffer {
    pub data_: *mut u64,
    pub nbytes_: usize,
    pub version_: u32,
    pub ownTransferables_: JSAutoStructuredCloneBuffer_StructuredClone_h_unnamed_7,
    pub callbacks_: *const JSStructuredCloneCallbacks,
    pub closure_: *mut ::std::os::raw::c_void,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSAutoStructuredCloneBuffer_StructuredClone_h_unnamed_7 {
    OwnsTransferablesIfAny = 0,
    IgnoreTransferablesIfAny = 1,
    NoTransferables = 2,
}
#[test]
fn bindgen_test_layout_JSAutoStructuredCloneBuffer() {
    assert_eq!(::std::mem::size_of::<JSAutoStructuredCloneBuffer>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<JSAutoStructuredCloneBuffer>() ,
               8usize);
}
extern "C" {
    #[link_name = "?data@JSAutoStructuredCloneBuffer@@QEBAPEA_KXZ"]
    fn _data_JSAutoStructuredCloneBuffer__QEBAPEA_KXZ_(this:
                                                           *mut JSAutoStructuredCloneBuffer)
     -> *mut u64;
    #[link_name = "?nbytes@JSAutoStructuredCloneBuffer@@QEBA_KXZ"]
    fn _nbytes_JSAutoStructuredCloneBuffer__QEBA_KXZ_(this:
                                                          *mut JSAutoStructuredCloneBuffer)
     -> usize;
    #[link_name =
          "?clear@JSAutoStructuredCloneBuffer@@QEAAXPEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _clear_JSAutoStructuredCloneBuffer__QEAAXPEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                            *mut JSAutoStructuredCloneBuffer,
                                                                                        optionalCallbacks:
                                                                                            *const JSStructuredCloneCallbacks,
                                                                                        closure:
                                                                                            *mut ::std::os::raw::c_void);
    #[link_name =
          "?copy@JSAutoStructuredCloneBuffer@@QEAA_NPEB_K_KIPEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _copy_JSAutoStructuredCloneBuffer__QEAA_NPEB_K_KIPEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                                    *mut JSAutoStructuredCloneBuffer,
                                                                                                data:
                                                                                                    *const u64,
                                                                                                nbytes:
                                                                                                    usize,
                                                                                                version:
                                                                                                    u32,
                                                                                                callbacks:
                                                                                                    *const JSStructuredCloneCallbacks,
                                                                                                closure:
                                                                                                    *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?adopt@JSAutoStructuredCloneBuffer@@QEAAXPEA_K_KIPEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _adopt_JSAutoStructuredCloneBuffer__QEAAXPEA_K_KIPEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                                    *mut JSAutoStructuredCloneBuffer,
                                                                                                data:
                                                                                                    *mut u64,
                                                                                                nbytes:
                                                                                                    usize,
                                                                                                version:
                                                                                                    u32,
                                                                                                callbacks:
                                                                                                    *const JSStructuredCloneCallbacks,
                                                                                                closure:
                                                                                                    *mut ::std::os::raw::c_void);
    #[link_name =
          "?steal@JSAutoStructuredCloneBuffer@@QEAAXPEAPEA_KPEA_KPEAIPEAPEBUJSStructuredCloneCallbacks@@PEAPEAX@Z"]
    fn _steal_JSAutoStructuredCloneBuffer__QEAAXPEAPEA_KPEA_KPEAIPEAPEBUJSStructuredCloneCallbacks__PEAPEAX_Z_(this:
                                                                                                                   *mut JSAutoStructuredCloneBuffer,
                                                                                                               datap:
                                                                                                                   *mut *mut u64,
                                                                                                               nbytesp:
                                                                                                                   *mut usize,
                                                                                                               versionp:
                                                                                                                   *mut u32,
                                                                                                               callbacks:
                                                                                                                   *mut *const JSStructuredCloneCallbacks,
                                                                                                               closure:
                                                                                                                   *mut *mut ::std::os::raw::c_void);
    #[link_name = "?abandon@JSAutoStructuredCloneBuffer@@QEAAXXZ"]
    fn _abandon_JSAutoStructuredCloneBuffer__QEAAXXZ_(this:
                                                          *mut JSAutoStructuredCloneBuffer);
    #[link_name =
          "?read@JSAutoStructuredCloneBuffer@@QEAA_NPEAUJSContext@@V?$MutableHandle@VValue@JS@@@JS@@PEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _read_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__MutableHandle_VValue_JS___JS__PEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                                                                            *mut JSAutoStructuredCloneBuffer,
                                                                                                                                        cx:
                                                                                                                                            *mut JSContext,
                                                                                                                                        vp:
                                                                                                                                            MutableHandleValue,
                                                                                                                                        optionalCallbacks:
                                                                                                                                            *const JSStructuredCloneCallbacks,
                                                                                                                                        closure:
                                                                                                                                            *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?write@JSAutoStructuredCloneBuffer@@QEAA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _write_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS__PEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                                                                      *mut JSAutoStructuredCloneBuffer,
                                                                                                                                  cx:
                                                                                                                                      *mut JSContext,
                                                                                                                                  v:
                                                                                                                                      HandleValue,
                                                                                                                                  optionalCallbacks:
                                                                                                                                      *const JSStructuredCloneCallbacks,
                                                                                                                                  closure:
                                                                                                                                      *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?write@JSAutoStructuredCloneBuffer@@QEAA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@1PEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    fn _write_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS__1PEBUJSStructuredCloneCallbacks__PEAX_Z_(this:
                                                                                                                                       *mut JSAutoStructuredCloneBuffer,
                                                                                                                                   cx:
                                                                                                                                       *mut JSContext,
                                                                                                                                   v:
                                                                                                                                       HandleValue,
                                                                                                                                   transferable:
                                                                                                                                       HandleValue,
                                                                                                                                   optionalCallbacks:
                                                                                                                                       *const JSStructuredCloneCallbacks,
                                                                                                                                   closure:
                                                                                                                                       *mut ::std::os::raw::c_void)
     -> bool;
}
impl JSAutoStructuredCloneBuffer {
    #[inline]
    pub unsafe fn data(&mut self) -> *mut u64 {
        _data_JSAutoStructuredCloneBuffer__QEBAPEA_KXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn nbytes(&mut self) -> usize {
        _nbytes_JSAutoStructuredCloneBuffer__QEBA_KXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn clear(&mut self,
                        optionalCallbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) {
        _clear_JSAutoStructuredCloneBuffer__QEAAXPEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                         optionalCallbacks,
                                                                                         closure)
    }
    /** Copy some memory. It will be automatically freed by the destructor. */
    #[inline]
    pub unsafe fn copy(&mut self, data: *const u64, nbytes: usize,
                       version: u32,
                       callbacks: *const JSStructuredCloneCallbacks,
                       closure: *mut ::std::os::raw::c_void) -> bool {
        _copy_JSAutoStructuredCloneBuffer__QEAA_NPEB_K_KIPEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                                 data,
                                                                                                 nbytes,
                                                                                                 version,
                                                                                                 callbacks,
                                                                                                 closure)
    }
    /**
     * Adopt some memory. It will be automatically freed by the destructor.
     * data must have been allocated by the JS engine (e.g., extracted via
     * JSAutoStructuredCloneBuffer::steal).
     */
    #[inline]
    pub unsafe fn adopt(&mut self, data: *mut u64, nbytes: usize,
                        version: u32,
                        callbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) {
        _adopt_JSAutoStructuredCloneBuffer__QEAAXPEA_K_KIPEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                                 data,
                                                                                                 nbytes,
                                                                                                 version,
                                                                                                 callbacks,
                                                                                                 closure)
    }
    /**
     * Release the buffer and transfer ownership to the caller. The caller is
     * responsible for calling JS_ClearStructuredClone or feeding the memory
     * back to JSAutoStructuredCloneBuffer::adopt.
     */
    #[inline]
    pub unsafe fn steal(&mut self, datap: *mut *mut u64, nbytesp: *mut usize,
                        versionp: *mut u32,
                        callbacks: *mut *const JSStructuredCloneCallbacks,
                        closure: *mut *mut ::std::os::raw::c_void) {
        _steal_JSAutoStructuredCloneBuffer__QEAAXPEAPEA_KPEA_KPEAIPEAPEBUJSStructuredCloneCallbacks__PEAPEAX_Z_(&mut *self,
                                                                                                                datap,
                                                                                                                nbytesp,
                                                                                                                versionp,
                                                                                                                callbacks,
                                                                                                                closure)
    }
    /**
     * Abandon ownership of any transferable objects stored in the buffer,
     * without freeing the buffer itself. Useful when copying the data out into
     * an external container, though note that you will need to use adopt() or
     * JS_ClearStructuredClone to properly release that data eventually.
     */
    #[inline]
    pub unsafe fn abandon(&mut self) {
        _abandon_JSAutoStructuredCloneBuffer__QEAAXXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn read(&mut self, cx: *mut JSContext, vp: MutableHandleValue,
                       optionalCallbacks: *const JSStructuredCloneCallbacks,
                       closure: *mut ::std::os::raw::c_void) -> bool {
        _read_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__MutableHandle_VValue_JS___JS__PEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                                                                         cx,
                                                                                                                                         vp,
                                                                                                                                         optionalCallbacks,
                                                                                                                                         closure)
    }
    #[inline]
    pub unsafe fn write(&mut self, cx: *mut JSContext, v: HandleValue,
                        optionalCallbacks: *const JSStructuredCloneCallbacks,
                        closure: *mut ::std::os::raw::c_void) -> bool {
        _write_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS__PEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                                                                   cx,
                                                                                                                                   v,
                                                                                                                                   optionalCallbacks,
                                                                                                                                   closure)
    }
    #[inline]
    pub unsafe fn write1(&mut self, cx: *mut JSContext, v: HandleValue,
                         transferable: HandleValue,
                         optionalCallbacks: *const JSStructuredCloneCallbacks,
                         closure: *mut ::std::os::raw::c_void) -> bool {
        _write_JSAutoStructuredCloneBuffer__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS__1PEBUJSStructuredCloneCallbacks__PEAX_Z_(&mut *self,
                                                                                                                                    cx,
                                                                                                                                    v,
                                                                                                                                    transferable,
                                                                                                                                    optionalCallbacks,
                                                                                                                                    closure)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSPrincipals {
    pub _vftable: *const _vftable_JSPrincipals,
    pub refcount: u32,
    pub debugToken: u32,
}
#[repr(C)]
pub struct _vftable_JSPrincipals {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
#[test]
fn bindgen_test_layout_JSPrincipals() {
    assert_eq!(::std::mem::size_of::<JSPrincipals>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSPrincipals>() , 8usize);
}
pub type JSSubsumesOp =
    ::std::option::Option<unsafe extern "C" fn(first: *mut JSPrincipals,
                                               second: *mut JSPrincipals)
                              -> bool>;
pub type JSCSPEvalChecker =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSSecurityCallbacks {
    pub contentSecurityPolicyAllows: JSCSPEvalChecker,
    pub subsumes: JSSubsumesOp,
}
impl ::std::clone::Clone for JSSecurityCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSSecurityCallbacks() {
    assert_eq!(::std::mem::size_of::<JSSecurityCallbacks>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSSecurityCallbacks>() , 8usize);
}
pub type JSDestroyPrincipalsOp =
    ::std::option::Option<unsafe extern "C" fn(principals:
                                                   *mut JSPrincipals)>;
pub type JSReadPrincipalsOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               reader:
                                                   *mut JSStructuredCloneReader,
                                               outPrincipals:
                                                   *mut *mut JSPrincipals)
                              -> bool>;
pub enum TwoByteChars { }
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCheckRequestDepth {
    pub cx: *mut JSContext,
}
#[test]
fn bindgen_test_layout_AutoCheckRequestDepth() {
    assert_eq!(::std::mem::size_of::<AutoCheckRequestDepth>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoCheckRequestDepth>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoVectorRooterBase<T> {
    pub _base: AutoGCRooter,
    pub _phantom0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoVectorRooter<T> {
    pub _base: AutoVectorRooterBase<T>,
}
pub type AutoValueVector = AutoVectorRooter<Value>;
pub type AutoObjectVector = AutoVectorRooter<*mut JSObject>;
pub type ValueVector = ::std::os::raw::c_void;
pub type IdVector = ::std::os::raw::c_void;
pub type ScriptVector = ::std::os::raw::c_void;
/**
 * Custom rooting behavior for internal and external clients.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct CustomAutoRooter {
    pub _vftable: *const _vftable_CustomAutoRooter,
    pub _base: AutoGCRooter,
}
#[repr(C)]
pub struct _vftable_CustomAutoRooter {
    pub trace: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void,
                                    trc: *mut JSTracer),
}
#[test]
fn bindgen_test_layout_CustomAutoRooter() {
    assert_eq!(::std::mem::size_of::<CustomAutoRooter>() , 32usize);
    assert_eq!(::std::mem::align_of::<CustomAutoRooter>() , 8usize);
}
/** A handle to an array of rooted values. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HandleValueArray {
    pub length_: usize,
    pub elements_: *const Value,
}
impl ::std::clone::Clone for HandleValueArray {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_HandleValueArray() {
    assert_eq!(::std::mem::size_of::<HandleValueArray>() , 16usize);
    assert_eq!(::std::mem::align_of::<HandleValueArray>() , 8usize);
}
/************************************************************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFreeOp {
    pub runtime_: *mut JSRuntime,
}
impl ::std::clone::Clone for JSFreeOp {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFreeOp() {
    assert_eq!(::std::mem::size_of::<JSFreeOp>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSFreeOp>() , 8usize);
}
/************************************************************************/
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSContextOp { JSCONTEXT_NEW = 0, JSCONTEXT_DESTROY = 1, }
/**
 * The possible values for contextOp when the runtime calls the callback are:
 *   JSCONTEXT_NEW      JS_NewContext successfully created a new JSContext
 *                      instance. The callback can initialize the instance as
 *                      required. If the callback returns false, the instance
 *                      will be destroyed and JS_NewContext returns null. In
 *                      this case the callback is not called again.
 *   JSCONTEXT_DESTROY  One of JS_DestroyContext* methods is called. The
 *                      callback may perform its own cleanup and must always
 *                      return true.
 *   Any other value    For future compatibility the callback must do nothing
 *                      and return true in this case.
 */
pub type JSContextCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               contextOp:
                                                   ::std::os::raw::c_uint,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCStatus { JSGC_BEGIN = 0, JSGC_END = 1, }
pub type JSGCCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               status: JSGCStatus,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSObjectsTenuredCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSFinalizeStatus {
    JSFINALIZE_GROUP_START = 0,
    JSFINALIZE_GROUP_END = 1,
    JSFINALIZE_COLLECTION_END = 2,
}
pub type JSFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               status: JSFinalizeStatus,
                                               isCompartment: bool,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSWeakPointerZoneGroupCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSWeakPointerCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               comp: *mut JSCompartment,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type JSInterruptCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext) -> bool>;
pub type JSEnqueuePromiseJobCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               job: HandleObject,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type JSErrorReporter =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               message:
                                                   *const ::std::os::raw::c_char,
                                               report: *mut JSErrorReport)>;
/**
 * Possible exception types. These types are part of a JSErrorFormatString
 * structure. They define which error to throw in case of a runtime error.
 * JSEXN_NONE marks an unthrowable error.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSExnType {
    JSEXN_NONE = -1,
    JSEXN_ERR = 0,
    JSEXN_INTERNALERR = 1,
    JSEXN_EVALERR = 2,
    JSEXN_RANGEERR = 3,
    JSEXN_REFERENCEERR = 4,
    JSEXN_SYNTAXERR = 5,
    JSEXN_TYPEERR = 6,
    JSEXN_URIERR = 7,
    JSEXN_DEBUGGEEWOULDRUN = 8,
    JSEXN_LIMIT = 9,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSErrorFormatString {
    /** The error message name in ASCII. */
    pub name: *const ::std::os::raw::c_char,
    /** The error format string in ASCII. */
    pub format: *const ::std::os::raw::c_char,
    /** The number of arguments to expand in the formatted error message. */
    pub argCount: u16,
    /** One of the JSExnType constants above. */
    pub exnType: i16,
}
impl ::std::clone::Clone for JSErrorFormatString {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSErrorFormatString() {
    assert_eq!(::std::mem::size_of::<JSErrorFormatString>() , 24usize);
    assert_eq!(::std::mem::align_of::<JSErrorFormatString>() , 8usize);
}
pub type JSErrorCallback =
    ::std::option::Option<unsafe extern "C" fn(userRef:
                                                   *mut ::std::os::raw::c_void,
                                               errorNumber:
                                                   ::std::os::raw::c_uint)
                              -> *const JSErrorFormatString>;
pub type JSLocaleToUpperCase =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleToLowerCase =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleCompare =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src1: HandleString,
                                               src2: HandleString,
                                               rval: MutableHandleValue)
                              -> bool>;
pub type JSLocaleToUnicode =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               src:
                                                   *const ::std::os::raw::c_char,
                                               rval: MutableHandleValue)
                              -> bool>;
/**
 * Callback used to ask the embedding for the cross compartment wrapper handler
 * that implements the desired prolicy for this kind of object in the
 * destination compartment. |obj| is the object to be wrapped. If |existing| is
 * non-nullptr, it will point to an existing wrapper object that should be
 * re-used if possible. |existing| is guaranteed to be a cross-compartment
 * wrapper with a lazily-defined prototype and the correct global. It is
 * guaranteed not to wrap a function.
 */
pub type JSWrapObjectCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               existing: HandleObject,
                                               obj: HandleObject)
                              -> *mut JSObject>;
/**
 * Callback used by the wrap hook to ask the embedding to prepare an object
 * for wrapping in a context. This might include unwrapping other wrappers
 * or even finding a more suitable object for the new compartment.
 */
pub type JSPreWrapCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               scope: HandleObject,
                                               obj: HandleObject,
                                               objectPassedToWrap:
                                                   HandleObject)
                              -> *mut JSObject>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSWrapObjectCallbacks {
    pub wrap: JSWrapObjectCallback,
    pub preWrap: JSPreWrapCallback,
}
impl ::std::clone::Clone for JSWrapObjectCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSWrapObjectCallbacks() {
    assert_eq!(::std::mem::size_of::<JSWrapObjectCallbacks>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSWrapObjectCallbacks>() , 8usize);
}
pub type JSDestroyCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(fop: *mut JSFreeOp,
                                               compartment:
                                                   *mut JSCompartment)>;
pub type JSSizeOfIncludingThisCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(mallocSizeOf: MallocSizeOf,
                                               compartment:
                                                   *mut JSCompartment)
                              -> usize>;
pub type JSZoneCallback =
    ::std::option::Option<unsafe extern "C" fn(zone: *mut Zone)>;
pub type JSCompartmentNameCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               compartment:
                                                   *mut JSCompartment,
                                               buf:
                                                   *mut ::std::os::raw::c_char,
                                               bufsize: usize)>;
/**
 * Container class for passing in script source buffers to the JS engine.  This
 * not only groups the buffer and length values, it also provides a way to
 * optionally pass ownership of the buffer to the JS engine without copying.
 * Rules for use:
 *
 *  1) The data array must be allocated with js_malloc() or js_realloc() if
 *     ownership is being granted to the SourceBufferHolder.
 *  2) If ownership is not given to the SourceBufferHolder, then the memory
 *     must be kept alive until the JS compilation is complete.
 *  3) Any code calling SourceBufferHolder::take() must guarantee to keep the
 *     memory alive until JS compilation completes.  Normally only the JS
 *     engine should be calling take().
 *
 * Example use:
 *
 *    size_t length = 512;
 *    char16_t* chars = static_cast<char16_t*>(js_malloc(sizeof(char16_t) * length));
 *    JS::SourceBufferHolder srcBuf(chars, length, JS::SourceBufferHolder::GiveOwnership);
 *    JS::Compile(cx, options, srcBuf);
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct SourceBufferHolder {
    pub data_: *const ::std::os::raw::c_ushort,
    pub length_: usize,
    pub ownsChars_: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SourceBufferHolder_Ownership { NoOwnership = 0, GiveOwnership = 1, }
#[test]
fn bindgen_test_layout_SourceBufferHolder() {
    assert_eq!(::std::mem::size_of::<SourceBufferHolder>() , 24usize);
    assert_eq!(::std::mem::align_of::<SourceBufferHolder>() , 8usize);
}
pub type JS_CurrentEmbedderTimeFunction =
    ::std::option::Option<unsafe extern "C" fn() -> f64>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoRequest {
    pub mContext: *mut JSContext,
}
#[test]
fn bindgen_test_layout_JSAutoRequest() {
    assert_eq!(::std::mem::size_of::<JSAutoRequest>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSAutoRequest>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RuntimeOptions {
    pub _bitfield_1: u8,
    pub _bitfield_2: u8,
}
impl RuntimeOptions {
    pub fn set_baseline_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 0usize);
        self._bitfield_1 |= (val as u8) << 0usize;
    }
    pub fn set_ion_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 1usize);
        self._bitfield_1 |= (val as u8) << 1usize;
    }
    pub fn set_asmJS_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 2usize);
        self._bitfield_1 |= (val as u8) << 2usize;
    }
    pub fn set_wasm_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 3usize);
        self._bitfield_1 |= (val as u8) << 3usize;
    }
    pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 4usize);
        self._bitfield_1 |= (val as u8) << 4usize;
    }
    pub fn set_nativeRegExp_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 5usize);
        self._bitfield_1 |= (val as u8) << 5usize;
    }
    pub fn set_unboxedArrays_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 6usize);
        self._bitfield_1 |= (val as u8) << 6usize;
    }
    pub fn set_asyncStack_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 7usize);
        self._bitfield_1 |= (val as u8) << 7usize;
    }
    pub const fn new_bitfield_1(baseline_: bool, ion_: bool, asmJS_: bool,
                                wasm_: bool,
                                throwOnAsmJSValidationFailure_: bool,
                                nativeRegExp_: bool, unboxedArrays_: bool,
                                asyncStack_: bool) -> u8 {
        0 | ((baseline_ as u8) << 0u32) | ((ion_ as u8) << 1u32) |
            ((asmJS_ as u8) << 2u32) | ((wasm_ as u8) << 3u32) |
            ((throwOnAsmJSValidationFailure_ as u8) << 4u32) |
            ((nativeRegExp_ as u8) << 5u32) | ((unboxedArrays_ as u8) << 6u32)
            | ((asyncStack_ as u8) << 7u32)
    }
    pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 0usize);
        self._bitfield_2 |= (val as u8) << 0usize;
    }
    pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 1usize);
        self._bitfield_2 |= (val as u8) << 1usize;
    }
    pub fn set_werror_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 2usize);
        self._bitfield_2 |= (val as u8) << 2usize;
    }
    pub fn set_strictMode_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 3usize);
        self._bitfield_2 |= (val as u8) << 3usize;
    }
    pub fn set_extraWarnings_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 4usize);
        self._bitfield_2 |= (val as u8) << 4usize;
    }
    pub fn set_matchFlagArgument_(&mut self, val: bool) {
        self._bitfield_2 &= !(((1 << (1u32 as u8)) - 1) << 5usize);
        self._bitfield_2 |= (val as u8) << 5usize;
    }
    pub const fn new_bitfield_2(throwOnDebuggeeWouldRun_: bool,
                                dumpStackOnDebuggeeWouldRun_: bool,
                                werror_: bool, strictMode_: bool,
                                extraWarnings_: bool,
                                matchFlagArgument_: bool) -> u8 {
        0 | ((throwOnDebuggeeWouldRun_ as u8) << 0u32) |
            ((dumpStackOnDebuggeeWouldRun_ as u8) << 1u32) |
            ((werror_ as u8) << 2u32) | ((strictMode_ as u8) << 3u32) |
            ((extraWarnings_ as u8) << 4u32) |
            ((matchFlagArgument_ as u8) << 5u32)
    }
}
impl ::std::clone::Clone for RuntimeOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_RuntimeOptions() {
    assert_eq!(::std::mem::size_of::<RuntimeOptions>() , 2usize);
    assert_eq!(::std::mem::align_of::<RuntimeOptions>() , 1usize);
}
extern "C" {
    #[link_name = "?baseline@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _baseline_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setBaseline@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setBaseline_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                            *mut RuntimeOptions,
                                                        flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleBaseline@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleBaseline_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                             *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?ion@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _ion_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions) -> bool;
    #[link_name = "?setIon@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setIon_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this: *mut RuntimeOptions,
                                                   flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleIon@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleIon_RuntimeOptions_JS__QEAAAEAV12_XZ_(this: *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?asmJS@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _asmJS_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions) -> bool;
    #[link_name = "?setAsmJS@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setAsmJS_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                         *mut RuntimeOptions,
                                                     flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleAsmJS@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleAsmJS_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                          *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?wasm@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _wasm_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions) -> bool;
    #[link_name = "?setWasm@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setWasm_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this: *mut RuntimeOptions,
                                                    flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleWasm@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleWasm_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                         *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name =
          "?throwOnAsmJSValidationFailure@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _throwOnAsmJSValidationFailure_RuntimeOptions_JS__QEBA_NXZ_(this:
                                                                       *mut RuntimeOptions)
     -> bool;
    #[link_name =
          "?setThrowOnAsmJSValidationFailure@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setThrowOnAsmJSValidationFailure_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                                 *mut RuntimeOptions,
                                                                             flag:
                                                                                 bool)
     -> *mut RuntimeOptions;
    #[link_name =
          "?toggleThrowOnAsmJSValidationFailure@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleThrowOnAsmJSValidationFailure_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                                                  *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?nativeRegExp@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _nativeRegExp_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setNativeRegExp@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setNativeRegExp_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                *mut RuntimeOptions,
                                                            flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?unboxedArrays@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _unboxedArrays_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setUnboxedArrays@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setUnboxedArrays_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                 *mut RuntimeOptions,
                                                             flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?asyncStack@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _asyncStack_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setAsyncStack@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setAsyncStack_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                              *mut RuntimeOptions,
                                                          flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?throwOnDebuggeeWouldRun@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _throwOnDebuggeeWouldRun_RuntimeOptions_JS__QEBA_NXZ_(this:
                                                                 *mut RuntimeOptions)
     -> bool;
    #[link_name =
          "?setThrowOnDebuggeeWouldRun@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setThrowOnDebuggeeWouldRun_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                           *mut RuntimeOptions,
                                                                       flag:
                                                                           bool)
     -> *mut RuntimeOptions;
    #[link_name = "?dumpStackOnDebuggeeWouldRun@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _dumpStackOnDebuggeeWouldRun_RuntimeOptions_JS__QEBA_NXZ_(this:
                                                                     *mut RuntimeOptions)
     -> bool;
    #[link_name =
          "?setDumpStackOnDebuggeeWouldRun@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setDumpStackOnDebuggeeWouldRun_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                               *mut RuntimeOptions,
                                                                           flag:
                                                                               bool)
     -> *mut RuntimeOptions;
    #[link_name = "?werror@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _werror_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setWerror@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setWerror_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                          *mut RuntimeOptions,
                                                      flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleWerror@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleWerror_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                           *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?strictMode@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _strictMode_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setStrictMode@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setStrictMode_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                              *mut RuntimeOptions,
                                                          flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleStrictMode@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleStrictMode_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                               *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?extraWarnings@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _extraWarnings_RuntimeOptions_JS__QEBA_NXZ_(this: *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setExtraWarnings@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setExtraWarnings_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                 *mut RuntimeOptions,
                                                             flag: bool)
     -> *mut RuntimeOptions;
    #[link_name = "?toggleExtraWarnings@RuntimeOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleExtraWarnings_RuntimeOptions_JS__QEAAAEAV12_XZ_(this:
                                                                  *mut RuntimeOptions)
     -> *mut RuntimeOptions;
    #[link_name = "?matchFlagArgument@RuntimeOptions@JS@@QEBA_NXZ"]
    fn _matchFlagArgument_RuntimeOptions_JS__QEBA_NXZ_(this:
                                                           *mut RuntimeOptions)
     -> bool;
    #[link_name = "?setMatchFlagArgument@RuntimeOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setMatchFlagArgument_RuntimeOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                     *mut RuntimeOptions,
                                                                 flag: bool)
     -> *mut RuntimeOptions;
}
impl RuntimeOptions {
    #[inline]
    pub unsafe fn baseline(&mut self) -> bool {
        _baseline_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setBaseline(&mut self, flag: bool) -> *mut RuntimeOptions {
        _setBaseline_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleBaseline(&mut self) -> *mut RuntimeOptions {
        _toggleBaseline_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn ion(&mut self) -> bool {
        _ion_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setIon(&mut self, flag: bool) -> *mut RuntimeOptions {
        _setIon_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleIon(&mut self) -> *mut RuntimeOptions {
        _toggleIon_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn asmJS(&mut self) -> bool {
        _asmJS_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setAsmJS(&mut self, flag: bool) -> *mut RuntimeOptions {
        _setAsmJS_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleAsmJS(&mut self) -> *mut RuntimeOptions {
        _toggleAsmJS_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn wasm(&mut self) -> bool {
        _wasm_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setWasm(&mut self, flag: bool) -> *mut RuntimeOptions {
        _setWasm_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleWasm(&mut self) -> *mut RuntimeOptions {
        _toggleWasm_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn throwOnAsmJSValidationFailure(&mut self) -> bool {
        _throwOnAsmJSValidationFailure_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setThrowOnAsmJSValidationFailure(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setThrowOnAsmJSValidationFailure_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                              flag)
    }
    #[inline]
    pub unsafe fn toggleThrowOnAsmJSValidationFailure(&mut self)
     -> *mut RuntimeOptions {
        _toggleThrowOnAsmJSValidationFailure_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn nativeRegExp(&mut self) -> bool {
        _nativeRegExp_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setNativeRegExp(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setNativeRegExp_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn unboxedArrays(&mut self) -> bool {
        _unboxedArrays_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setUnboxedArrays(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setUnboxedArrays_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                              flag)
    }
    #[inline]
    pub unsafe fn asyncStack(&mut self) -> bool {
        _asyncStack_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setAsyncStack(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setAsyncStack_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn throwOnDebuggeeWouldRun(&mut self) -> bool {
        _throwOnDebuggeeWouldRun_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setThrowOnDebuggeeWouldRun(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setThrowOnDebuggeeWouldRun_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                        flag)
    }
    #[inline]
    pub unsafe fn dumpStackOnDebuggeeWouldRun(&mut self) -> bool {
        _dumpStackOnDebuggeeWouldRun_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setDumpStackOnDebuggeeWouldRun(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setDumpStackOnDebuggeeWouldRun_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                            flag)
    }
    #[inline]
    pub unsafe fn werror(&mut self) -> bool {
        _werror_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setWerror(&mut self, flag: bool) -> *mut RuntimeOptions {
        _setWerror_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleWerror(&mut self) -> *mut RuntimeOptions {
        _toggleWerror_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn strictMode(&mut self) -> bool {
        _strictMode_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setStrictMode(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setStrictMode_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self, flag)
    }
    #[inline]
    pub unsafe fn toggleStrictMode(&mut self) -> *mut RuntimeOptions {
        _toggleStrictMode_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn extraWarnings(&mut self) -> bool {
        _extraWarnings_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setExtraWarnings(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setExtraWarnings_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                              flag)
    }
    #[inline]
    pub unsafe fn toggleExtraWarnings(&mut self) -> *mut RuntimeOptions {
        _toggleExtraWarnings_RuntimeOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn matchFlagArgument(&mut self) -> bool {
        _matchFlagArgument_RuntimeOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setMatchFlagArgument(&mut self, flag: bool)
     -> *mut RuntimeOptions {
        _setMatchFlagArgument_RuntimeOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                  flag)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ContextOptions {
    pub _bitfield_1: u8,
}
impl ContextOptions {
    pub fn set_privateIsNSISupports_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 0usize);
        self._bitfield_1 |= (val as u8) << 0usize;
    }
    pub fn set_dontReportUncaught_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 1usize);
        self._bitfield_1 |= (val as u8) << 1usize;
    }
    pub fn set_autoJSAPIOwnsErrorReporting_(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u8)) - 1) << 2usize);
        self._bitfield_1 |= (val as u8) << 2usize;
    }
    pub const fn new_bitfield_1(privateIsNSISupports_: bool,
                                dontReportUncaught_: bool,
                                autoJSAPIOwnsErrorReporting_: bool) -> u8 {
        0 | ((privateIsNSISupports_ as u8) << 0u32) |
            ((dontReportUncaught_ as u8) << 1u32) |
            ((autoJSAPIOwnsErrorReporting_ as u8) << 2u32)
    }
}
impl ::std::clone::Clone for ContextOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ContextOptions() {
    assert_eq!(::std::mem::size_of::<ContextOptions>() , 1usize);
    assert_eq!(::std::mem::align_of::<ContextOptions>() , 1usize);
}
extern "C" {
    #[link_name = "?privateIsNSISupports@ContextOptions@JS@@QEBA_NXZ"]
    fn _privateIsNSISupports_ContextOptions_JS__QEBA_NXZ_(this:
                                                              *mut ContextOptions)
     -> bool;
    #[link_name =
          "?setPrivateIsNSISupports@ContextOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setPrivateIsNSISupports_ContextOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                        *mut ContextOptions,
                                                                    flag:
                                                                        bool)
     -> *mut ContextOptions;
    #[link_name =
          "?togglePrivateIsNSISupports@ContextOptions@JS@@QEAAAEAV12@XZ"]
    fn _togglePrivateIsNSISupports_ContextOptions_JS__QEAAAEAV12_XZ_(this:
                                                                         *mut ContextOptions)
     -> *mut ContextOptions;
    #[link_name = "?dontReportUncaught@ContextOptions@JS@@QEBA_NXZ"]
    fn _dontReportUncaught_ContextOptions_JS__QEBA_NXZ_(this:
                                                            *mut ContextOptions)
     -> bool;
    #[link_name = "?setDontReportUncaught@ContextOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setDontReportUncaught_ContextOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                      *mut ContextOptions,
                                                                  flag: bool)
     -> *mut ContextOptions;
    #[link_name =
          "?toggleDontReportUncaught@ContextOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleDontReportUncaught_ContextOptions_JS__QEAAAEAV12_XZ_(this:
                                                                       *mut ContextOptions)
     -> *mut ContextOptions;
    #[link_name = "?autoJSAPIOwnsErrorReporting@ContextOptions@JS@@QEBA_NXZ"]
    fn _autoJSAPIOwnsErrorReporting_ContextOptions_JS__QEBA_NXZ_(this:
                                                                     *mut ContextOptions)
     -> bool;
    #[link_name =
          "?setAutoJSAPIOwnsErrorReporting@ContextOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setAutoJSAPIOwnsErrorReporting_ContextOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                               *mut ContextOptions,
                                                                           flag:
                                                                               bool)
     -> *mut ContextOptions;
    #[link_name =
          "?toggleAutoJSAPIOwnsErrorReporting@ContextOptions@JS@@QEAAAEAV12@XZ"]
    fn _toggleAutoJSAPIOwnsErrorReporting_ContextOptions_JS__QEAAAEAV12_XZ_(this:
                                                                                *mut ContextOptions)
     -> *mut ContextOptions;
}
impl ContextOptions {
    #[inline]
    pub unsafe fn privateIsNSISupports(&mut self) -> bool {
        _privateIsNSISupports_ContextOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setPrivateIsNSISupports(&mut self, flag: bool)
     -> *mut ContextOptions {
        _setPrivateIsNSISupports_ContextOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                     flag)
    }
    #[inline]
    pub unsafe fn togglePrivateIsNSISupports(&mut self)
     -> *mut ContextOptions {
        _togglePrivateIsNSISupports_ContextOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn dontReportUncaught(&mut self) -> bool {
        _dontReportUncaught_ContextOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setDontReportUncaught(&mut self, flag: bool)
     -> *mut ContextOptions {
        _setDontReportUncaught_ContextOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                   flag)
    }
    #[inline]
    pub unsafe fn toggleDontReportUncaught(&mut self) -> *mut ContextOptions {
        _toggleDontReportUncaught_ContextOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn autoJSAPIOwnsErrorReporting(&mut self) -> bool {
        _autoJSAPIOwnsErrorReporting_ContextOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setAutoJSAPIOwnsErrorReporting(&mut self, flag: bool)
     -> *mut ContextOptions {
        _setAutoJSAPIOwnsErrorReporting_ContextOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                            flag)
    }
    #[inline]
    pub unsafe fn toggleAutoJSAPIOwnsErrorReporting(&mut self)
     -> *mut ContextOptions {
        _toggleAutoJSAPIOwnsErrorReporting_ContextOptions_JS__QEAAAEAV12_XZ_(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSaveContextOptions {
    pub cx_: *mut JSContext,
    pub oldOptions_: ContextOptions,
}
#[test]
fn bindgen_test_layout_AutoSaveContextOptions() {
    assert_eq!(::std::mem::size_of::<AutoSaveContextOptions>() , 16usize);
    assert_eq!(::std::mem::align_of::<AutoSaveContextOptions>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoCompartment {
    pub cx_: *mut JSContext,
    pub oldCompartment_: *mut JSCompartment,
}
#[test]
fn bindgen_test_layout_JSAutoCompartment() {
    assert_eq!(::std::mem::size_of::<JSAutoCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSAutoCompartment>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoNullableCompartment {
    pub cx_: *mut JSContext,
    pub oldCompartment_: *mut JSCompartment,
}
#[test]
fn bindgen_test_layout_JSAutoNullableCompartment() {
    assert_eq!(::std::mem::size_of::<JSAutoNullableCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSAutoNullableCompartment>() , 8usize);
}
pub type JSIterateCompartmentCallback =
    ::std::option::Option<unsafe extern "C" fn(rt: *mut JSRuntime,
                                               data:
                                                   *mut ::std::os::raw::c_void,
                                               compartment:
                                                   *mut JSCompartment)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSGCParamKey {
    JSGC_MAX_BYTES = 0,
    JSGC_MAX_MALLOC_BYTES = 1,
    JSGC_BYTES = 3,
    JSGC_NUMBER = 4,
    JSGC_MODE = 6,
    JSGC_UNUSED_CHUNKS = 7,
    JSGC_TOTAL_CHUNKS = 8,
    JSGC_SLICE_TIME_BUDGET = 9,
    JSGC_MARK_STACK_LIMIT = 10,
    JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
    JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,
    JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,
    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,
    JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,
    JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
    JSGC_DYNAMIC_HEAP_GROWTH = 17,
    JSGC_DYNAMIC_MARK_SLICE = 18,
    JSGC_ALLOCATION_THRESHOLD = 19,
    JSGC_DECOMMIT_THRESHOLD = 20,
    JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
    JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
    JSGC_COMPACTING_ENABLED = 23,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSConstScalarSpec<T> {
    pub name: *const ::std::os::raw::c_char,
    pub val: T,
}
/**
 * Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will
 * allow us to pass one JSJitInfo per function with the property/function spec,
 * without additional field overhead.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSNativeWrapper {
    pub op: JSNative,
    pub info: *const JSJitInfo,
}
impl ::std::clone::Clone for JSNativeWrapper {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSNativeWrapper() {
    assert_eq!(::std::mem::size_of::<JSNativeWrapper>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSNativeWrapper>() , 8usize);
}
/**
 * Description of a property. JS_DefineProperties and JS_InitClass take arrays
 * of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END
 * are helper macros for defining such arrays.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSPropertySpec {
    pub name: *const ::std::os::raw::c_char,
    pub flags: u8,
    pub getter: JSNativeWrapper,
    pub setter: JSNativeWrapper,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSPropertySpec_SelfHostedWrapper {
    pub unused: *mut ::std::os::raw::c_void,
    pub funname: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSPropertySpec_SelfHostedWrapper {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSPropertySpec_SelfHostedWrapper() {
    assert_eq!(::std::mem::size_of::<JSPropertySpec_SelfHostedWrapper>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<JSPropertySpec_SelfHostedWrapper>() ,
               8usize);
}
impl ::std::clone::Clone for JSPropertySpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSPropertySpec() {
    assert_eq!(::std::mem::size_of::<JSPropertySpec>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSPropertySpec>() , 8usize);
}
/**
 * To define a native function, set call to a JSNativeWrapper. To define a
 * self-hosted function, set selfHostedName to the name of a function
 * compiled during JSRuntime::initSelfHosting.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFunctionSpec {
    pub name: *const ::std::os::raw::c_char,
    pub call: JSNativeWrapper,
    pub nargs: u16,
    pub flags: u16,
    pub selfHostedName: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSFunctionSpec {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFunctionSpec() {
    assert_eq!(::std::mem::size_of::<JSFunctionSpec>() , 40usize);
    assert_eq!(::std::mem::align_of::<JSFunctionSpec>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ZoneSpecifier { FreshZone = 0, SystemZone = 1, }
/**
 * CompartmentCreationOptions specifies options relevant to creating a new
 * compartment, that are either immutable characteristics of that compartment
 * or that are discarded after the compartment has been created.
 *
 * Access to these options on an existing compartment is read-only: if you
 * need particular selections, make them before you create the compartment.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentCreationOptions {
    pub addonId_: *mut JSAddonId,
    pub traceGlobal_: JSTraceOp,
    pub zone_: CompartmentCreationOptions_jsapi_h_unnamed_8,
    pub invisibleToDebugger_: bool,
    pub mergeable_: bool,
    pub preserveJitCode_: bool,
    pub cloneSingletons_: bool,
    pub experimentalDateTimeFormatFormatToPartsEnabled_: bool,
    pub sharedMemoryAndAtomics_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentCreationOptions_jsapi_h_unnamed_8 {
    pub spec: __BindgenUnionField<ZoneSpecifier>,
    pub pointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub _bindgen_data_: u64,
}
impl CompartmentCreationOptions_jsapi_h_unnamed_8 {
    pub unsafe fn spec(&mut self) -> *mut ZoneSpecifier {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pointer(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for CompartmentCreationOptions_jsapi_h_unnamed_8 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentCreationOptions_jsapi_h_unnamed_8() {
    assert_eq!(::std::mem::size_of::<CompartmentCreationOptions_jsapi_h_unnamed_8>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<CompartmentCreationOptions_jsapi_h_unnamed_8>()
               , 8usize);
}
impl ::std::clone::Clone for CompartmentCreationOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentCreationOptions() {
    assert_eq!(::std::mem::size_of::<CompartmentCreationOptions>() , 32usize);
    assert_eq!(::std::mem::align_of::<CompartmentCreationOptions>() , 8usize);
}
extern "C" {
    #[link_name =
          "?addonIdOrNull@CompartmentCreationOptions@JS@@QEBAPEAVJSAddonId@@XZ"]
    fn _addonIdOrNull_CompartmentCreationOptions_JS__QEBAPEAVJSAddonId__XZ_(this:
                                                                                *mut CompartmentCreationOptions)
     -> *mut JSAddonId;
    #[link_name =
          "?setAddonId@CompartmentCreationOptions@JS@@QEAAAEAV12@PEAVJSAddonId@@@Z"]
    fn _setAddonId_CompartmentCreationOptions_JS__QEAAAEAV12_PEAVJSAddonId___Z_(this:
                                                                                    *mut CompartmentCreationOptions,
                                                                                id:
                                                                                    *mut JSAddonId)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?getTrace@CompartmentCreationOptions@JS@@QEBAP6AXPEAVJSTracer@@PEAVJSObject@@@ZXZ"]
    fn _getTrace_CompartmentCreationOptions_JS__QEBAP6AXPEAVJSTracer__PEAVJSObject___ZXZ_(this:
                                                                                              *mut CompartmentCreationOptions)
     -> JSTraceOp;
    #[link_name =
          "?setTrace@CompartmentCreationOptions@JS@@QEAAAEAV12@P6AXPEAVJSTracer@@PEAVJSObject@@@Z@Z"]
    fn _setTrace_CompartmentCreationOptions_JS__QEAAAEAV12_P6AXPEAVJSTracer__PEAVJSObject___Z_Z_(this:
                                                                                                     *mut CompartmentCreationOptions,
                                                                                                 op:
                                                                                                     JSTraceOp)
     -> *mut CompartmentCreationOptions;
    #[link_name = "?zonePointer@CompartmentCreationOptions@JS@@QEBAPEAXXZ"]
    fn _zonePointer_CompartmentCreationOptions_JS__QEBAPEAXXZ_(this:
                                                                   *mut CompartmentCreationOptions)
     -> *mut ::std::os::raw::c_void;
    #[link_name =
          "?zoneSpecifier@CompartmentCreationOptions@JS@@QEBA?AW4ZoneSpecifier@2@XZ"]
    fn _zoneSpecifier_CompartmentCreationOptions_JS__QEBA_AW4ZoneSpecifier_2_XZ_(this:
                                                                                     *mut CompartmentCreationOptions)
     -> ZoneSpecifier;
    #[link_name =
          "?setZone@CompartmentCreationOptions@JS@@QEAAAEAV12@W4ZoneSpecifier@2@@Z"]
    fn _setZone_CompartmentCreationOptions_JS__QEAAAEAV12_W4ZoneSpecifier_2__Z_(this:
                                                                                    *mut CompartmentCreationOptions,
                                                                                spec:
                                                                                    ZoneSpecifier)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?setSameZoneAs@CompartmentCreationOptions@JS@@QEAAAEAV12@PEAVJSObject@@@Z"]
    fn _setSameZoneAs_CompartmentCreationOptions_JS__QEAAAEAV12_PEAVJSObject___Z_(this:
                                                                                      *mut CompartmentCreationOptions,
                                                                                  obj:
                                                                                      *mut JSObject)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?invisibleToDebugger@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _invisibleToDebugger_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                                         *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setInvisibleToDebugger@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setInvisibleToDebugger_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                                   *mut CompartmentCreationOptions,
                                                                               flag:
                                                                                   bool)
     -> *mut CompartmentCreationOptions;
    #[link_name = "?mergeable@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _mergeable_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                               *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setMergeable@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setMergeable_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                         *mut CompartmentCreationOptions,
                                                                     flag:
                                                                         bool)
     -> *mut CompartmentCreationOptions;
    #[link_name = "?preserveJitCode@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _preserveJitCode_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                                     *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setPreserveJitCode@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setPreserveJitCode_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                               *mut CompartmentCreationOptions,
                                                                           flag:
                                                                               bool)
     -> *mut CompartmentCreationOptions;
    #[link_name = "?cloneSingletons@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _cloneSingletons_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                                     *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setCloneSingletons@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setCloneSingletons_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                               *mut CompartmentCreationOptions,
                                                                           flag:
                                                                               bool)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?experimentalDateTimeFormatFormatToPartsEnabled@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _experimentalDateTimeFormatFormatToPartsEnabled_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                                                                    *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setExperimentalDateTimeFormatFormatToPartsEnabled@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setExperimentalDateTimeFormatFormatToPartsEnabled_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                                                              *mut CompartmentCreationOptions,
                                                                                                          flag:
                                                                                                              bool)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?getSharedMemoryAndAtomicsEnabled@CompartmentCreationOptions@JS@@QEBA_NXZ"]
    fn _getSharedMemoryAndAtomicsEnabled_CompartmentCreationOptions_JS__QEBA_NXZ_(this:
                                                                                      *mut CompartmentCreationOptions)
     -> bool;
    #[link_name =
          "?setSharedMemoryAndAtomicsEnabled@CompartmentCreationOptions@JS@@QEAAAEAV12@_N@Z"]
    fn _setSharedMemoryAndAtomicsEnabled_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(this:
                                                                                             *mut CompartmentCreationOptions,
                                                                                         flag:
                                                                                             bool)
     -> *mut CompartmentCreationOptions;
}
impl CompartmentCreationOptions {
    #[inline]
    pub unsafe fn addonIdOrNull(&mut self) -> *mut JSAddonId {
        _addonIdOrNull_CompartmentCreationOptions_JS__QEBAPEAVJSAddonId__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setAddonId(&mut self, id: *mut JSAddonId)
     -> *mut CompartmentCreationOptions {
        _setAddonId_CompartmentCreationOptions_JS__QEAAAEAV12_PEAVJSAddonId___Z_(&mut *self,
                                                                                 id)
    }
    #[inline]
    pub unsafe fn getTrace(&mut self) -> JSTraceOp {
        _getTrace_CompartmentCreationOptions_JS__QEBAP6AXPEAVJSTracer__PEAVJSObject___ZXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setTrace(&mut self, op: JSTraceOp)
     -> *mut CompartmentCreationOptions {
        _setTrace_CompartmentCreationOptions_JS__QEAAAEAV12_P6AXPEAVJSTracer__PEAVJSObject___Z_Z_(&mut *self,
                                                                                                  op)
    }
    #[inline]
    pub unsafe fn zonePointer(&mut self) -> *mut ::std::os::raw::c_void {
        _zonePointer_CompartmentCreationOptions_JS__QEBAPEAXXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn zoneSpecifier(&mut self) -> ZoneSpecifier {
        _zoneSpecifier_CompartmentCreationOptions_JS__QEBA_AW4ZoneSpecifier_2_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setZone(&mut self, spec: ZoneSpecifier)
     -> *mut CompartmentCreationOptions {
        _setZone_CompartmentCreationOptions_JS__QEAAAEAV12_W4ZoneSpecifier_2__Z_(&mut *self,
                                                                                 spec)
    }
    #[inline]
    pub unsafe fn setSameZoneAs(&mut self, obj: *mut JSObject)
     -> *mut CompartmentCreationOptions {
        _setSameZoneAs_CompartmentCreationOptions_JS__QEAAAEAV12_PEAVJSObject___Z_(&mut *self,
                                                                                   obj)
    }
    #[inline]
    pub unsafe fn invisibleToDebugger(&mut self) -> bool {
        _invisibleToDebugger_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setInvisibleToDebugger(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _setInvisibleToDebugger_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                                flag)
    }
    #[inline]
    pub unsafe fn mergeable(&mut self) -> bool {
        _mergeable_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setMergeable(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _setMergeable_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                      flag)
    }
    #[inline]
    pub unsafe fn preserveJitCode(&mut self) -> bool {
        _preserveJitCode_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setPreserveJitCode(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _setPreserveJitCode_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                            flag)
    }
    #[inline]
    pub unsafe fn cloneSingletons(&mut self) -> bool {
        _cloneSingletons_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setCloneSingletons(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _setCloneSingletons_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                            flag)
    }
    #[inline]
    pub unsafe fn experimentalDateTimeFormatFormatToPartsEnabled(&mut self)
     -> bool {
        _experimentalDateTimeFormatFormatToPartsEnabled_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setExperimentalDateTimeFormatFormatToPartsEnabled(&mut self,
                                                                    flag:
                                                                        bool)
     -> *mut CompartmentCreationOptions {
        _setExperimentalDateTimeFormatFormatToPartsEnabled_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                                                           flag)
    }
    #[inline]
    pub unsafe fn getSharedMemoryAndAtomicsEnabled(&mut self) -> bool {
        _getSharedMemoryAndAtomicsEnabled_CompartmentCreationOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setSharedMemoryAndAtomicsEnabled(&mut self, flag: bool)
     -> *mut CompartmentCreationOptions {
        _setSharedMemoryAndAtomicsEnabled_CompartmentCreationOptions_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                                          flag)
    }
}
/**
 * CompartmentBehaviors specifies behaviors of a compartment that can be
 * changed after the compartment's been created.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentBehaviors {
    pub version_: JSVersion,
    pub discardSource_: bool,
    pub disableLazyParsing_: bool,
    pub extraWarningsOverride_: CompartmentBehaviors_Override,
    pub singletonsAsTemplates_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentBehaviors_Override {
    pub mode_: CompartmentBehaviors_Override_Mode,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CompartmentBehaviors_Override_Mode {
    Default = 0,
    ForceTrue = 1,
    ForceFalse = 2,
}
impl ::std::clone::Clone for CompartmentBehaviors_Override {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentBehaviors_Override() {
    assert_eq!(::std::mem::size_of::<CompartmentBehaviors_Override>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<CompartmentBehaviors_Override>() ,
               4usize);
}
extern "C" {
    #[link_name = "?get@Override@CompartmentBehaviors@JS@@QEBA_N_N@Z"]
    fn _get_Override_CompartmentBehaviors_JS__QEBA_N_N_Z_(this:
                                                              *mut CompartmentBehaviors_Override,
                                                          defaultValue: bool)
     -> bool;
    #[link_name = "?set@Override@CompartmentBehaviors@JS@@QEAAX_N@Z"]
    fn _set_Override_CompartmentBehaviors_JS__QEAAX_N_Z_(this:
                                                             *mut CompartmentBehaviors_Override,
                                                         overrideValue: bool);
    #[link_name = "?reset@Override@CompartmentBehaviors@JS@@QEAAXXZ"]
    fn _reset_Override_CompartmentBehaviors_JS__QEAAXXZ_(this:
                                                             *mut CompartmentBehaviors_Override);
}
impl CompartmentBehaviors_Override {
    #[inline]
    pub unsafe fn get(&mut self, defaultValue: bool) -> bool {
        _get_Override_CompartmentBehaviors_JS__QEBA_N_N_Z_(&mut *self,
                                                           defaultValue)
    }
    #[inline]
    pub unsafe fn set(&mut self, overrideValue: bool) {
        _set_Override_CompartmentBehaviors_JS__QEAAX_N_Z_(&mut *self,
                                                          overrideValue)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        _reset_Override_CompartmentBehaviors_JS__QEAAXXZ_(&mut *self)
    }
}
impl ::std::clone::Clone for CompartmentBehaviors {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentBehaviors() {
    assert_eq!(::std::mem::size_of::<CompartmentBehaviors>() , 16usize);
    assert_eq!(::std::mem::align_of::<CompartmentBehaviors>() , 4usize);
}
extern "C" {
    #[link_name = "?version@CompartmentBehaviors@JS@@QEBA?AW4JSVersion@@XZ"]
    fn _version_CompartmentBehaviors_JS__QEBA_AW4JSVersion__XZ_(this:
                                                                    *mut CompartmentBehaviors)
     -> JSVersion;
    #[link_name =
          "?setVersion@CompartmentBehaviors@JS@@QEAAAEAV12@W4JSVersion@@@Z"]
    fn _setVersion_CompartmentBehaviors_JS__QEAAAEAV12_W4JSVersion___Z_(this:
                                                                            *mut CompartmentBehaviors,
                                                                        aVersion:
                                                                            JSVersion)
     -> *mut CompartmentBehaviors;
    #[link_name = "?discardSource@CompartmentBehaviors@JS@@QEBA_NXZ"]
    fn _discardSource_CompartmentBehaviors_JS__QEBA_NXZ_(this:
                                                             *mut CompartmentBehaviors)
     -> bool;
    #[link_name =
          "?setDiscardSource@CompartmentBehaviors@JS@@QEAAAEAV12@_N@Z"]
    fn _setDiscardSource_CompartmentBehaviors_JS__QEAAAEAV12__N_Z_(this:
                                                                       *mut CompartmentBehaviors,
                                                                   flag: bool)
     -> *mut CompartmentBehaviors;
    #[link_name = "?disableLazyParsing@CompartmentBehaviors@JS@@QEBA_NXZ"]
    fn _disableLazyParsing_CompartmentBehaviors_JS__QEBA_NXZ_(this:
                                                                  *mut CompartmentBehaviors)
     -> bool;
    #[link_name =
          "?setDisableLazyParsing@CompartmentBehaviors@JS@@QEAAAEAV12@_N@Z"]
    fn _setDisableLazyParsing_CompartmentBehaviors_JS__QEAAAEAV12__N_Z_(this:
                                                                            *mut CompartmentBehaviors,
                                                                        flag:
                                                                            bool)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "?extraWarnings@CompartmentBehaviors@JS@@QEBA_NPEAUJSRuntime@@@Z"]
    fn _extraWarnings_CompartmentBehaviors_JS__QEBA_NPEAUJSRuntime___Z_(this:
                                                                            *mut CompartmentBehaviors,
                                                                        rt:
                                                                            *mut JSRuntime)
     -> bool;
    #[link_name =
          "?extraWarnings@CompartmentBehaviors@JS@@QEBA_NPEAUJSContext@@@Z"]
    fn _extraWarnings_CompartmentBehaviors_JS__QEBA_NPEAUJSContext___Z_(this:
                                                                            *mut CompartmentBehaviors,
                                                                        cx:
                                                                            *mut JSContext)
     -> bool;
    #[link_name =
          "?extraWarningsOverride@CompartmentBehaviors@JS@@QEAAAEAVOverride@12@XZ"]
    fn _extraWarningsOverride_CompartmentBehaviors_JS__QEAAAEAVOverride_12_XZ_(this:
                                                                                   *mut CompartmentBehaviors)
     -> *mut CompartmentBehaviors_Override;
    #[link_name =
          "?getSingletonsAsTemplates@CompartmentBehaviors@JS@@QEBA_NXZ"]
    fn _getSingletonsAsTemplates_CompartmentBehaviors_JS__QEBA_NXZ_(this:
                                                                        *mut CompartmentBehaviors)
     -> bool;
    #[link_name =
          "?setSingletonsAsValues@CompartmentBehaviors@JS@@QEAAAEAV12@XZ"]
    fn _setSingletonsAsValues_CompartmentBehaviors_JS__QEAAAEAV12_XZ_(this:
                                                                          *mut CompartmentBehaviors)
     -> *mut CompartmentBehaviors;
}
impl CompartmentBehaviors {
    #[inline]
    pub unsafe fn version(&mut self) -> JSVersion {
        _version_CompartmentBehaviors_JS__QEBA_AW4JSVersion__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setVersion(&mut self, aVersion: JSVersion)
     -> *mut CompartmentBehaviors {
        _setVersion_CompartmentBehaviors_JS__QEAAAEAV12_W4JSVersion___Z_(&mut *self,
                                                                         aVersion)
    }
    #[inline]
    pub unsafe fn discardSource(&mut self) -> bool {
        _discardSource_CompartmentBehaviors_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setDiscardSource(&mut self, flag: bool)
     -> *mut CompartmentBehaviors {
        _setDiscardSource_CompartmentBehaviors_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                    flag)
    }
    #[inline]
    pub unsafe fn disableLazyParsing(&mut self) -> bool {
        _disableLazyParsing_CompartmentBehaviors_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setDisableLazyParsing(&mut self, flag: bool)
     -> *mut CompartmentBehaviors {
        _setDisableLazyParsing_CompartmentBehaviors_JS__QEAAAEAV12__N_Z_(&mut *self,
                                                                         flag)
    }
    #[inline]
    pub unsafe fn extraWarnings(&mut self, rt: *mut JSRuntime) -> bool {
        _extraWarnings_CompartmentBehaviors_JS__QEBA_NPEAUJSRuntime___Z_(&mut *self,
                                                                         rt)
    }
    #[inline]
    pub unsafe fn extraWarnings1(&mut self, cx: *mut JSContext) -> bool {
        _extraWarnings_CompartmentBehaviors_JS__QEBA_NPEAUJSContext___Z_(&mut *self,
                                                                         cx)
    }
    #[inline]
    pub unsafe fn extraWarningsOverride(&mut self)
     -> *mut CompartmentBehaviors_Override {
        _extraWarningsOverride_CompartmentBehaviors_JS__QEAAAEAVOverride_12_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn getSingletonsAsTemplates(&mut self) -> bool {
        _getSingletonsAsTemplates_CompartmentBehaviors_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setSingletonsAsValues(&mut self)
     -> *mut CompartmentBehaviors {
        _setSingletonsAsValues_CompartmentBehaviors_JS__QEAAAEAV12_XZ_(&mut *self)
    }
}
/**
 * CompartmentOptions specifies compartment characteristics: both those that
 * can't be changed on a compartment once it's been created
 * (CompartmentCreationOptions), and those that can be changed on an existing
 * compartment (CompartmentBehaviors).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentOptions {
    pub creationOptions_: CompartmentCreationOptions,
    pub behaviors_: CompartmentBehaviors,
}
impl ::std::clone::Clone for CompartmentOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentOptions() {
    assert_eq!(::std::mem::size_of::<CompartmentOptions>() , 48usize);
    assert_eq!(::std::mem::align_of::<CompartmentOptions>() , 8usize);
}
extern "C" {
    #[link_name =
          "?creationOptions@CompartmentOptions@JS@@QEAAAEAVCompartmentCreationOptions@2@XZ"]
    fn _creationOptions_CompartmentOptions_JS__QEAAAEAVCompartmentCreationOptions_2_XZ_(this:
                                                                                            *mut CompartmentOptions)
     -> *mut CompartmentCreationOptions;
    #[link_name =
          "?creationOptions@CompartmentOptions@JS@@QEBAAEBVCompartmentCreationOptions@2@XZ"]
    fn _creationOptions_CompartmentOptions_JS__QEBAAEBVCompartmentCreationOptions_2_XZ_(this:
                                                                                            *mut CompartmentOptions)
     -> *const CompartmentCreationOptions;
    #[link_name =
          "?behaviors@CompartmentOptions@JS@@QEAAAEAVCompartmentBehaviors@2@XZ"]
    fn _behaviors_CompartmentOptions_JS__QEAAAEAVCompartmentBehaviors_2_XZ_(this:
                                                                                *mut CompartmentOptions)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "?behaviors@CompartmentOptions@JS@@QEBAAEBVCompartmentBehaviors@2@XZ"]
    fn _behaviors_CompartmentOptions_JS__QEBAAEBVCompartmentBehaviors_2_XZ_(this:
                                                                                *mut CompartmentOptions)
     -> *const CompartmentBehaviors;
}
impl CompartmentOptions {
    #[inline]
    pub unsafe fn creationOptions(&mut self)
     -> *mut CompartmentCreationOptions {
        _creationOptions_CompartmentOptions_JS__QEAAAEAVCompartmentCreationOptions_2_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn creationOptions1(&mut self)
     -> *const CompartmentCreationOptions {
        _creationOptions_CompartmentOptions_JS__QEBAAEBVCompartmentCreationOptions_2_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn behaviors(&mut self) -> *mut CompartmentBehaviors {
        _behaviors_CompartmentOptions_JS__QEAAAEAVCompartmentBehaviors_2_XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn behaviors1(&mut self) -> *const CompartmentBehaviors {
        _behaviors_CompartmentOptions_JS__QEBAAEBVCompartmentBehaviors_2_XZ_(&mut *self)
    }
}
/**
 * During global creation, we fire notifications to callbacks registered
 * via the Debugger API. These callbacks are arbitrary script, and can touch
 * the global in arbitrary ways. When that happens, the global should not be
 * in a half-baked state. But this creates a problem for consumers that need
 * to set slots on the global to put it in a consistent state.
 *
 * This API provides a way for consumers to set slots atomically (immediately
 * after the global is created), before any debugger hooks are fired. It's
 * unfortunately on the clunky side, but that's the way the cookie crumbles.
 *
 * If callers have no additional state on the global to set up, they may pass
 * |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to
 * fire the hook as its final act before returning. Otherwise, callers should
 * pass |DontFireOnNewGlobalHook|, which means that they are responsible for
 * invoking JS_FireOnNewGlobalObject upon successfully creating the global. If
 * an error occurs and the operation aborts, callers should skip firing the
 * hook. But otherwise, callers must take care to fire the hook exactly once
 * before compiling any script in the global's scope (we have assertions in
 * place to enforce this). This lets us be sure that debugger clients never miss
 * breakpoints.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum OnNewGlobalHookOption {
    FireOnNewGlobalHook = 0,
    DontFireOnNewGlobalHook = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PropertyDescriptor {
    pub obj: *mut JSObject,
    pub attrs: ::std::os::raw::c_uint,
    pub getter: JSGetterOp,
    pub setter: JSSetterOp,
    pub value: Value,
}
impl ::std::clone::Clone for PropertyDescriptor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PropertyDescriptor() {
    assert_eq!(::std::mem::size_of::<PropertyDescriptor>() , 40usize);
    assert_eq!(::std::mem::align_of::<PropertyDescriptor>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyDescriptorOperations<Outer> {
    pub _phantom0: ::std::marker::PhantomData<Outer>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PropertyDescriptorOperations_jsapi_h_unnamed_9 { SHADOWABLE = 0, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutablePropertyDescriptorOperations<Outer> {
    pub _base: PropertyDescriptorOperations<Outer>,
}
#[repr(i8)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AsmJSOption { Enabled = 0, Disabled = 1, DisabledByDebugger = 2, }
/**
 * The common base class for the CompileOptions hierarchy.
 *
 * Use this in code that needs to propagate compile options from one compilation
 * unit to another.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TransitiveCompileOptions {
    pub _vftable: *const _vftable_TransitiveCompileOptions,
    pub mutedErrors_: bool,
    pub filename_: *const ::std::os::raw::c_char,
    pub introducerFilename_: *const ::std::os::raw::c_char,
    pub sourceMapURL_: *const ::std::os::raw::c_ushort,
    pub version: JSVersion,
    pub versionSet: bool,
    pub utf8: bool,
    pub selfHostingMode: bool,
    pub canLazilyParse: bool,
    pub strictOption: bool,
    pub extraWarningsOption: bool,
    pub werrorOption: bool,
    pub asmJSOption: AsmJSOption,
    pub throwOnAsmJSValidationFailureOption: bool,
    pub forceAsync: bool,
    pub installedFile: bool,
    pub sourceIsLazy: bool,
    pub introductionType: *const ::std::os::raw::c_char,
    pub introductionLineno: ::std::os::raw::c_uint,
    pub introductionOffset: u32,
    pub hasIntroductionInfo: bool,
}
#[repr(C)]
pub struct _vftable_TransitiveCompileOptions {
    pub element: unsafe extern "C" fn(this: *mut ::std::os::raw::c_void)
                     -> *mut JSObject,
    pub elementAttributeName: unsafe extern "C" fn(this:
                                                       *mut ::std::os::raw::c_void)
                                  -> *mut JSString,
    pub introductionScript: unsafe extern "C" fn(this:
                                                     *mut ::std::os::raw::c_void)
                                -> *mut JSScript,
}
impl ::std::clone::Clone for TransitiveCompileOptions {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TransitiveCompileOptions() {
    assert_eq!(::std::mem::size_of::<TransitiveCompileOptions>() , 80usize);
    assert_eq!(::std::mem::align_of::<TransitiveCompileOptions>() , 8usize);
}
extern "C" {
    #[link_name =
          "?copyPODTransitiveOptions@TransitiveCompileOptions@JS@@IEAAXAEBV12@@Z"]
    fn _copyPODTransitiveOptions_TransitiveCompileOptions_JS__IEAAXAEBV12__Z_(this:
                                                                                  *mut TransitiveCompileOptions,
                                                                              rhs:
                                                                                  *const TransitiveCompileOptions);
    #[link_name = "?mutedErrors@TransitiveCompileOptions@JS@@QEBA_NXZ"]
    fn _mutedErrors_TransitiveCompileOptions_JS__QEBA_NXZ_(this:
                                                               *mut TransitiveCompileOptions)
     -> bool;
    #[link_name = "?filename@TransitiveCompileOptions@JS@@QEBAPEBDXZ"]
    fn _filename_TransitiveCompileOptions_JS__QEBAPEBDXZ_(this:
                                                              *mut TransitiveCompileOptions)
     -> *const ::std::os::raw::c_char;
    #[link_name =
          "?introducerFilename@TransitiveCompileOptions@JS@@QEBAPEBDXZ"]
    fn _introducerFilename_TransitiveCompileOptions_JS__QEBAPEBDXZ_(this:
                                                                        *mut TransitiveCompileOptions)
     -> *const ::std::os::raw::c_char;
    #[link_name = "?sourceMapURL@TransitiveCompileOptions@JS@@QEBAPEB_SXZ"]
    fn _sourceMapURL_TransitiveCompileOptions_JS__QEBAPEB_SXZ_(this:
                                                                   *mut TransitiveCompileOptions)
     -> *const ::std::os::raw::c_ushort;
}
impl TransitiveCompileOptions {
    #[inline]
    pub unsafe fn copyPODTransitiveOptions(&mut self,
                                           rhs:
                                               *const TransitiveCompileOptions) {
        _copyPODTransitiveOptions_TransitiveCompileOptions_JS__IEAAXAEBV12__Z_(&mut *self,
                                                                               rhs)
    }
    #[inline]
    pub unsafe fn mutedErrors(&mut self) -> bool {
        _mutedErrors_TransitiveCompileOptions_JS__QEBA_NXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn filename(&mut self) -> *const ::std::os::raw::c_char {
        _filename_TransitiveCompileOptions_JS__QEBAPEBDXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn introducerFilename(&mut self)
     -> *const ::std::os::raw::c_char {
        _introducerFilename_TransitiveCompileOptions_JS__QEBAPEBDXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn sourceMapURL(&mut self) -> *const ::std::os::raw::c_ushort {
        _sourceMapURL_TransitiveCompileOptions_JS__QEBAPEB_SXZ_(&mut *self)
    }
}
#[repr(C)]
pub struct ReadOnlyCompileOptions {
    pub _bindgen_opaque_blob: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_ReadOnlyCompileOptions() {
    assert_eq!(::std::mem::size_of::<ReadOnlyCompileOptions>() , 96usize);
    assert_eq!(::std::mem::align_of::<ReadOnlyCompileOptions>() , 8usize);
}
#[repr(C)]
pub struct OwningCompileOptions {
    pub _bindgen_opaque_blob: [u64; 25usize],
}
#[test]
fn bindgen_test_layout_OwningCompileOptions() {
    assert_eq!(::std::mem::size_of::<OwningCompileOptions>() , 200usize);
    assert_eq!(::std::mem::align_of::<OwningCompileOptions>() , 8usize);
}
#[repr(C)]
pub struct CompileOptions {
    pub _bindgen_opaque_blob: [u64; 21usize],
}
#[test]
fn bindgen_test_layout_CompileOptions() {
    assert_eq!(::std::mem::size_of::<CompileOptions>() , 168usize);
    assert_eq!(::std::mem::align_of::<CompileOptions>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum PromiseState { Pending = 0, Fulfilled = 1, Rejected = 2, }
/**
 * This class can be used to store a pointer to the youngest frame of a saved
 * stack in the specified JSContext. This reference will be picked up by any new
 * calls performed until the class is destroyed, with the specified asyncCause,
 * that must not be empty.
 *
 * Any stack capture initiated during these new calls will go through the async
 * stack instead of the current stack.
 *
 * Capturing the stack before a new call is performed will not be affected.
 *
 * The provided chain of SavedFrame objects can live in any compartment,
 * although it will be copied to the compartment where the stack is captured.
 *
 * See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
 * stack frames.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSetAsyncStackForNewCalls {
    pub cx: *mut JSContext,
    pub oldAsyncStack: RootedObject,
    pub oldAsyncCause: RootedString,
    pub oldAsyncCallIsExplicit: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
    IMPLICIT = 0,
    EXPLICIT = 1,
}
#[test]
fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
    assert_eq!(::std::mem::size_of::<AutoSetAsyncStackForNewCalls>() ,
               64usize);
    assert_eq!(::std::mem::align_of::<AutoSetAsyncStackForNewCalls>() ,
               8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct JSAutoByteString {
    pub mBytes: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_JSAutoByteString() {
    assert_eq!(::std::mem::size_of::<JSAutoByteString>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSAutoByteString>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SymbolCode {
    iterator = 0,
    match_ = 1,
    species = 2,
    toPrimitive = 3,
    unscopables = 4,
    Limit = 5,
    InSymbolRegistry = -2,
    UniqueSymbol = -1,
}
/************************************************************************/
pub type JSONWriteCallback =
    ::std::option::Option<unsafe extern "C" fn(buf:
                                                   *const ::std::os::raw::c_ushort,
                                               len: u32,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
/**
 * Locale specific string conversion and error message callbacks.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSLocaleCallbacks {
    pub localeToUpperCase: JSLocaleToUpperCase,
    pub localeToLowerCase: JSLocaleToLowerCase,
    pub localeCompare: JSLocaleCompare,
    pub localeToUnicode: JSLocaleToUnicode,
}
impl ::std::clone::Clone for JSLocaleCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSLocaleCallbacks() {
    assert_eq!(::std::mem::size_of::<JSLocaleCallbacks>() , 32usize);
    assert_eq!(::std::mem::align_of::<JSLocaleCallbacks>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSErrorReport {
    pub linebuf_: *const ::std::os::raw::c_ushort,
    pub linebufLength_: usize,
    pub tokenOffset_: usize,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_uint,
    pub column: ::std::os::raw::c_uint,
    pub isMuted: bool,
    pub flags: ::std::os::raw::c_uint,
    pub errorNumber: ::std::os::raw::c_uint,
    pub ucmessage: *const ::std::os::raw::c_ushort,
    pub messageArgs: *mut *const ::std::os::raw::c_ushort,
    pub exnType: i16,
}
impl ::std::clone::Clone for JSErrorReport {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSErrorReport() {
    assert_eq!(::std::mem::size_of::<JSErrorReport>() , 80usize);
    assert_eq!(::std::mem::align_of::<JSErrorReport>() , 8usize);
}
/**
 * Save and later restore the current exception state of a given JSContext.
 * This is useful for implementing behavior in C++ that's like try/catch
 * or try/finally in JS.
 *
 * Typical usage:
 *
 *     bool ok = JS::Evaluate(cx, ...);
 *     AutoSaveExceptionState savedExc(cx);
 *     ... cleanup that might re-enter JS ...
 *     return ok;
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoSaveExceptionState {
    pub context: *mut JSContext,
    pub wasPropagatingForcedReturn: bool,
    pub wasOverRecursed: bool,
    pub wasThrowing: bool,
    pub exceptionValue: RootedValue,
}
#[test]
fn bindgen_test_layout_AutoSaveExceptionState() {
    assert_eq!(::std::mem::size_of::<AutoSaveExceptionState>() , 40usize);
    assert_eq!(::std::mem::align_of::<AutoSaveExceptionState>() , 8usize);
}
extern "C" {
    #[link_name = "?drop@AutoSaveExceptionState@JS@@QEAAXXZ"]
    fn _drop_AutoSaveExceptionState_JS__QEAAXXZ_(this:
                                                     *mut AutoSaveExceptionState);
    #[link_name = "?restore@AutoSaveExceptionState@JS@@QEAAXXZ"]
    fn _restore_AutoSaveExceptionState_JS__QEAAXXZ_(this:
                                                        *mut AutoSaveExceptionState);
}
impl AutoSaveExceptionState {
    #[inline]
    pub unsafe fn drop(&mut self) {
        _drop_AutoSaveExceptionState_JS__QEAAXXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        _restore_AutoSaveExceptionState_JS__QEAAXXZ_(&mut *self)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitCompilerOption {
    JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 0,
    JSJITCOMPILER_ION_WARMUP_TRIGGER = 1,
    JSJITCOMPILER_ION_GVN_ENABLE = 2,
    JSJITCOMPILER_ION_FORCE_IC = 3,
    JSJITCOMPILER_ION_ENABLE = 4,
    JSJITCOMPILER_BASELINE_ENABLE = 5,
    JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 6,
    JSJITCOMPILER_SIGNALS_ENABLE = 7,
    JSJITCOMPILER_JUMP_THRESHOLD = 8,
    JSJITCOMPILER_NOT_AN_OPTION = 9,
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoFilename {
    pub ss_: *mut ::std::os::raw::c_void,
    pub filename_: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AutoFilename() {
    assert_eq!(::std::mem::size_of::<AutoFilename>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoFilename>() , 8usize);
}
extern "C" {
    #[link_name = "?reset@AutoFilename@JS@@QEAAXXZ"]
    fn _reset_AutoFilename_JS__QEAAXXZ_(this: *mut AutoFilename);
    #[link_name =
          "?setOwned@AutoFilename@JS@@QEAAX$$QEAV?$UniquePtr@$$BY0A@DUFreePolicy@JS@@@mozilla@@@Z"]
    fn _setOwned_AutoFilename_JS__QEAAX__QEAV__UniquePtr___BY0A_DUFreePolicy_JS___mozilla___Z_(this:
                                                                                                   *mut AutoFilename,
                                                                                               filename:
                                                                                                   ::std::os::raw::c_void);
    #[link_name = "?setUnowned@AutoFilename@JS@@QEAAXPEBD@Z"]
    fn _setUnowned_AutoFilename_JS__QEAAXPEBD_Z_(this: *mut AutoFilename,
                                                 filename:
                                                     *const ::std::os::raw::c_char);
    #[link_name = "?setScriptSource@AutoFilename@JS@@QEAAXPEAX@Z"]
    fn _setScriptSource_AutoFilename_JS__QEAAXPEAX_Z_(this: *mut AutoFilename,
                                                      ss:
                                                          *mut ::std::os::raw::c_void);
    #[link_name = "?get@AutoFilename@JS@@QEBAPEBDXZ"]
    fn _get_AutoFilename_JS__QEBAPEBDXZ_(this: *mut AutoFilename)
     -> *const ::std::os::raw::c_char;
}
impl AutoFilename {
    #[inline]
    pub unsafe fn reset(&mut self) {
        _reset_AutoFilename_JS__QEAAXXZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn setOwned(&mut self, filename: ::std::os::raw::c_void) {
        _setOwned_AutoFilename_JS__QEAAX__QEAV__UniquePtr___BY0A_DUFreePolicy_JS___mozilla___Z_(&mut *self,
                                                                                                filename)
    }
    #[inline]
    pub unsafe fn setUnowned(&mut self,
                             filename: *const ::std::os::raw::c_char) {
        _setUnowned_AutoFilename_JS__QEAAXPEBD_Z_(&mut *self, filename)
    }
    #[inline]
    pub unsafe fn setScriptSource(&mut self,
                                  ss: *mut ::std::os::raw::c_void) {
        _setScriptSource_AutoFilename_JS__QEAAXPEAX_Z_(&mut *self, ss)
    }
    #[inline]
    pub unsafe fn get(&mut self) -> *const ::std::os::raw::c_char {
        _get_AutoFilename_JS__QEBAPEBDXZ_(&mut *self)
    }
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoHideScriptedCaller {
    pub mContext: *mut JSContext,
}
#[test]
fn bindgen_test_layout_AutoHideScriptedCaller() {
    assert_eq!(::std::mem::size_of::<AutoHideScriptedCaller>() , 8usize);
    assert_eq!(::std::mem::align_of::<AutoHideScriptedCaller>() , 8usize);
}
pub type OpenAsmJSCacheEntryForReadOp =
    ::std::option::Option<unsafe extern "C" fn(global: HandleObject,
                                               begin:
                                                   *const ::std::os::raw::c_ushort,
                                               limit:
                                                   *const ::std::os::raw::c_ushort,
                                               size: *mut usize,
                                               memory: *mut *const u8,
                                               handle: *mut isize) -> bool>;
pub type CloseAsmJSCacheEntryForReadOp =
    ::std::option::Option<unsafe extern "C" fn(size: usize, memory: *const u8,
                                               handle: isize)>;
pub const AsmJSCache_MIN: AsmJSCacheResult =
    AsmJSCacheResult::AsmJSCache_Success;
/** The list of reasons why an asm.js module may not be stored in the cache. */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AsmJSCacheResult {
    AsmJSCache_Success = 0,
    AsmJSCache_ModuleTooSmall = 1,
    AsmJSCache_SynchronousScript = 2,
    AsmJSCache_QuotaExceeded = 3,
    AsmJSCache_StorageInitFailure = 4,
    AsmJSCache_Disabled_Internal = 5,
    AsmJSCache_Disabled_ShellFlags = 6,
    AsmJSCache_Disabled_JitInspector = 7,
    AsmJSCache_InternalError = 8,
    AsmJSCache_LIMIT = 9,
}
pub type OpenAsmJSCacheEntryForWriteOp =
    ::std::option::Option<unsafe extern "C" fn(global: HandleObject,
                                               installed: bool,
                                               begin:
                                                   *const ::std::os::raw::c_ushort,
                                               end:
                                                   *const ::std::os::raw::c_ushort,
                                               size: usize,
                                               memory: *mut *mut u8,
                                               handle: *mut isize)
                              -> AsmJSCacheResult>;
pub type CloseAsmJSCacheEntryForWriteOp =
    ::std::option::Option<unsafe extern "C" fn(size: usize, memory: *mut u8,
                                               handle: isize)>;
pub type BuildIdCharVector = ::std::os::raw::c_void;
/**
 * Return the buildId (represented as a sequence of characters) associated with
 * the currently-executing build. If the JS engine is embedded such that a
 * single cache entry can be observed by different compiled versions of the JS
 * engine, it is critical that the buildId shall change for each new build of
 * the JS engine.
 */
pub type BuildIdOp =
    ::std::option::Option<unsafe extern "C" fn(buildId:
                                                   *mut BuildIdCharVector)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AsmJSCacheOps {
    pub openEntryForRead: OpenAsmJSCacheEntryForReadOp,
    pub closeEntryForRead: CloseAsmJSCacheEntryForReadOp,
    pub openEntryForWrite: OpenAsmJSCacheEntryForWriteOp,
    pub closeEntryForWrite: CloseAsmJSCacheEntryForWriteOp,
}
impl ::std::clone::Clone for AsmJSCacheOps {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AsmJSCacheOps() {
    assert_eq!(::std::mem::size_of::<AsmJSCacheOps>() , 32usize);
    assert_eq!(::std::mem::align_of::<AsmJSCacheOps>() , 8usize);
}
/**
 * Convenience class for imitating a JS level for-of loop. Typical usage:
 *
 *     ForOfIterator it(cx);
 *     if (!it.init(iterable))
 *       return false;
 *     RootedValue val(cx);
 *     while (true) {
 *       bool done;
 *       if (!it.next(&val, &done))
 *         return false;
 *       if (done)
 *         break;
 *       if (!DoStuff(cx, val))
 *         return false;
 *     }
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct ForOfIterator {
    pub cx_: *mut JSContext,
    pub iterator: RootedObject,
    pub index: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ForOfIterator_NonIterableBehavior {
    ThrowOnNonIterable = 0,
    AllowNonIterable = 1,
}
#[test]
fn bindgen_test_layout_ForOfIterator() {
    assert_eq!(::std::mem::size_of::<ForOfIterator>() , 40usize);
    assert_eq!(::std::mem::align_of::<ForOfIterator>() , 8usize);
}
extern "C" {
    #[link_name =
          "?init@ForOfIterator@JS@@QEAA_NV?$Handle@VValue@JS@@@2@W4NonIterableBehavior@12@@Z"]
    fn _init_ForOfIterator_JS__QEAA_NV__Handle_VValue_JS___2_W4NonIterableBehavior_12__Z_(this:
                                                                                              *mut ForOfIterator,
                                                                                          iterable:
                                                                                              HandleValue,
                                                                                          nonIterableBehavior:
                                                                                              ForOfIterator_NonIterableBehavior)
     -> bool;
    #[link_name =
          "?next@ForOfIterator@JS@@QEAA_NV?$MutableHandle@VValue@JS@@@2@PEA_N@Z"]
    fn _next_ForOfIterator_JS__QEAA_NV__MutableHandle_VValue_JS___2_PEA_N_Z_(this:
                                                                                 *mut ForOfIterator,
                                                                             val:
                                                                                 MutableHandleValue,
                                                                             done:
                                                                                 *mut bool)
     -> bool;
    #[link_name = "?valueIsIterable@ForOfIterator@JS@@QEBA_NXZ"]
    fn _valueIsIterable_ForOfIterator_JS__QEBA_NXZ_(this: *mut ForOfIterator)
     -> bool;
}
impl ForOfIterator {
    /**
     * Initialize the iterator.  If AllowNonIterable is passed then if getting
     * the @@iterator property from iterable returns undefined init() will just
     * return true instead of throwing.  Callers must then check
     * valueIsIterable() before continuing with the iteration.
     */
    #[inline]
    pub unsafe fn init(&mut self, iterable: HandleValue,
                       nonIterableBehavior: ForOfIterator_NonIterableBehavior)
     -> bool {
        _init_ForOfIterator_JS__QEAA_NV__Handle_VValue_JS___2_W4NonIterableBehavior_12__Z_(&mut *self,
                                                                                           iterable,
                                                                                           nonIterableBehavior)
    }
    /**
     * Get the next value from the iterator.  If false *done is true
     * after this call, do not examine val.
     */
    #[inline]
    pub unsafe fn next(&mut self, val: MutableHandleValue, done: *mut bool)
     -> bool {
        _next_ForOfIterator_JS__QEAA_NV__MutableHandle_VValue_JS___2_PEA_N_Z_(&mut *self,
                                                                              val,
                                                                              done)
    }
    /**
     * If initialized with throwOnNonCallable = false, check whether
     * the value is iterable.
     */
    #[inline]
    pub unsafe fn valueIsIterable(&mut self) -> bool {
        _valueIsIterable_ForOfIterator_JS__QEBA_NXZ_(&mut *self)
    }
}
extern "C" {
    #[link_name = "?NOT_ARRAY@ForOfIterator@JS@@1IB"]
    pub static ForOfIterator_consts_NOT_ARRAY: ::std::os::raw::c_uint;
}
/**
 * If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS
 * engine may call the large-allocation- failure callback, if set, to allow the
 * embedding to flush caches, possibly perform shrinking GCs, etc. to make some
 * room. The allocation will then be retried (and may still fail.)
 */
pub type LargeAllocationFailureCallback =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * Unlike the error reporter, which is only called if the exception for an OOM
 * bubbles up and is not caught, the OutOfMemoryCallback is called immediately
 * at the OOM site to allow the embedding to capture the current state of heap
 * allocation before anything is freed. If the large-allocation-failure callback
 * is called at all (not all allocation sites call the large-allocation-failure
 * callback on failure), it is called before the out-of-memory callback; the
 * out-of-memory callback is only called if the allocation still fails after the
 * large-allocation-failure callback has returned.
 */
pub type OutOfMemoryCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SavedFrameResult { Ok = 0, AccessDenied = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum SavedFrameSelfHosted { Include = 0, Exclude = 1, }
pub enum AutoStopwatch { }
/**
 * Abstract base class for a representation of the performance of a
 * component. Embeddings interested in performance monitoring should
 * provide a concrete implementation of this class, as well as the
 * relevant callbacks (see below).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PerformanceGroup {
    pub _vftable: *const _vftable_PerformanceGroup,
    pub recentCycles_: u64,
    pub recentTicks_: u64,
    pub recentCPOW_: u64,
    pub iteration_: u64,
    pub isActive_: bool,
    pub isUsedInThisIteration_: bool,
    pub owner_: *const AutoStopwatch,
    pub refCount_: u64,
}
#[repr(C)]
pub struct _vftable_PerformanceGroup {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for PerformanceGroup {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PerformanceGroup() {
    assert_eq!(::std::mem::size_of::<PerformanceGroup>() , 64usize);
    assert_eq!(::std::mem::align_of::<PerformanceGroup>() , 8usize);
}
pub type StopwatchStartCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: u64,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type jsbytecode = u8;
pub type IsAcceptableThis =
    ::std::option::Option<unsafe extern "C" fn(v: HandleValue) -> bool>;
pub type NativeImpl =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               args: *const CallArgs)
                              -> bool>;
pub enum JSLinearString { }
pub enum BaseProxyHandler { }
pub enum InterpreterFrame { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_10 {
    JS_TELEMETRY_GC_REASON = 0,
    JS_TELEMETRY_GC_IS_COMPARTMENTAL = 1,
    JS_TELEMETRY_GC_MS = 2,
    JS_TELEMETRY_GC_BUDGET_MS = 3,
    JS_TELEMETRY_GC_ANIMATION_MS = 4,
    JS_TELEMETRY_GC_MAX_PAUSE_MS = 5,
    JS_TELEMETRY_GC_MARK_MS = 6,
    JS_TELEMETRY_GC_SWEEP_MS = 7,
    JS_TELEMETRY_GC_COMPACT_MS = 8,
    JS_TELEMETRY_GC_MARK_ROOTS_MS = 9,
    JS_TELEMETRY_GC_MARK_GRAY_MS = 10,
    JS_TELEMETRY_GC_SLICE_MS = 11,
    JS_TELEMETRY_GC_SLOW_PHASE = 12,
    JS_TELEMETRY_GC_MMU_50 = 13,
    JS_TELEMETRY_GC_RESET = 14,
    JS_TELEMETRY_GC_INCREMENTAL_DISABLED = 15,
    JS_TELEMETRY_GC_NON_INCREMENTAL = 16,
    JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS = 17,
    JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS = 18,
    JS_TELEMETRY_GC_MINOR_REASON = 19,
    JS_TELEMETRY_GC_MINOR_REASON_LONG = 20,
    JS_TELEMETRY_GC_MINOR_US = 21,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT = 22,
    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS = 23,
    JS_TELEMETRY_ADDON_EXCEPTIONS = 24,
    JS_TELEMETRY_DEFINE_GETTER_SETTER_THIS_NULL_UNDEFINED = 25,
    JS_TELEMETRY_END = 26,
}
pub type JSAccumulateTelemetryDataCallback =
    ::std::option::Option<unsafe extern "C" fn(id: ::std::os::raw::c_int,
                                               sample: u32,
                                               key:
                                                   *const ::std::os::raw::c_char)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_11 {
    MakeNonConfigurableIntoConfigurable = 0,
    CopyNonConfigurableAsIs = 1,
}
pub type PropertyCopyBehavior = jsfriendapi_h_unnamed_11;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSFunctionSpecWithHelp {
    pub name: *const ::std::os::raw::c_char,
    pub call: JSNative,
    pub nargs: u16,
    pub flags: u16,
    pub jitInfo: *const JSJitInfo,
    pub usage: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for JSFunctionSpecWithHelp {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSFunctionSpecWithHelp() {
    assert_eq!(::std::mem::size_of::<JSFunctionSpecWithHelp>() , 48usize);
    assert_eq!(::std::mem::align_of::<JSFunctionSpecWithHelp>() , 8usize);
}
/**
 * A class of objects that return source code on demand.
 *
 * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
 * retain the source code (and doesn't do lazy bytecode generation). If we ever
 * need the source code, say, in response to a call to Function.prototype.
 * toSource or Debugger.Source.prototype.text, then we call the 'load' member
 * function of the instance of this class that has hopefully been registered
 * with the runtime, passing the code's URL, and hope that it will be able to
 * find the source.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct SourceHook {
    pub _vftable: *const _vftable_SourceHook,
}
#[repr(C)]
pub struct _vftable_SourceHook {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
#[test]
fn bindgen_test_layout_SourceHook() {
    assert_eq!(::std::mem::size_of::<SourceHook>() , 8usize);
    assert_eq!(::std::mem::align_of::<SourceHook>() , 8usize);
}
pub type PreserveWrapperCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: *mut JSObject) -> bool>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum jsfriendapi_h_unnamed_12 {
    CollectNurseryBeforeDump = 0,
    IgnoreNurseryObjects = 1,
}
pub type DumpHeapNurseryBehaviour = jsfriendapi_h_unnamed_12;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WeakMapTracer {
    pub _vftable: *const _vftable_WeakMapTracer,
    pub runtime: *mut JSRuntime,
}
#[repr(C)]
pub struct _vftable_WeakMapTracer {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for WeakMapTracer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_WeakMapTracer() {
    assert_eq!(::std::mem::size_of::<WeakMapTracer>() , 16usize);
    assert_eq!(::std::mem::align_of::<WeakMapTracer>() , 8usize);
}
pub type GCThingCallback =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               thing: GCCellPtr)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectGroup {
    pub clasp: *const Class,
    pub proto: *mut JSObject,
    pub compartment: *mut JSCompartment,
}
impl ::std::clone::Clone for ObjectGroup {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectGroup() {
    assert_eq!(::std::mem::size_of::<ObjectGroup>() , 24usize);
    assert_eq!(::std::mem::align_of::<ObjectGroup>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BaseShape {
    pub clasp_: *const Class,
    pub parent: *mut JSObject,
}
impl ::std::clone::Clone for BaseShape {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_BaseShape() {
    assert_eq!(::std::mem::size_of::<BaseShape>() , 16usize);
    assert_eq!(::std::mem::align_of::<BaseShape>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Shape {
    pub base: *mut BaseShape,
    pub _1: jsid,
    pub slotInfo: u32,
}
impl ::std::clone::Clone for Shape {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Shape() {
    assert_eq!(::std::mem::size_of::<Shape>() , 24usize);
    assert_eq!(::std::mem::align_of::<Shape>() , 8usize);
}
/**
 * This layout is shared by all native objects. For non-native objects, the
 * group may always be accessed safely, and other members may be as well,
 * depending on the object's specific layout.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Object {
    pub group: *mut ObjectGroup,
    pub shape: *mut Shape,
    pub slots: *mut Value,
    pub _1: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Object {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Object() {
    assert_eq!(::std::mem::size_of::<Object>() , 32usize);
    assert_eq!(::std::mem::align_of::<Object>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Function {
    pub base: Object,
    pub nargs: u16,
    pub flags: u16,
    pub native: JSNative,
    pub jitinfo: *const JSJitInfo,
    pub _1: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Function {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Function() {
    assert_eq!(::std::mem::size_of::<Function>() , 64usize);
    assert_eq!(::std::mem::align_of::<Function>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct String {
    pub flags: u32,
    pub length: u32,
    pub String_jsfriendapi_h_unnamed_13: String_jsfriendapi_h_unnamed_13,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct String_jsfriendapi_h_unnamed_13 {
    pub nonInlineCharsLatin1: __BindgenUnionField<*const Latin1Char>,
    pub nonInlineCharsTwoByte: __BindgenUnionField<*const ::std::os::raw::c_ushort>,
    pub inlineStorageLatin1: __BindgenUnionField<[Latin1Char; 1usize]>,
    pub inlineStorageTwoByte: __BindgenUnionField<[::std::os::raw::c_ushort; 1usize]>,
    pub _bindgen_data_: u64,
}
impl String_jsfriendapi_h_unnamed_13 {
    pub unsafe fn nonInlineCharsLatin1(&mut self) -> *mut *const Latin1Char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn nonInlineCharsTwoByte(&mut self)
     -> *mut *const ::std::os::raw::c_ushort {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inlineStorageLatin1(&mut self)
     -> *mut [Latin1Char; 1usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn inlineStorageTwoByte(&mut self)
     -> *mut [::std::os::raw::c_ushort; 1usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for String_jsfriendapi_h_unnamed_13 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_String_jsfriendapi_h_unnamed_13() {
    assert_eq!(::std::mem::size_of::<String_jsfriendapi_h_unnamed_13>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<String_jsfriendapi_h_unnamed_13>() ,
               8usize);
}
impl ::std::clone::Clone for String {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_String() {
    assert_eq!(::std::mem::size_of::<String>() , 16usize);
    assert_eq!(::std::mem::align_of::<String>() , 8usize);
}
pub type ActivityCallback =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               active: bool)>;
pub type DOMInstanceClassHasProtoAtDepth =
    ::std::option::Option<unsafe extern "C" fn(instanceClass: *const Class,
                                               protoID: u32, depth: u32)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSDOMCallbacks {
    pub instanceClassMatchesProto: DOMInstanceClassHasProtoAtDepth,
}
impl ::std::clone::Clone for JSDOMCallbacks {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSDOMCallbacks() {
    assert_eq!(::std::mem::size_of::<JSDOMCallbacks>() , 8usize);
    assert_eq!(::std::mem::align_of::<JSDOMCallbacks>() , 8usize);
}
pub type DOMCallbacks = JSDOMCallbacks;
pub enum RegExpGuard { }
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum NukeReferencesToWindow {
    NukeWindowReferences = 0,
    DontNukeWindowReferences = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentFilter {
    pub _vftable: *const _vftable_CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_CompartmentFilter {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for CompartmentFilter {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentFilter() {
    assert_eq!(::std::mem::size_of::<CompartmentFilter>() , 8usize);
    assert_eq!(::std::mem::align_of::<CompartmentFilter>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AllCompartments {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_AllCompartments {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for AllCompartments {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ContentCompartmentsOnly {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_ContentCompartmentsOnly {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for ContentCompartmentsOnly {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ChromeCompartmentsOnly {
    pub _base: CompartmentFilter,
}
#[repr(C)]
pub struct _vftable_ChromeCompartmentsOnly {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for ChromeCompartmentsOnly {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SingleCompartment {
    pub _base: CompartmentFilter,
    pub ours: *mut JSCompartment,
}
#[repr(C)]
pub struct _vftable_SingleCompartment {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for SingleCompartment {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SingleCompartment() {
    assert_eq!(::std::mem::size_of::<SingleCompartment>() , 16usize);
    assert_eq!(::std::mem::align_of::<SingleCompartment>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompartmentsWithPrincipals {
    pub _base: CompartmentFilter,
    pub principals: *mut JSPrincipals,
}
#[repr(C)]
pub struct _vftable_CompartmentsWithPrincipals {
    pub _base: _vftable_CompartmentFilter,
}
impl ::std::clone::Clone for CompartmentsWithPrincipals {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CompartmentsWithPrincipals() {
    assert_eq!(::std::mem::size_of::<CompartmentsWithPrincipals>() , 16usize);
    assert_eq!(::std::mem::align_of::<CompartmentsWithPrincipals>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ExpandoAndGeneration {
    pub expando: Heap<Value>,
    pub generation: u64,
}
#[test]
fn bindgen_test_layout_ExpandoAndGeneration() {
    assert_eq!(::std::mem::size_of::<ExpandoAndGeneration>() , 16usize);
    assert_eq!(::std::mem::align_of::<ExpandoAndGeneration>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum DOMProxyShadowsResult {
    ShadowCheckFailed = 0,
    Shadows = 1,
    DoesntShadow = 2,
    DoesntShadowUnique = 3,
    ShadowsViaDirectExpando = 4,
    ShadowsViaIndirectExpando = 5,
}
pub type DOMProxyShadowsCheck =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               object: HandleObject,
                                               id: HandleId)
                              -> DOMProxyShadowsResult>;
/**
 * Report an exception, which is currently realized as a printf-style format
 * string and its arguments.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSErrNum {
    JSMSG_NOT_AN_ERROR = 0,
    JSMSG_NOT_DEFINED = 1,
    JSMSG_MORE_ARGS_NEEDED = 2,
    JSMSG_INCOMPATIBLE_PROTO = 3,
    JSMSG_NO_CONSTRUCTOR = 4,
    JSMSG_BAD_SORT_ARG = 5,
    JSMSG_CANT_WATCH = 6,
    JSMSG_READ_ONLY = 7,
    JSMSG_CANT_DELETE = 8,
    JSMSG_CANT_TRUNCATE_ARRAY = 9,
    JSMSG_NOT_FUNCTION = 10,
    JSMSG_NOT_CONSTRUCTOR = 11,
    JSMSG_CANT_CONVERT_TO = 12,
    JSMSG_TOPRIMITIVE_NOT_CALLABLE = 13,
    JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 14,
    JSMSG_NO_PROPERTIES = 15,
    JSMSG_BAD_REGEXP_FLAG = 16,
    JSMSG_ARG_INDEX_OUT_OF_RANGE = 17,
    JSMSG_SPREAD_TOO_LARGE = 18,
    JSMSG_BAD_WEAKMAP_KEY = 19,
    JSMSG_BAD_GETTER_OR_SETTER = 20,
    JSMSG_BAD_ARRAY_LENGTH = 21,
    JSMSG_REDECLARED_VAR = 22,
    JSMSG_UNDECLARED_VAR = 23,
    JSMSG_GETTER_ONLY = 24,
    JSMSG_OVERWRITING_ACCESSOR = 25,
    JSMSG_UNDEFINED_PROP = 26,
    JSMSG_INVALID_MAP_ITERABLE = 27,
    JSMSG_NESTING_GENERATOR = 28,
    JSMSG_INCOMPATIBLE_METHOD = 29,
    JSMSG_OBJECT_WATCH_DEPRECATED = 30,
    JSMSG_BAD_SURROGATE_CHAR = 31,
    JSMSG_UTF8_CHAR_TOO_LARGE = 32,
    JSMSG_MALFORMED_UTF8_CHAR = 33,
    JSMSG_BUILTIN_CTOR_NO_NEW = 34,
    JSMSG_BAD_GENERATOR_YIELD = 35,
    JSMSG_EMPTY_ARRAY_REDUCE = 36,
    JSMSG_UNEXPECTED_TYPE = 37,
    JSMSG_MISSING_FUN_ARG = 38,
    JSMSG_NOT_NONNULL_OBJECT = 39,
    JSMSG_SET_NON_OBJECT_RECEIVER = 40,
    JSMSG_INVALID_DESCRIPTOR = 41,
    JSMSG_OBJECT_NOT_EXTENSIBLE = 42,
    JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 43,
    JSMSG_CANT_REDEFINE_PROP = 44,
    JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 45,
    JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 46,
    JSMSG_BAD_GET_SET_FIELD = 47,
    JSMSG_THROW_TYPE_ERROR = 48,
    JSMSG_NOT_EXPECTED_TYPE = 49,
    JSMSG_NOT_ITERABLE = 50,
    JSMSG_ALREADY_HAS_PRAGMA = 51,
    JSMSG_NEXT_RETURNED_PRIMITIVE = 52,
    JSMSG_CANT_SET_PROTO = 53,
    JSMSG_CANT_SET_PROTO_OF = 54,
    JSMSG_CANT_SET_PROTO_CYCLE = 55,
    JSMSG_INVALID_ARG_TYPE = 56,
    JSMSG_TERMINATED = 57,
    JSMSG_PROTO_NOT_OBJORNULL = 58,
    JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 59,
    JSMSG_UNINITIALIZED_THIS = 60,
    JSMSG_UNINITIALIZED_THIS_ARROW = 61,
    JSMSG_BAD_DERIVED_RETURN = 62,
    JSMSG_JSON_BAD_PARSE = 63,
    JSMSG_JSON_CYCLIC_VALUE = 64,
    JSMSG_BAD_INSTANCEOF_RHS = 65,
    JSMSG_BAD_LEFTSIDE_OF_ASS = 66,
    JSMSG_BAD_PROTOTYPE = 67,
    JSMSG_IN_NOT_OBJECT = 68,
    JSMSG_TOO_MANY_CON_SPREADARGS = 69,
    JSMSG_TOO_MANY_FUN_SPREADARGS = 70,
    JSMSG_UNINITIALIZED_LEXICAL = 71,
    JSMSG_BAD_CONST_ASSIGN = 72,
    JSMSG_INVALID_DATE = 73,
    JSMSG_BAD_TOISOSTRING_PROP = 74,
    JSMSG_BAD_URI = 75,
    JSMSG_INVALID_NORMALIZE_FORM = 76,
    JSMSG_NEGATIVE_REPETITION_COUNT = 77,
    JSMSG_NOT_A_CODEPOINT = 78,
    JSMSG_RESULTING_STRING_TOO_LARGE = 79,
    JSMSG_DEPRECATED_STRING_CONTAINS = 80,
    JSMSG_BAD_RADIX = 81,
    JSMSG_PRECISION_RANGE = 82,
    JSMSG_BAD_APPLY_ARGS = 83,
    JSMSG_BAD_FORMAL = 84,
    JSMSG_CALLER_IS_STRICT = 85,
    JSMSG_DEPRECATED_USAGE = 86,
    JSMSG_NOT_SCRIPTED_FUNCTION = 87,
    JSMSG_NO_REST_NAME = 88,
    JSMSG_PARAMETER_AFTER_REST = 89,
    JSMSG_TOO_MANY_FUN_APPLY_ARGS = 90,
    JSMSG_CSP_BLOCKED_EVAL = 91,
    JSMSG_CSP_BLOCKED_FUNCTION = 92,
    JSMSG_ACCESSOR_DEF_DENIED = 93,
    JSMSG_DEAD_OBJECT = 94,
    JSMSG_UNWRAP_DENIED = 95,
    JSMSG_BAD_CLONE_FUNOBJ_SCOPE = 96,
    JSMSG_CANT_CLONE_OBJECT = 97,
    JSMSG_CANT_OPEN = 98,
    JSMSG_USER_DEFINED_ERROR = 99,
    JSMSG_ALLOC_OVERFLOW = 100,
    JSMSG_BAD_BUILD_ID = 101,
    JSMSG_BAD_BYTECODE = 102,
    JSMSG_BUFFER_TOO_SMALL = 103,
    JSMSG_BUILD_ID_NOT_AVAILABLE = 104,
    JSMSG_BYTECODE_TOO_BIG = 105,
    JSMSG_NEED_DIET = 106,
    JSMSG_OUT_OF_MEMORY = 107,
    JSMSG_OVER_RECURSED = 108,
    JSMSG_TOO_BIG_TO_ENCODE = 109,
    JSMSG_TOO_DEEP = 110,
    JSMSG_UNCAUGHT_EXCEPTION = 111,
    JSMSG_UNKNOWN_FORMAT = 112,
    JSMSG_ACCESSOR_WRONG_ARGS = 113,
    JSMSG_ARRAY_COMP_LEFTSIDE = 114,
    JSMSG_ARRAY_INIT_TOO_BIG = 115,
    JSMSG_AS_AFTER_IMPORT_STAR = 116,
    JSMSG_AS_AFTER_RESERVED_WORD = 117,
    JSMSG_BAD_ANON_GENERATOR_RETURN = 118,
    JSMSG_BAD_ARROW_ARGS = 119,
    JSMSG_BAD_BINDING = 120,
    JSMSG_BAD_CONST_DECL = 121,
    JSMSG_BAD_CONTINUE = 122,
    JSMSG_BAD_DESTRUCT_ASS = 123,
    JSMSG_BAD_DESTRUCT_TARGET = 124,
    JSMSG_BAD_DESTRUCT_PARENS = 125,
    JSMSG_BAD_DESTRUCT_DECL = 126,
    JSMSG_BAD_DUP_ARGS = 127,
    JSMSG_BAD_FOR_EACH_LOOP = 128,
    JSMSG_BAD_FOR_LEFTSIDE = 129,
    JSMSG_LEXICAL_DECL_DEFINES_LET = 130,
    JSMSG_LET_STARTING_FOROF_LHS = 131,
    JSMSG_BAD_GENERATOR_RETURN = 132,
    JSMSG_BAD_GENEXP_BODY = 133,
    JSMSG_BAD_INCOP_OPERAND = 134,
    JSMSG_BAD_METHOD_DEF = 135,
    JSMSG_BAD_OCTAL = 136,
    JSMSG_BAD_OPERAND = 137,
    JSMSG_BAD_PROP_ID = 138,
    JSMSG_BAD_RETURN_OR_YIELD = 139,
    JSMSG_BAD_STRICT_ASSIGN = 140,
    JSMSG_BAD_SWITCH = 141,
    JSMSG_BAD_SUPER = 142,
    JSMSG_BAD_SUPERPROP = 143,
    JSMSG_BAD_SUPERCALL = 144,
    JSMSG_BRACKET_AFTER_ARRAY_COMPREHENSION = 145,
    JSMSG_BRACKET_AFTER_LIST = 146,
    JSMSG_BRACKET_IN_INDEX = 147,
    JSMSG_CATCH_AFTER_GENERAL = 148,
    JSMSG_CATCH_IDENTIFIER = 149,
    JSMSG_CATCH_OR_FINALLY = 150,
    JSMSG_CATCH_WITHOUT_TRY = 151,
    JSMSG_COLON_AFTER_CASE = 152,
    JSMSG_COLON_AFTER_ID = 153,
    JSMSG_COLON_IN_COND = 154,
    JSMSG_COMP_PROP_UNTERM_EXPR = 155,
    JSMSG_CONTRARY_NONDIRECTIVE = 156,
    JSMSG_CURLY_AFTER_BODY = 157,
    JSMSG_CURLY_AFTER_CATCH = 158,
    JSMSG_CURLY_AFTER_FINALLY = 159,
    JSMSG_CURLY_AFTER_LIST = 160,
    JSMSG_CURLY_AFTER_TRY = 161,
    JSMSG_CURLY_BEFORE_BODY = 162,
    JSMSG_CURLY_BEFORE_CATCH = 163,
    JSMSG_CURLY_BEFORE_CLASS = 164,
    JSMSG_CURLY_BEFORE_FINALLY = 165,
    JSMSG_CURLY_BEFORE_SWITCH = 166,
    JSMSG_CURLY_BEFORE_TRY = 167,
    JSMSG_CURLY_IN_COMPOUND = 168,
    JSMSG_DECLARATION_AFTER_EXPORT = 169,
    JSMSG_DECLARATION_AFTER_IMPORT = 170,
    JSMSG_DEPRECATED_DELETE_OPERAND = 171,
    JSMSG_DEPRECATED_EXPR_CLOSURE = 172,
    JSMSG_DEPRECATED_FLAGS_ARG = 173,
    JSMSG_DEPRECATED_FOR_EACH = 174,
    JSMSG_DEPRECATED_OCTAL = 175,
    JSMSG_DEPRECATED_PRAGMA = 176,
    JSMSG_DEPRECATED_BLOCK_SCOPE_FUN_REDECL = 177,
    JSMSG_DUPLICATE_EXPORT_NAME = 178,
    JSMSG_DUPLICATE_FORMAL = 179,
    JSMSG_DUPLICATE_LABEL = 180,
    JSMSG_DUPLICATE_PROPERTY = 181,
    JSMSG_EMPTY_CONSEQUENT = 182,
    JSMSG_EQUAL_AS_ASSIGN = 183,
    JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 184,
    JSMSG_FINALLY_WITHOUT_TRY = 185,
    JSMSG_FROM_AFTER_IMPORT_CLAUSE = 186,
    JSMSG_FROM_AFTER_EXPORT_STAR = 187,
    JSMSG_GARBAGE_AFTER_INPUT = 188,
    JSMSG_IDSTART_AFTER_NUMBER = 189,
    JSMSG_ILLEGAL_CHARACTER = 190,
    JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 191,
    JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 192,
    JSMSG_LABEL_NOT_FOUND = 193,
    JSMSG_LET_CLASS_BINDING = 194,
    JSMSG_LET_COMP_BINDING = 195,
    JSMSG_LEXICAL_DECL_NOT_IN_BLOCK = 196,
    JSMSG_LEXICAL_DECL_LABEL = 197,
    JSMSG_FUNCTION_LABEL = 198,
    JSMSG_SLOPPY_FUNCTION_LABEL = 199,
    JSMSG_LINE_BREAK_AFTER_THROW = 200,
    JSMSG_MALFORMED_ESCAPE = 201,
    JSMSG_MISSING_BINARY_DIGITS = 202,
    JSMSG_MISSING_EXPONENT = 203,
    JSMSG_MISSING_EXPR_AFTER_THROW = 204,
    JSMSG_MISSING_FORMAL = 205,
    JSMSG_MISSING_HEXDIGITS = 206,
    JSMSG_MISSING_OCTAL_DIGITS = 207,
    JSMSG_MODULE_SPEC_AFTER_FROM = 208,
    JSMSG_NAME_AFTER_DOT = 209,
    JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 210,
    JSMSG_NO_BINDING_NAME = 211,
    JSMSG_NO_EXPORT_NAME = 212,
    JSMSG_NO_IMPORT_NAME = 213,
    JSMSG_NO_VARIABLE_NAME = 214,
    JSMSG_OBSOLETE_FLAGS_ARG = 215,
    JSMSG_OF_AFTER_FOR_NAME = 216,
    JSMSG_PAREN_AFTER_ARGS = 217,
    JSMSG_PAREN_AFTER_CATCH = 218,
    JSMSG_PAREN_AFTER_COND = 219,
    JSMSG_PAREN_AFTER_FOR = 220,
    JSMSG_PAREN_AFTER_FORMAL = 221,
    JSMSG_PAREN_AFTER_FOR_CTRL = 222,
    JSMSG_PAREN_AFTER_FOR_OF_ITERABLE = 223,
    JSMSG_PAREN_AFTER_SWITCH = 224,
    JSMSG_PAREN_AFTER_WITH = 225,
    JSMSG_PAREN_BEFORE_CATCH = 226,
    JSMSG_PAREN_BEFORE_COND = 227,
    JSMSG_PAREN_BEFORE_FORMAL = 228,
    JSMSG_PAREN_BEFORE_SWITCH = 229,
    JSMSG_PAREN_BEFORE_WITH = 230,
    JSMSG_PAREN_IN_PAREN = 231,
    JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 232,
    JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 233,
    JSMSG_REDECLARED_CATCH_IDENTIFIER = 234,
    JSMSG_REDECLARED_PARAM = 235,
    JSMSG_RESERVED_ID = 236,
    JSMSG_REST_WITH_DEFAULT = 237,
    JSMSG_SELFHOSTED_TOP_LEVEL_LEXICAL = 238,
    JSMSG_SELFHOSTED_UNBOUND_NAME = 239,
    JSMSG_SEMI_AFTER_FOR_COND = 240,
    JSMSG_SEMI_AFTER_FOR_INIT = 241,
    JSMSG_SEMI_BEFORE_STMNT = 242,
    JSMSG_SOURCE_TOO_LONG = 243,
    JSMSG_STMT_AFTER_RETURN = 244,
    JSMSG_STRICT_CODE_WITH = 245,
    JSMSG_TEMPLSTR_UNTERM_EXPR = 246,
    JSMSG_SIMD_NOT_A_VECTOR = 247,
    JSMSG_TOO_MANY_CASES = 248,
    JSMSG_TOO_MANY_CATCH_VARS = 249,
    JSMSG_TOO_MANY_CON_ARGS = 250,
    JSMSG_TOO_MANY_DEFAULTS = 251,
    JSMSG_TOO_MANY_FUN_ARGS = 252,
    JSMSG_TOO_MANY_LOCALS = 253,
    JSMSG_TOO_MANY_YIELDS = 254,
    JSMSG_TOUGH_BREAK = 255,
    JSMSG_UNEXPECTED_TOKEN = 256,
    JSMSG_UNNAMED_CLASS_STMT = 257,
    JSMSG_UNNAMED_FUNCTION_STMT = 258,
    JSMSG_UNTERMINATED_COMMENT = 259,
    JSMSG_UNTERMINATED_REGEXP = 260,
    JSMSG_UNTERMINATED_STRING = 261,
    JSMSG_USELESS_EXPR = 262,
    JSMSG_USE_ASM_DIRECTIVE_FAIL = 263,
    JSMSG_VAR_HIDES_ARG = 264,
    JSMSG_WHILE_AFTER_DO = 265,
    JSMSG_YIELD_IN_ARROW = 266,
    JSMSG_YIELD_IN_DEFAULT = 267,
    JSMSG_BAD_COLUMN_NUMBER = 268,
    JSMSG_COMPUTED_NAME_IN_PATTERN = 269,
    JSMSG_DEFAULT_IN_PATTERN = 270,
    JSMSG_BAD_NEWTARGET = 271,
    JSMSG_ESCAPED_KEYWORD = 272,
    JSMSG_USE_ASM_TYPE_FAIL = 273,
    JSMSG_USE_ASM_LINK_FAIL = 274,
    JSMSG_USE_ASM_TYPE_OK = 275,
    JSMSG_WASM_FAIL = 276,
    JSMSG_WASM_DECODE_FAIL = 277,
    JSMSG_WASM_TEXT_FAIL = 278,
    JSMSG_WASM_BAD_IND_CALL = 279,
    JSMSG_WASM_BAD_BUF_ARG = 280,
    JSMSG_WASM_BAD_IMPORT_ARG = 281,
    JSMSG_WASM_UNREACHABLE = 282,
    JSMSG_BAD_TRAP_RETURN_VALUE = 283,
    JSMSG_CANT_CHANGE_EXTENSIBILITY = 284,
    JSMSG_CANT_DEFINE_INVALID = 285,
    JSMSG_CANT_DEFINE_NEW = 286,
    JSMSG_CANT_DEFINE_NE_AS_NC = 287,
    JSMSG_PROXY_DEFINE_RETURNED_FALSE = 288,
    JSMSG_PROXY_DELETE_RETURNED_FALSE = 289,
    JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 290,
    JSMSG_PROXY_SET_RETURNED_FALSE = 291,
    JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 292,
    JSMSG_CANT_REPORT_C_AS_NC = 293,
    JSMSG_CANT_REPORT_E_AS_NE = 294,
    JSMSG_CANT_REPORT_INVALID = 295,
    JSMSG_CANT_REPORT_NC_AS_NE = 296,
    JSMSG_CANT_REPORT_NEW = 297,
    JSMSG_CANT_REPORT_NE_AS_NC = 298,
    JSMSG_CANT_SET_NW_NC = 299,
    JSMSG_CANT_SET_WO_SETTER = 300,
    JSMSG_CANT_SKIP_NC = 301,
    JSMSG_ONWKEYS_STR_SYM = 302,
    JSMSG_MUST_REPORT_SAME_VALUE = 303,
    JSMSG_MUST_REPORT_UNDEFINED = 304,
    JSMSG_OBJECT_ACCESS_DENIED = 305,
    JSMSG_PROPERTY_ACCESS_DENIED = 306,
    JSMSG_PROXY_CONSTRUCT_OBJECT = 307,
    JSMSG_PROXY_EXTENSIBILITY = 308,
    JSMSG_PROXY_GETOWN_OBJORUNDEF = 309,
    JSMSG_PROXY_REVOKED = 310,
    JSMSG_PROXY_ARG_REVOKED = 311,
    JSMSG_BAD_TRAP = 312,
    JSMSG_SC_BAD_CLONE_VERSION = 313,
    JSMSG_SC_BAD_SERIALIZED_DATA = 314,
    JSMSG_SC_DUP_TRANSFERABLE = 315,
    JSMSG_SC_NOT_TRANSFERABLE = 316,
    JSMSG_SC_UNSUPPORTED_TYPE = 317,
    JSMSG_SC_SHMEM_MUST_TRANSFER = 318,
    JSMSG_ASSIGN_FUNCTION_OR_NULL = 319,
    JSMSG_DEBUG_BAD_LINE = 320,
    JSMSG_DEBUG_BAD_OFFSET = 321,
    JSMSG_DEBUG_BAD_REFERENT = 322,
    JSMSG_DEBUG_BAD_RESUMPTION = 323,
    JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 324,
    JSMSG_DEBUG_CCW_REQUIRED = 325,
    JSMSG_DEBUG_COMPARTMENT_MISMATCH = 326,
    JSMSG_DEBUG_LOOP = 327,
    JSMSG_DEBUG_NOT_DEBUGGEE = 328,
    JSMSG_DEBUG_NOT_DEBUGGING = 329,
    JSMSG_DEBUG_NOT_IDLE = 330,
    JSMSG_DEBUG_NOT_LIVE = 331,
    JSMSG_DEBUG_NO_SCOPE_OBJECT = 332,
    JSMSG_DEBUG_OBJECT_PROTO = 333,
    JSMSG_DEBUG_OBJECT_WRONG_OWNER = 334,
    JSMSG_DEBUG_OPTIMIZED_OUT = 335,
    JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 336,
    JSMSG_DEBUG_VARIABLE_NOT_FOUND = 337,
    JSMSG_DEBUG_WRAPPER_IN_WAY = 338,
    JSMSG_DEBUGGEE_WOULD_RUN = 339,
    JSMSG_NOT_CALLABLE_OR_UNDEFINED = 340,
    JSMSG_NOT_TRACKING_ALLOCATIONS = 341,
    JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 342,
    JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 343,
    JSMSG_QUERY_LINE_WITHOUT_URL = 344,
    JSMSG_DEBUG_CANT_SET_OPT_ENV = 345,
    JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 346,
    JSMSG_DEBUG_CENSUS_BREAKDOWN = 347,
    JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 348,
    JSMSG_TRACELOGGER_ENABLE_FAIL = 349,
    JSMSG_DATE_NOT_FINITE = 350,
    JSMSG_INTERNAL_INTL_ERROR = 351,
    JSMSG_INTL_OBJECT_NOT_INITED = 352,
    JSMSG_INTL_OBJECT_REINITED = 353,
    JSMSG_INVALID_CURRENCY_CODE = 354,
    JSMSG_INVALID_DIGITS_VALUE = 355,
    JSMSG_INVALID_LANGUAGE_TAG = 356,
    JSMSG_INVALID_LOCALES_ELEMENT = 357,
    JSMSG_INVALID_LOCALE_MATCHER = 358,
    JSMSG_INVALID_OPTION_VALUE = 359,
    JSMSG_INVALID_TIME_ZONE = 360,
    JSMSG_UNDEFINED_CURRENCY = 361,
    JSMSG_BACK_REF_OUT_OF_RANGE = 362,
    JSMSG_BAD_CLASS_RANGE = 363,
    JSMSG_ESCAPE_AT_END_OF_REGEXP = 364,
    JSMSG_INVALID_DECIMAL_ESCAPE = 365,
    JSMSG_INVALID_GROUP = 366,
    JSMSG_INVALID_IDENTITY_ESCAPE = 367,
    JSMSG_INVALID_UNICODE_ESCAPE = 368,
    JSMSG_MISSING_PAREN = 369,
    JSMSG_NEWREGEXP_FLAGGED = 370,
    JSMSG_NOTHING_TO_REPEAT = 371,
    JSMSG_NUMBERS_OUT_OF_ORDER = 372,
    JSMSG_RANGE_WITH_CLASS_ESCAPE = 373,
    JSMSG_RAW_BRACE_IN_REGEP = 374,
    JSMSG_RAW_BRACKET_IN_REGEP = 375,
    JSMSG_TOO_MANY_PARENS = 376,
    JSMSG_UNICODE_OVERFLOW = 377,
    JSMSG_UNMATCHED_RIGHT_PAREN = 378,
    JSMSG_UNTERM_CLASS = 379,
    JSMSG_DEFAULT_LOCALE_ERROR = 380,
    JSMSG_NO_SUCH_SELF_HOSTED_PROP = 381,
    JSMSG_INVALID_PROTOTYPE = 382,
    JSMSG_TYPEDOBJECT_BAD_ARGS = 383,
    JSMSG_TYPEDOBJECT_BINARYARRAY_BAD_INDEX = 384,
    JSMSG_TYPEDOBJECT_HANDLE_UNATTACHED = 385,
    JSMSG_TYPEDOBJECT_STRUCTTYPE_BAD_ARGS = 386,
    JSMSG_TYPEDOBJECT_TOO_BIG = 387,
    JSMSG_SIMD_FAILED_CONVERSION = 388,
    JSMSG_SIMD_TO_NUMBER = 389,
    JSMSG_BAD_INDEX = 390,
    JSMSG_NON_ARRAY_BUFFER_RETURNED = 391,
    JSMSG_SAME_ARRAY_BUFFER_RETURNED = 392,
    JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 393,
    JSMSG_TYPED_ARRAY_BAD_ARGS = 394,
    JSMSG_TYPED_ARRAY_NEGATIVE_ARG = 395,
    JSMSG_TYPED_ARRAY_DETACHED = 396,
    JSMSG_SHARED_ARRAY_BAD_LENGTH = 397,
    JSMSG_BAD_PARSE_NODE = 398,
    JSMSG_SYMBOL_TO_STRING = 399,
    JSMSG_SYMBOL_TO_NUMBER = 400,
    JSMSG_ATOMICS_BAD_ARRAY = 401,
    JSMSG_ATOMICS_TOO_LONG = 402,
    JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 403,
    JSMSG_ATOMICS_BAD_INDEX = 404,
    JSMSG_CANT_SET_INTERPOSED = 405,
    JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 406,
    JSMSG_CANT_DELETE_WINDOW_ELEMENT = 407,
    JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 408,
    JSMSG_CANT_PREVENT_EXTENSIONS = 409,
    JSMSG_NO_NAMED_SETTER = 410,
    JSMSG_NO_INDEXED_SETTER = 411,
    JSMSG_CANT_DELETE_SUPER = 412,
    JSMSG_REINIT_THIS = 413,
    JSMSG_BAD_DEFAULT_EXPORT = 414,
    JSMSG_MISSING_INDIRECT_EXPORT = 415,
    JSMSG_AMBIGUOUS_INDIRECT_EXPORT = 416,
    JSMSG_MISSING_IMPORT = 417,
    JSMSG_AMBIGUOUS_IMPORT = 418,
    JSMSG_MISSING_NAMESPACE_EXPORT = 419,
    JSMSG_MISSING_EXPORT = 420,
    JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 421,
    JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 422,
    JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 423,
    JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 424,
    JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 425,
    JSErr_Limit = 426,
}
/**
 * This class provides safe access to a string's chars across a GC. Once
 * we allocate strings and chars in the nursery (bug 903519), this class
 * will have to make a copy of the string's chars if they are allocated
 * in the nursery, so it's best to avoid using this class unless you really
 * need it. It's usually more efficient to use the latin1Chars/twoByteChars
 * JSString methods and often the code can be rewritten so that only indexes
 * instead of char pointers are used in parts of the code that can GC.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoStableStringChars {
    pub s_: RootedString,
    pub AutoStableStringChars_jsfriendapi_h_unnamed_14: AutoStableStringChars_jsfriendapi_h_unnamed_14,
    pub state_: AutoStableStringChars_State,
    pub ownsChars_: bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AutoStableStringChars_jsfriendapi_h_unnamed_14 {
    pub twoByteChars_: __BindgenUnionField<*const ::std::os::raw::c_ushort>,
    pub latin1Chars_: __BindgenUnionField<*const Latin1Char>,
    pub _bindgen_data_: u64,
}
impl AutoStableStringChars_jsfriendapi_h_unnamed_14 {
    pub unsafe fn twoByteChars_(&mut self)
     -> *mut *const ::std::os::raw::c_ushort {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn latin1Chars_(&mut self) -> *mut *const Latin1Char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for AutoStableStringChars_jsfriendapi_h_unnamed_14 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AutoStableStringChars_jsfriendapi_h_unnamed_14() {
    assert_eq!(::std::mem::size_of::<AutoStableStringChars_jsfriendapi_h_unnamed_14>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<AutoStableStringChars_jsfriendapi_h_unnamed_14>()
               , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum AutoStableStringChars_State {
    Uninitialized = 0,
    Latin1 = 1,
    TwoByte = 2,
}
#[test]
fn bindgen_test_layout_AutoStableStringChars() {
    assert_eq!(::std::mem::size_of::<AutoStableStringChars>() , 40usize);
    assert_eq!(::std::mem::align_of::<AutoStableStringChars>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct ErrorReport {
    pub reportp: *mut JSErrorReport,
    pub message_: *const ::std::os::raw::c_char,
    pub ownedReport: JSErrorReport,
    pub ownedMessage: *mut ::std::os::raw::c_char,
    pub str_: RootedString,
    pub strChars: AutoStableStringChars,
    pub exnObject: RootedObject,
    pub bytesStorage: JSAutoByteString,
    pub filename: JSAutoByteString,
    pub ownsMessageAndReport: bool,
}
#[test]
fn bindgen_test_layout_ErrorReport() {
    assert_eq!(::std::mem::size_of::<ErrorReport>() , 216usize);
    assert_eq!(::std::mem::align_of::<ErrorReport>() , 8usize);
}
extern "C" {
    #[link_name =
          "?init@ErrorReport@js@@QEAA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    fn _init_ErrorReport_js__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS___Z_(this:
                                                                                    *mut ErrorReport,
                                                                                cx:
                                                                                    *mut JSContext,
                                                                                exn:
                                                                                    HandleValue)
     -> bool;
    #[link_name = "?report@ErrorReport@js@@QEAAPEAVJSErrorReport@@XZ"]
    fn _report_ErrorReport_js__QEAAPEAVJSErrorReport__XZ_(this:
                                                              *mut ErrorReport)
     -> *mut JSErrorReport;
    #[link_name = "?message@ErrorReport@js@@QEAAPEBDXZ"]
    fn _message_ErrorReport_js__QEAAPEBDXZ_(this: *mut ErrorReport)
     -> *const ::std::os::raw::c_char;
}
impl ErrorReport {
    #[inline]
    pub unsafe fn init(&mut self, cx: *mut JSContext, exn: HandleValue)
     -> bool {
        _init_ErrorReport_js__QEAA_NPEAUJSContext__V__Handle_VValue_JS___JS___Z_(&mut *self,
                                                                                 cx,
                                                                                 exn)
    }
    #[inline]
    pub unsafe fn report(&mut self) -> *mut JSErrorReport {
        _report_ErrorReport_js__QEAAPEAVJSErrorReport__XZ_(&mut *self)
    }
    #[inline]
    pub unsafe fn message(&mut self) -> *const ::std::os::raw::c_char {
        _message_ErrorReport_js__QEAAPEBDXZ_(&mut *self)
    }
}
/**
 * Scalar types that can appear in typed arrays and typed objects.  The enum
 * values must to be kept in sync with the JS_SCALARTYPEREPR_ constants, as
 * well as the TypedArrayObject::classes and TypedArrayObject::protoClasses
 * definitions.
 */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Type {
    Int8 = 0,
    Uint8 = 1,
    Int16 = 2,
    Uint16 = 3,
    Int32 = 4,
    Uint32 = 5,
    Float32 = 6,
    Float64 = 7,
    Uint8Clamped = 8,
    MaxTypedArrayViewType = 9,
    Float32x4 = 10,
    Int32x4 = 11,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum DetachDataDisposition { ChangeData = 0, KeepData = 1, }
#[repr(i16)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum InlinableNative { _BindgenOpaqueEnum = 0, }
/**
 * A class, expected to be passed by value, which represents the CallArgs for a
 * JSJitGetterOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitGetterCallArgs {
    pub _base: MutableHandleValue,
}
impl ::std::clone::Clone for JSJitGetterCallArgs {
    fn clone(&self) -> Self { *self }
}
/**
 * A class, expected to be passed by value, which represents the CallArgs for a
 * JSJitSetterOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitSetterCallArgs {
    pub _base: MutableHandleValue,
}
impl ::std::clone::Clone for JSJitSetterCallArgs {
    fn clone(&self) -> Self { *self }
}
/**
 * A class, expected to be passed by reference, which represents the CallArgs
 * for a JSJitMethodOp.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitMethodCallArgs {
    pub _base: CallArgsBase<NoUsedRval>,
}
impl ::std::clone::Clone for JSJitMethodCallArgs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitMethodCallArgsTraits;
impl ::std::clone::Clone for JSJitMethodCallArgsTraits {
    fn clone(&self) -> Self { *self }
}
pub type JSJitGetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args: JSJitGetterCallArgs)
                              -> bool>;
pub type JSJitSetterOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args: JSJitSetterCallArgs)
                              -> bool>;
pub type JSJitMethodOp =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               thisObj: HandleObject,
                                               specializedThis:
                                                   *mut ::std::os::raw::c_void,
                                               args:
                                                   *const JSJitMethodCallArgs)
                              -> bool>;
/**
 * This struct contains metadata passed from the DOM to the JS Engine for JIT
 * optimizations on DOM property accessors. Eventually, this should be made
 * available to general JSAPI users, but we are not currently ready to do so.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSJitInfo {
    pub call: *const ::std::os::raw::c_void,
    pub protoID: u16,
    pub depth: u16,
    /** The OpType that says what sort of function we are. */
    pub _bitfield_1: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_OpType {
    Getter = 0,
    Setter = 1,
    Method = 2,
    StaticMethod = 3,
    InlinableNative = 4,
    OpTypeCount = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_ArgType {
    String = 1,
    Integer = 2,
    Double = 4,
    Boolean = 8,
    Object = 16,
    Null = 32,
    Numeric = 6,
    Primitive = 47,
    ObjectOrNull = 48,
    Any = 63,
    ArgTypeListEnd = -2147483648,
}
/**
     * An enum that describes what this getter/setter/method aliases.  This
     * determines what things can be hoisted past this call, and if this
     * call is movable what it can be hoisted past.
     */
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum JSJitInfo_AliasSet {
    AliasNone = 0,
    AliasDOMSets = 1,
    AliasEverything = 2,
    AliasSetCount = 3,
}
impl JSJitInfo {
    pub fn set_type_(&mut self, val: u8) {
        self._bitfield_1 &= !(((1 << (4u32 as u32)) - 1) << 0usize);
        self._bitfield_1 |= (val as u32) << 0usize;
    }
    pub fn set_aliasSet_(&mut self, val: u8) {
        self._bitfield_1 &= !(((1 << (4u32 as u32)) - 1) << 4usize);
        self._bitfield_1 |= (val as u32) << 4usize;
    }
    pub fn set_returnType_(&mut self, val: u8) {
        self._bitfield_1 &= !(((1 << (8u32 as u32)) - 1) << 8usize);
        self._bitfield_1 |= (val as u32) << 8usize;
    }
    pub fn set_isInfallible(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 16usize);
        self._bitfield_1 |= (val as u32) << 16usize;
    }
    pub fn set_isMovable(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 17usize);
        self._bitfield_1 |= (val as u32) << 17usize;
    }
    pub fn set_isEliminatable(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 18usize);
        self._bitfield_1 |= (val as u32) << 18usize;
    }
    pub fn set_isAlwaysInSlot(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 19usize);
        self._bitfield_1 |= (val as u32) << 19usize;
    }
    pub fn set_isLazilyCachedInSlot(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 20usize);
        self._bitfield_1 |= (val as u32) << 20usize;
    }
    pub fn set_isTypedMethod(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << (1u32 as u32)) - 1) << 21usize);
        self._bitfield_1 |= (val as u32) << 21usize;
    }
    pub fn set_slotIndex(&mut self, val: u16) {
        self._bitfield_1 &= !(((1 << (10u32 as u32)) - 1) << 22usize);
        self._bitfield_1 |= (val as u32) << 22usize;
    }
    pub const fn new_bitfield_1(type_: u8, aliasSet_: u8, returnType_: u8,
                                isInfallible: bool, isMovable: bool,
                                isEliminatable: bool, isAlwaysInSlot: bool,
                                isLazilyCachedInSlot: bool,
                                isTypedMethod: bool, slotIndex: u16) -> u32 {
        0 | ((type_ as u32) << 0u32) | ((aliasSet_ as u32) << 4u32) |
            ((returnType_ as u32) << 8u32) | ((isInfallible as u32) << 16u32)
            | ((isMovable as u32) << 17u32) |
            ((isEliminatable as u32) << 18u32) |
            ((isAlwaysInSlot as u32) << 19u32) |
            ((isLazilyCachedInSlot as u32) << 20u32) |
            ((isTypedMethod as u32) << 21u32) | ((slotIndex as u32) << 22u32)
    }
}
impl ::std::clone::Clone for JSJitInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSJitInfo() {
    assert_eq!(::std::mem::size_of::<JSJitInfo>() , 16usize);
    assert_eq!(::std::mem::align_of::<JSJitInfo>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JSTypedMethodJitInfo {
    pub base: JSJitInfo,
    pub argTypes: *const JSJitInfo_ArgType,
}
impl ::std::clone::Clone for JSTypedMethodJitInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_JSTypedMethodJitInfo() {
    assert_eq!(::std::mem::size_of::<JSTypedMethodJitInfo>() , 24usize);
    assert_eq!(::std::mem::align_of::<JSTypedMethodJitInfo>() , 8usize);
}
/**
 * If the embedder has registered a ScriptEnvironmentPreparer,
 * PrepareScriptEnvironmentAndInvoke will call the preparer's 'invoke' method
 * with the given |closure|, with the assumption that the preparer will set up
 * any state necessary to run script in |scope|, invoke |closure| with a valid
 * JSContext*, report any exceptions thrown from the closure, and return.
 *
 * If no preparer is registered, PrepareScriptEnvironmentAndInvoke will assert
 * that |rt| has exactly one JSContext associated with it, enter the compartment
 * of |scope| on that context, and invoke |closure|.
 *
 * In both cases, PrepareScriptEnvironmentAndInvoke will report any exceptions
 * that are thrown by the closure.  Consumers who want to propagate back
 * whether the closure succeeded should do so via members of the closure
 * itself.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptEnvironmentPreparer {
    pub _vftable: *const _vftable_ScriptEnvironmentPreparer,
}
#[repr(C)]
pub struct _vftable_ScriptEnvironmentPreparer {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptEnvironmentPreparer_Closure {
    pub _vftable: *const _vftable_ScriptEnvironmentPreparer_Closure,
}
#[repr(C)]
pub struct _vftable_ScriptEnvironmentPreparer_Closure {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for ScriptEnvironmentPreparer_Closure {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptEnvironmentPreparer_Closure() {
    assert_eq!(::std::mem::size_of::<ScriptEnvironmentPreparer_Closure>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<ScriptEnvironmentPreparer_Closure>() ,
               8usize);
}
impl ::std::clone::Clone for ScriptEnvironmentPreparer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptEnvironmentPreparer() {
    assert_eq!(::std::mem::size_of::<ScriptEnvironmentPreparer>() , 8usize);
    assert_eq!(::std::mem::align_of::<ScriptEnvironmentPreparer>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum CTypesActivityType {
    CTYPES_CALL_BEGIN = 0,
    CTYPES_CALL_END = 1,
    CTYPES_CALLBACK_BEGIN = 2,
    CTYPES_CALLBACK_END = 3,
}
pub type CTypesActivityCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               type_: CTypesActivityType)>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct AutoCTypesActivityCallback {
    pub cx: *mut JSContext,
    pub callback: CTypesActivityCallback,
    pub endType: CTypesActivityType,
}
#[test]
fn bindgen_test_layout_AutoCTypesActivityCallback() {
    assert_eq!(::std::mem::size_of::<AutoCTypesActivityCallback>() , 24usize);
    assert_eq!(::std::mem::align_of::<AutoCTypesActivityCallback>() , 8usize);
}
extern "C" {
    #[link_name = "?DoEndCallback@AutoCTypesActivityCallback@js@@QEAAXXZ"]
    fn _DoEndCallback_AutoCTypesActivityCallback_js__QEAAXXZ_(this:
                                                                  *mut AutoCTypesActivityCallback);
}
impl AutoCTypesActivityCallback {
    #[inline]
    pub unsafe fn DoEndCallback(&mut self) {
        _DoEndCallback_AutoCTypesActivityCallback_js__QEAAXXZ_(&mut *self)
    }
}
pub type ObjectMetadataCallback =
    ::std::option::Option<unsafe extern "C" fn(cx: *mut JSContext,
                                               obj: HandleObject)
                              -> *mut JSObject>;
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NativeProfiler {
    pub _vftable: *const _vftable_NativeProfiler,
}
#[repr(C)]
pub struct _vftable_NativeProfiler {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
#[test]
fn bindgen_test_layout_NativeProfiler() {
    assert_eq!(::std::mem::size_of::<NativeProfiler>() , 8usize);
    assert_eq!(::std::mem::align_of::<NativeProfiler>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct GCHeapProfiler {
    pub _vftable: *const _vftable_GCHeapProfiler,
}
#[repr(C)]
pub struct _vftable_GCHeapProfiler {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
#[test]
fn bindgen_test_layout_GCHeapProfiler() {
    assert_eq!(::std::mem::size_of::<GCHeapProfiler>() , 8usize);
    assert_eq!(::std::mem::align_of::<GCHeapProfiler>() , 8usize);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum InitState { Uninitialized = 0, Running = 1, ShutDown = 2, }
pub type JS_ICUAllocFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               size: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type JS_ICUReallocFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               p: *mut ::std::os::raw::c_void,
                                               size: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type JS_ICUFreeFn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               p:
                                                   *mut ::std::os::raw::c_void)>;
pub enum nsISupports { }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TabSizes {
    pub objects: usize,
    pub strings: usize,
    pub private_: usize,
    pub other: usize,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum TabSizes_Kind { Objects = 0, Strings = 1, Private = 2, Other = 3, }
impl ::std::clone::Clone for TabSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TabSizes() {
    assert_eq!(::std::mem::size_of::<TabSizes>() , 32usize);
    assert_eq!(::std::mem::align_of::<TabSizes>() , 8usize);
}
/** These are the measurements used by Servo. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ServoSizes {
    pub gcHeapUsed: usize,
    pub gcHeapUnused: usize,
    pub gcHeapAdmin: usize,
    pub gcHeapDecommitted: usize,
    pub mallocHeap: usize,
    pub nonHeap: usize,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ServoSizes_Kind {
    GCHeapUsed = 0,
    GCHeapUnused = 1,
    GCHeapAdmin = 2,
    GCHeapDecommitted = 3,
    MallocHeap = 4,
    NonHeap = 5,
    Ignore = 6,
}
impl ::std::clone::Clone for ServoSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ServoSizes() {
    assert_eq!(::std::mem::size_of::<ServoSizes>() , 48usize);
    assert_eq!(::std::mem::align_of::<ServoSizes>() , 8usize);
}
/**
 * This hash policy avoids flattening ropes (which perturbs the site being
 * measured and requires a JSContext) at the expense of doing a FULL ROPE COPY
 * on every hash and match! Beware.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InefficientNonFlatteningStringHashPolicy;
impl ::std::clone::Clone for InefficientNonFlatteningStringHashPolicy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CStringHashPolicy;
impl ::std::clone::Clone for CStringHashPolicy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClassInfo {
    pub objectsGCHeap: usize,
    pub objectsMallocHeapSlots: usize,
    pub objectsMallocHeapElementsNormal: usize,
    pub objectsMallocHeapElementsAsmJS: usize,
    pub objectsNonHeapElementsNormal: usize,
    pub objectsNonHeapElementsAsmJS: usize,
    pub objectsNonHeapElementsShared: usize,
    pub objectsNonHeapCodeAsmJS: usize,
    pub objectsMallocHeapMisc: usize,
    pub shapesGCHeapTree: usize,
    pub shapesGCHeapDict: usize,
    pub shapesGCHeapBase: usize,
    pub shapesMallocHeapTreeTables: usize,
    pub shapesMallocHeapDictTables: usize,
    pub shapesMallocHeapTreeKids: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for ClassInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ClassInfo() {
    assert_eq!(::std::mem::size_of::<ClassInfo>() , 128usize);
    assert_eq!(::std::mem::align_of::<ClassInfo>() , 8usize);
}
/**
 * Holds data about a notable class (one whose combined object and shape
 * instances use more than a certain amount of memory) so we can report it
 * individually.
 *
 * The only difference between this class and ClassInfo is that this class
 * holds a copy of the filename.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableClassInfo {
    pub _base: ClassInfo,
    pub className_: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotableClassInfo() {
    assert_eq!(::std::mem::size_of::<NotableClassInfo>() , 136usize);
    assert_eq!(::std::mem::align_of::<NotableClassInfo>() , 8usize);
}
/** Data for tracking JIT-code memory usage. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CodeSizes {
    pub ion: usize,
    pub baseline: usize,
    pub regexp: usize,
    pub other: usize,
    pub unused: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for CodeSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CodeSizes() {
    assert_eq!(::std::mem::size_of::<CodeSizes>() , 48usize);
    assert_eq!(::std::mem::align_of::<CodeSizes>() , 8usize);
}
/** Data for tracking GC memory usage. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GCSizes {
    pub marker: usize,
    pub nurseryCommitted: usize,
    pub nurseryDecommitted: usize,
    pub nurseryMallocedBuffers: usize,
    pub storeBufferVals: usize,
    pub storeBufferCells: usize,
    pub storeBufferSlots: usize,
    pub storeBufferWholeCells: usize,
    pub storeBufferGenerics: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for GCSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GCSizes() {
    assert_eq!(::std::mem::size_of::<GCSizes>() , 80usize);
    assert_eq!(::std::mem::align_of::<GCSizes>() , 8usize);
}
/**
 * This class holds information about the memory taken up by identical copies of
 * a particular string.  Multiple JSStrings may have their sizes aggregated
 * together into one StringInfo object.  Note that two strings with identical
 * chars will not be aggregated together if one is a short string and the other
 * is not.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StringInfo {
    pub gcHeapLatin1: usize,
    pub gcHeapTwoByte: usize,
    pub mallocHeapLatin1: usize,
    pub mallocHeapTwoByte: usize,
    pub numCopies: u32,
}
impl ::std::clone::Clone for StringInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_StringInfo() {
    assert_eq!(::std::mem::size_of::<StringInfo>() , 40usize);
    assert_eq!(::std::mem::align_of::<StringInfo>() , 8usize);
}
/**
 * Holds data about a notable string (one which, counting all duplicates, uses
 * more than a certain amount of memory) so we can report it individually.
 *
 * The only difference between this class and StringInfo is that
 * NotableStringInfo holds a copy of some or all of the string's chars.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableStringInfo {
    pub _base: StringInfo,
    pub buffer: *mut ::std::os::raw::c_char,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_NotableStringInfo() {
    assert_eq!(::std::mem::size_of::<NotableStringInfo>() , 56usize);
    assert_eq!(::std::mem::align_of::<NotableStringInfo>() , 8usize);
}
/**
 * This class holds information about the memory taken up by script sources
 * from a particular file.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScriptSourceInfo {
    pub compressed: usize,
    pub uncompressed: usize,
    pub misc: usize,
    pub numScripts: u32,
}
impl ::std::clone::Clone for ScriptSourceInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ScriptSourceInfo() {
    assert_eq!(::std::mem::size_of::<ScriptSourceInfo>() , 32usize);
    assert_eq!(::std::mem::align_of::<ScriptSourceInfo>() , 8usize);
}
/**
 * Holds data about a notable script source file (one whose combined
 * script sources use more than a certain amount of memory) so we can report it
 * individually.
 *
 * The only difference between this class and ScriptSourceInfo is that this
 * class holds a copy of the filename.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
#[derive(Debug)]
pub struct NotableScriptSourceInfo {
    pub _base: ScriptSourceInfo,
    pub filename_: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotableScriptSourceInfo() {
    assert_eq!(::std::mem::size_of::<NotableScriptSourceInfo>() , 40usize);
    assert_eq!(::std::mem::align_of::<NotableScriptSourceInfo>() , 8usize);
}
/**
 * These measurements relate directly to the JSRuntime, and not to zones and
 * compartments within it.
 */
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct RuntimeSizes {
    pub object: usize,
    pub atomsTable: usize,
    pub contexts: usize,
    pub temporary: usize,
    pub interpreterStack: usize,
    pub mathCache: usize,
    pub uncompressedSourceCache: usize,
    pub compressedSourceSet: usize,
    pub scriptData: usize,
    pub scriptSourceInfo: ScriptSourceInfo,
    pub code: CodeSizes,
    pub gc: GCSizes,
    pub allScriptSources: u64,
    pub notableScriptSources: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_RuntimeSizes() {
    assert_eq!(::std::mem::size_of::<RuntimeSizes>() , 272usize);
    assert_eq!(::std::mem::align_of::<RuntimeSizes>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UnusedGCThingSizes {
    pub object: usize,
    pub script: usize,
    pub lazyScript: usize,
    pub shape: usize,
    pub baseShape: usize,
    pub objectGroup: usize,
    pub string: usize,
    pub symbol: usize,
    pub jitcode: usize,
    pub dummy: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for UnusedGCThingSizes {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_UnusedGCThingSizes() {
    assert_eq!(::std::mem::size_of::<UnusedGCThingSizes>() , 80usize);
    assert_eq!(::std::mem::align_of::<UnusedGCThingSizes>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct ZoneStats {
    pub symbolsGCHeap: usize,
    pub gcHeapArenaAdmin: usize,
    pub lazyScriptsGCHeap: usize,
    pub lazyScriptsMallocHeap: usize,
    pub jitCodesGCHeap: usize,
    pub objectGroupsGCHeap: usize,
    pub objectGroupsMallocHeap: usize,
    pub typePool: usize,
    pub baselineStubsOptimized: usize,
    pub uniqueIdMap: usize,
    pub unusedGCThings: UnusedGCThingSizes,
    pub stringInfo: StringInfo,
    pub extra: *mut ::std::os::raw::c_void,
    pub allStrings: u64,
    pub notableStrings: [u64; 4usize],
    pub isTotals: bool,
}
#[test]
fn bindgen_test_layout_ZoneStats() {
    assert_eq!(::std::mem::size_of::<ZoneStats>() , 256usize);
    assert_eq!(::std::mem::align_of::<ZoneStats>() , 8usize);
}
#[repr(C)]
#[unsafe_no_drop_flag]
pub struct CompartmentStats {
    pub objectsPrivate: usize,
    pub scriptsGCHeap: usize,
    pub scriptsMallocHeapData: usize,
    pub baselineData: usize,
    pub baselineStubsFallback: usize,
    pub ionData: usize,
    pub typeInferenceTypeScripts: usize,
    pub typeInferenceAllocationSiteTables: usize,
    pub typeInferenceArrayTypeTables: usize,
    pub typeInferenceObjectTypeTables: usize,
    pub compartmentObject: usize,
    pub compartmentTables: usize,
    pub innerViewsTable: usize,
    pub lazyArrayBuffersTable: usize,
    pub objectMetadataTable: usize,
    pub crossCompartmentWrappersTable: usize,
    pub regexpCompartment: usize,
    pub savedStacksSet: usize,
    pub nonSyntacticLexicalScopesTable: usize,
    pub jitCompartment: usize,
    pub privateData: usize,
    pub classInfo: ClassInfo,
    pub extra: *mut ::std::os::raw::c_void,
    pub allClasses: u64,
    pub notableClasses: [u64; 4usize],
    pub isTotals: bool,
}
#[test]
fn bindgen_test_layout_CompartmentStats() {
    assert_eq!(::std::mem::size_of::<CompartmentStats>() , 352usize);
    assert_eq!(::std::mem::align_of::<CompartmentStats>() , 8usize);
}
pub type CompartmentStatsVector = ::std::os::raw::c_void;
pub type ZoneStatsVector = ::std::os::raw::c_void;
#[repr(C)]
pub struct RuntimeStats {
    pub _bindgen_opaque_blob: [u64; 127usize],
}
#[test]
fn bindgen_test_layout_RuntimeStats() {
    assert_eq!(::std::mem::size_of::<RuntimeStats>() , 1016usize);
    assert_eq!(::std::mem::align_of::<RuntimeStats>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ObjectPrivateVisitor {
    pub _vftable: *const _vftable_ObjectPrivateVisitor,
    pub getISupports_: ::std::option::Option<unsafe extern "C" fn() -> bool>,
}
#[repr(C)]
pub struct _vftable_ObjectPrivateVisitor {
    pub _bindgen_empty_ctype_warning_fix: u64,
}
impl ::std::clone::Clone for ObjectPrivateVisitor {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ObjectPrivateVisitor() {
    assert_eq!(::std::mem::size_of::<ObjectPrivateVisitor>() , 16usize);
    assert_eq!(::std::mem::align_of::<ObjectPrivateVisitor>() , 8usize);
}
extern "C" {
    #[link_name = "?NullHandleValue@JS@@3V?$Handle@VValue@JS@@@1@B"]
    pub static NullHandleValue: Handle<Value>;
    #[link_name = "?UndefinedHandleValue@JS@@3V?$Handle@VValue@JS@@@1@B"]
    pub static UndefinedHandleValue: Handle<Value>;
    #[link_name = "?TrueHandleValue@JS@@3V?$Handle@VValue@JS@@@1@B"]
    pub static TrueHandleValue: Handle<Value>;
    #[link_name = "?FalseHandleValue@JS@@3V?$Handle@VValue@JS@@@1@B"]
    pub static FalseHandleValue: Handle<Value>;
    #[link_name = "?JSID_VOID@@3Ujsid@@B"]
    pub static JSID_VOID: jsid;
    #[link_name = "?JSID_EMPTY@@3Ujsid@@B"]
    pub static JSID_EMPTY: jsid;
    #[link_name = "?JSID_VOIDHANDLE@@3V?$Handle@Ujsid@@@JS@@B"]
    pub static JSID_VOIDHANDLE: Handle<jsid>;
    #[link_name = "?JSID_EMPTYHANDLE@@3V?$Handle@Ujsid@@@JS@@B"]
    pub static JSID_EMPTYHANDLE: Handle<jsid>;
    #[link_name = "?FunctionClassPtr@js@@3QEBUClass@1@EB"]
    pub static FunctionClassPtr: Class;
    #[link_name = "?ObjectClassPtr@js@@3QEBUClass@1@EB"]
    pub static ObjectClassPtr: Class;
    #[link_name = "?Int8ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Int8ArrayClassPtr: *const Class;
    #[link_name = "?Uint8ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Uint8ArrayClassPtr: *const Class;
    #[link_name = "?Uint8ClampedArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Uint8ClampedArrayClassPtr: *const Class;
    #[link_name = "?Int16ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Int16ArrayClassPtr: *const Class;
    #[link_name = "?Uint16ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Uint16ArrayClassPtr: *const Class;
    #[link_name = "?Int32ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Int32ArrayClassPtr: *const Class;
    #[link_name = "?Uint32ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Uint32ArrayClassPtr: *const Class;
    #[link_name = "?Float32ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Float32ArrayClassPtr: *const Class;
    #[link_name = "?Float64ArrayClassPtr@detail@js@@3QEBUClass@2@EB"]
    pub static Float64ArrayClassPtr: *const Class;
    #[link_name = "?libraryInitState@detail@JS@@3W4InitState@12@A"]
    pub static mut libraryInitState: InitState;
}
extern "C" {
    #[link_name = "?CurrentThreadCanAccessRuntime@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn CurrentThreadCanAccessRuntime(rt: *mut JSRuntime) -> bool;
    #[link_name = "?CurrentThreadCanAccessZone@js@@YA_NPEAUZone@JS@@@Z"]
    pub fn CurrentThreadCanAccessZone(zone: *mut Zone) -> bool;
    #[link_name =
          "?AssertGCThingHasType@gc@js@@YAXPEAUCell@12@W4TraceKind@JS@@@Z"]
    pub fn AssertGCThingHasType(cell: *mut Cell, kind: TraceKind);
    #[link_name = "?GetObjectZone@JS@@YAPEAUZone@1@PEAVJSObject@@@Z"]
    pub fn GetObjectZone(obj: *mut JSObject) -> *mut Zone;
    /**
 * Create an object providing access to the garbage collector's internal notion
 * of the current state of memory (both GC heap memory and GCthing-controlled
 * malloc memory.
 */
    #[link_name =
          "?NewMemoryInfoObject@gc@js@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn NewMemoryInfoObject(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Get a statically allocated C string explaining the given GC reason.
 */
    #[link_name = "?ExplainReason@gcreason@JS@@YAPEBDW4Reason@12@@Z"]
    pub fn ExplainReason(reason: Reason) -> *const ::std::os::raw::c_char;
    /**
 * Schedule the given zone to be collected as part of the next GC.
 */
    #[link_name = "?PrepareZoneForGC@JS@@YAXPEAUZone@1@@Z"]
    pub fn PrepareZoneForGC(zone: *mut Zone);
    /**
 * Schedule all zones to be collected in the next GC.
 */
    #[link_name = "?PrepareForFullGC@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn PrepareForFullGC(rt: *mut JSRuntime);
    /**
 * When performing an incremental GC, the zones that were selected for the
 * previous incremental slice must be selected in subsequent slices as well.
 * This function selects those slices automatically.
 */
    #[link_name = "?PrepareForIncrementalGC@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn PrepareForIncrementalGC(rt: *mut JSRuntime);
    /**
 * Returns true if any zone in the system has been scheduled for GC with one of
 * the functions above or by the JS engine.
 */
    #[link_name = "?IsGCScheduled@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsGCScheduled(rt: *mut JSRuntime) -> bool;
    /**
 * Undoes the effect of the Prepare methods above. The given zone will not be
 * collected in the next GC.
 */
    #[link_name = "?SkipZoneForGC@JS@@YAXPEAUZone@1@@Z"]
    pub fn SkipZoneForGC(zone: *mut Zone);
    /**
 * Performs a non-incremental collection of all selected zones.
 *
 * If the gckind argument is GC_NORMAL, then some objects that are unreachable
 * from the program may still be alive afterwards because of internal
 * references; if GC_SHRINK is passed then caches and other temporary references
 * to objects will be cleared and all unreferenced objects will be removed from
 * the system.
 */
    #[link_name =
          "?GCForReason@JS@@YAXPEAUJSRuntime@@W4JSGCInvocationKind@@W4Reason@gcreason@1@@Z"]
    pub fn GCForReason(rt: *mut JSRuntime, gckind: JSGCInvocationKind,
                       reason: Reason);
    /**
 * Begin an incremental collection and perform one slice worth of work. When
 * this function returns, the collection may not be complete.
 * IncrementalGCSlice() must be called repeatedly until
 * !IsIncrementalGCInProgress(rt).
 *
 * Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
 *       shorter than the requested interval.
 */
    #[link_name =
          "?StartIncrementalGC@JS@@YAXPEAUJSRuntime@@W4JSGCInvocationKind@@W4Reason@gcreason@1@_J@Z"]
    pub fn StartIncrementalGC(rt: *mut JSRuntime, gckind: JSGCInvocationKind,
                              reason: Reason, millis: i64);
    /**
 * Perform a slice of an ongoing incremental collection. When this function
 * returns, the collection may not be complete. It must be called repeatedly
 * until !IsIncrementalGCInProgress(rt).
 *
 * Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
 *       shorter than the requested interval.
 */
    #[link_name =
          "?IncrementalGCSlice@JS@@YAXPEAUJSRuntime@@W4Reason@gcreason@1@_J@Z"]
    pub fn IncrementalGCSlice(rt: *mut JSRuntime, reason: Reason,
                              millis: i64);
    /**
 * If IsIncrementalGCInProgress(rt), this call finishes the ongoing collection
 * by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(rt),
 * this is equivalent to GCForReason. When this function returns,
 * IsIncrementalGCInProgress(rt) will always be false.
 */
    #[link_name =
          "?FinishIncrementalGC@JS@@YAXPEAUJSRuntime@@W4Reason@gcreason@1@@Z"]
    pub fn FinishIncrementalGC(rt: *mut JSRuntime, reason: Reason);
    /**
 * If IsIncrementalGCInProgress(rt), this call aborts the ongoing collection and
 * performs whatever work needs to be done to return the collector to its idle
 * state. This may take an arbitrarily long time. When this function returns,
 * IsIncrementalGCInProgress(rt) will always be false.
 */
    #[link_name = "?AbortIncrementalGC@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn AbortIncrementalGC(rt: *mut JSRuntime);
    /**
 * The GC slice callback is called at the beginning and end of each slice. This
 * callback may be used for GC notifications as well as to perform additional
 * marking.
 */
    #[link_name =
          "?SetGCSliceCallback@JS@@YAP6AXPEAUJSRuntime@@W4GCProgress@1@AEBUGCDescription@1@@Z0P6AX012@Z@Z"]
    pub fn SetGCSliceCallback(rt: *mut JSRuntime, callback: GCSliceCallback)
     -> GCSliceCallback;
    /**
 * Set the nursery collection callback for the given runtime. When set, it will
 * be called at the start and end of every nursery collection.
 */
    #[link_name =
          "?SetGCNurseryCollectionCallback@JS@@YAP6AXPEAUJSRuntime@@W4GCNurseryProgress@1@W4Reason@gcreason@1@@Z0P6AX012@Z@Z"]
    pub fn SetGCNurseryCollectionCallback(rt: *mut JSRuntime,
                                          callback:
                                              GCNurseryCollectionCallback)
     -> GCNurseryCollectionCallback;
    /**
 * Incremental GC defaults to enabled, but may be disabled for testing or in
 * embeddings that have not yet implemented barriers on their native classes.
 * There is not currently a way to re-enable incremental GC once it has been
 * disabled on the runtime.
 */
    #[link_name = "?DisableIncrementalGC@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn DisableIncrementalGC(rt: *mut JSRuntime);
    /**
 * Returns true if incremental GC is enabled. Simply having incremental GC
 * enabled is not sufficient to ensure incremental collections are happening.
 * See the comment "Incremental GC" above for reasons why incremental GC may be
 * suppressed. Inspection of the "nonincremental reason" field of the
 * GCDescription returned by GCSliceCallback may help narrow down the cause if
 * collections are not happening incrementally when expected.
 */
    #[link_name = "?IsIncrementalGCEnabled@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsIncrementalGCEnabled(rt: *mut JSRuntime) -> bool;
    /**
 * Returns true while an incremental GC is ongoing, both when actively
 * collecting and between slices.
 */
    #[link_name = "?IsIncrementalGCInProgress@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsIncrementalGCInProgress(rt: *mut JSRuntime) -> bool;
    #[link_name = "?IsIncrementalBarrierNeeded@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsIncrementalBarrierNeeded(rt: *mut JSRuntime) -> bool;
    #[link_name = "?IsIncrementalBarrierNeeded@JS@@YA_NPEAUJSContext@@@Z"]
    pub fn IsIncrementalBarrierNeeded1(cx: *mut JSContext) -> bool;
    #[link_name = "?IncrementalReferenceBarrier@JS@@YAXVGCCellPtr@1@@Z"]
    pub fn IncrementalReferenceBarrier(thing: GCCellPtr);
    #[link_name = "?IncrementalValueBarrier@JS@@YAXAEBVValue@1@@Z"]
    pub fn IncrementalValueBarrier(v: *const Value);
    #[link_name = "?IncrementalObjectBarrier@JS@@YAXPEAVJSObject@@@Z"]
    pub fn IncrementalObjectBarrier(obj: *mut JSObject);
    /**
 * Returns true if the most recent GC ran incrementally.
 */
    #[link_name = "?WasIncrementalGC@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn WasIncrementalGC(rt: *mut JSRuntime) -> bool;
    /**
 * Returns true if generational allocation and collection is currently enabled
 * on the given runtime.
 */
    #[link_name = "?IsGenerationalGCEnabled@JS@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsGenerationalGCEnabled(rt: *mut JSRuntime) -> bool;
    /**
 * Returns the GC's "number". This does not correspond directly to the number
 * of GCs that have been run, but is guaranteed to be monotonically increasing
 * with GC activity.
 */
    #[link_name = "?GetGCNumber@JS@@YA_KXZ"]
    pub fn GetGCNumber() -> usize;
    /**
 * The GC does not immediately return the unused memory freed by a collection
 * back to the system incase it is needed soon afterwards. This call forces the
 * GC to return this memory immediately.
 */
    #[link_name = "?ShrinkGCBuffers@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn ShrinkGCBuffers(rt: *mut JSRuntime);
    /**
 * Unsets the gray bit for anything reachable from |thing|. |kind| should not be
 * JS::TraceKind::Shape. |thing| should be non-null.
 */
    #[link_name = "?UnmarkGrayGCThingRecursively@JS@@YA_NVGCCellPtr@1@@Z"]
    pub fn UnmarkGrayGCThingRecursively(thing: GCCellPtr) -> bool;
    #[link_name = "?PokeGC@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn PokeGC(rt: *mut JSRuntime);
    #[link_name = "?NotifyDidPaint@JS@@YAXPEAUJSRuntime@@@Z"]
    pub fn NotifyDidPaint(rt: *mut JSRuntime);
    /** Returns a static string equivalent of |kind|. */
    #[link_name = "?GCTraceKindToAscii@JS@@YAPEBDW4TraceKind@1@@Z"]
    pub fn GCTraceKindToAscii(kind: TraceKind)
     -> *const ::std::os::raw::c_char;
    #[link_name =
          "?TraceEdge@JS@@YAXPEAVJSTracer@@PEAV?$TenuredHeap@PEAVJSObject@@@1@PEBD@Z"]
    pub fn TraceEdge(trc: *mut JSTracer,
                     edgep: *mut TenuredHeap<*mut JSObject>,
                     name: *const ::std::os::raw::c_char);
    #[link_name = "?TraceChildren@JS@@YAXPEAVJSTracer@@VGCCellPtr@1@@Z"]
    pub fn TraceChildren(trc: *mut JSTracer, thing: GCCellPtr);
    #[link_name =
          "?JS_GetTraceThingInfo@@YAXPEAD_KPEAVJSTracer@@PEAXW4TraceKind@JS@@_N@Z"]
    pub fn JS_GetTraceThingInfo(buf: *mut ::std::os::raw::c_char,
                                bufsize: usize, trc: *mut JSTracer,
                                thing: *mut ::std::os::raw::c_void,
                                kind: TraceKind, includeDetails: bool);
    #[link_name = "?isGCEnabled@JS@@YA_NXZ"]
    pub fn isGCEnabled() -> bool;
    #[link_name = "?HeapObjectPostBarrier@JS@@YAXPEAPEAVJSObject@@PEAV2@1@Z"]
    pub fn HeapObjectPostBarrier(objp: *mut *mut JSObject,
                                 prev: *mut JSObject, next: *mut JSObject);
    /**
 * For generational GC, assert that an object is in the tenured generation as
 * opposed to being in the nursery.
 */
    #[link_name = "?AssertGCThingMustBeTenured@JS@@YAXPEAVJSObject@@@Z"]
    pub fn AssertGCThingMustBeTenured(obj: *mut JSObject);
    #[link_name =
          "?AssertGCThingIsNotAnObjectSubclass@JS@@YAXPEAUCell@gc@js@@@Z"]
    pub fn AssertGCThingIsNotAnObjectSubclass(cell: *mut Cell);
    #[link_name = "?HeapValuePostBarrier@JS@@YAXPEAVValue@1@AEBV21@1@Z"]
    pub fn HeapValuePostBarrier(valuep: *mut Value, prev: *const Value,
                                next: *const Value);
    #[link_name = "?JS_ComputeThis@@YA?AVValue@JS@@PEAUJSContext@@PEAV12@@Z"]
    pub fn JS_ComputeThis(cx: *mut JSContext, vp: *mut Value) -> Value;
    #[link_name = "?CheckIsValidConstructible@detail@JS@@YAXVValue@2@@Z"]
    pub fn CheckIsValidConstructible(v: Value);
    /**
 * Only JSStrings that have been interned via the JSAPI can be turned into
 * jsids by API clients.
 *
 * N.B. if a jsid is backed by a string which has not been interned, that
 * string must be appropriately rooted to avoid being collected by the GC.
 */
    #[link_name =
          "?INTERNED_STRING_TO_JSID@@YA?AUjsid@@PEAUJSContext@@PEAVJSString@@@Z"]
    pub fn INTERNED_STRING_TO_JSID(cx: *mut JSContext, str: *mut JSString)
     -> jsid;
    /**
 * ES6 7.2.2.
 *
 * Returns false on failure, otherwise returns true and sets |*isArray|
 * indicating whether the object passes ECMAScript's IsArray test.  This is the
 * same test performed by |Array.isArray|.
 *
 * This is NOT the same as asking whether |obj| is an Array or a wrapper around
 * one.  If |obj| is a proxy created by |Proxy.revocable()| and has been
 * revoked, or if |obj| is a proxy whose target (at any number of hops) is a
 * revoked proxy, this method throws a TypeError and returns false.
 */
    #[link_name =
          "?IsArray@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@PEA_N@Z"]
    pub fn IsArray(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool)
     -> bool;
    /**
 * Identical to IsArray above, but the nature of the object (if successfully
 * determined) is communicated via |*answer|.  In particular this method
 * returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on
 * a revoked proxy.
 *
 * Most users will want the overload above, not this one.
 */
    #[link_name =
          "?IsArray@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@PEAW4IsArrayAnswer@1@@Z"]
    pub fn IsArray1(cx: *mut JSContext, obj: HandleObject,
                    answer: *mut IsArrayAnswer) -> bool;
    /** Note: if the *data contains transferable objects, it can be read only once. */
    #[link_name =
          "?JS_ReadStructuredClone@@YA_NPEAUJSContext@@PEA_K_KIV?$MutableHandle@VValue@JS@@@JS@@PEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    pub fn JS_ReadStructuredClone(cx: *mut JSContext, data: *mut u64,
                                  nbytes: usize, version: u32,
                                  vp: MutableHandleValue,
                                  optionalCallbacks:
                                      *const JSStructuredCloneCallbacks,
                                  closure: *mut ::std::os::raw::c_void)
     -> bool;
    /**
 * Note: On success, the caller is responsible for calling
 * JS_ClearStructuredClone(*datap, nbytes, optionalCallbacks, closure).
 */
    #[link_name =
          "?JS_WriteStructuredClone@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAPEA_KPEA_KPEBUJSStructuredCloneCallbacks@@PEAX1@Z"]
    pub fn JS_WriteStructuredClone(cx: *mut JSContext, v: HandleValue,
                                   datap: *mut *mut u64, nbytesp: *mut usize,
                                   optionalCallbacks:
                                       *const JSStructuredCloneCallbacks,
                                   closure: *mut ::std::os::raw::c_void,
                                   transferable: HandleValue) -> bool;
    #[link_name =
          "?JS_ClearStructuredClone@@YA_NPEA_K_KPEBUJSStructuredCloneCallbacks@@PEAX_N@Z"]
    pub fn JS_ClearStructuredClone(data: *mut u64, nbytes: usize,
                                   optionalCallbacks:
                                       *const JSStructuredCloneCallbacks,
                                   closure: *mut ::std::os::raw::c_void,
                                   freeData: bool) -> bool;
    #[link_name = "?JS_StructuredCloneHasTransferables@@YA_NPEB_K_KPEA_N@Z"]
    pub fn JS_StructuredCloneHasTransferables(data: *const u64, nbytes: usize,
                                              hasTransferable: *mut bool)
     -> bool;
    #[link_name =
          "?JS_StructuredClone@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@V?$MutableHandle@VValue@JS@@@3@PEBUJSStructuredCloneCallbacks@@PEAX@Z"]
    pub fn JS_StructuredClone(cx: *mut JSContext, v: HandleValue,
                              vp: MutableHandleValue,
                              optionalCallbacks:
                                  *const JSStructuredCloneCallbacks,
                              closure: *mut ::std::os::raw::c_void) -> bool;
    #[link_name =
          "?JS_ReadUint32Pair@@YA_NPEAUJSStructuredCloneReader@@PEAI1@Z"]
    pub fn JS_ReadUint32Pair(r: *mut JSStructuredCloneReader, p1: *mut u32,
                             p2: *mut u32) -> bool;
    #[link_name = "?JS_ReadBytes@@YA_NPEAUJSStructuredCloneReader@@PEAX_K@Z"]
    pub fn JS_ReadBytes(r: *mut JSStructuredCloneReader,
                        p: *mut ::std::os::raw::c_void, len: usize) -> bool;
    #[link_name =
          "?JS_ReadTypedArray@@YA_NPEAUJSStructuredCloneReader@@V?$MutableHandle@VValue@JS@@@JS@@@Z"]
    pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader,
                             vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_WriteUint32Pair@@YA_NPEAUJSStructuredCloneWriter@@II@Z"]
    pub fn JS_WriteUint32Pair(w: *mut JSStructuredCloneWriter, tag: u32,
                              data: u32) -> bool;
    #[link_name = "?JS_WriteBytes@@YA_NPEAUJSStructuredCloneWriter@@PEBX_K@Z"]
    pub fn JS_WriteBytes(w: *mut JSStructuredCloneWriter,
                         p: *const ::std::os::raw::c_void, len: usize)
     -> bool;
    #[link_name =
          "?JS_WriteString@@YA_NPEAUJSStructuredCloneWriter@@V?$Handle@PEAVJSString@@@JS@@@Z"]
    pub fn JS_WriteString(w: *mut JSStructuredCloneWriter, str: HandleString)
     -> bool;
    #[link_name =
          "?JS_WriteTypedArray@@YA_NPEAUJSStructuredCloneWriter@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: HandleValue)
     -> bool;
    #[link_name = "?JS_HoldPrincipals@@YAXPEAUJSPrincipals@@@Z"]
    pub fn JS_HoldPrincipals(principals: *mut JSPrincipals);
    #[link_name =
          "?JS_DropPrincipals@@YAXPEAUJSRuntime@@PEAUJSPrincipals@@@Z"]
    pub fn JS_DropPrincipals(rt: *mut JSRuntime,
                             principals: *mut JSPrincipals);
    #[link_name =
          "?JS_SetSecurityCallbacks@@YAXPEAUJSRuntime@@PEBUJSSecurityCallbacks@@@Z"]
    pub fn JS_SetSecurityCallbacks(rt: *mut JSRuntime,
                                   callbacks: *const JSSecurityCallbacks);
    #[link_name =
          "?JS_GetSecurityCallbacks@@YAPEBUJSSecurityCallbacks@@PEAUJSRuntime@@@Z"]
    pub fn JS_GetSecurityCallbacks(rt: *mut JSRuntime)
     -> *const JSSecurityCallbacks;
    #[link_name =
          "?JS_SetTrustedPrincipals@@YAXPEAUJSRuntime@@PEAUJSPrincipals@@@Z"]
    pub fn JS_SetTrustedPrincipals(rt: *mut JSRuntime,
                                   prin: *mut JSPrincipals);
    #[link_name =
          "?JS_InitDestroyPrincipalsCallback@@YAXPEAUJSRuntime@@P6AXPEAUJSPrincipals@@@Z@Z"]
    pub fn JS_InitDestroyPrincipalsCallback(rt: *mut JSRuntime,
                                            destroyPrincipals:
                                                JSDestroyPrincipalsOp);
    #[link_name =
          "?JS_InitReadPrincipalsCallback@@YAXPEAUJSRuntime@@P6A_NPEAUJSContext@@PEAUJSStructuredCloneReader@@PEAPEAUJSPrincipals@@@Z@Z"]
    pub fn JS_InitReadPrincipalsCallback(rt: *mut JSRuntime,
                                         read: JSReadPrincipalsOp);
    /************************************************************************/
    #[link_name =
          "?JS_StringHasBeenPinned@@YA_NPEAUJSContext@@PEAVJSString@@@Z"]
    pub fn JS_StringHasBeenPinned(cx: *mut JSContext, str: *mut JSString)
     -> bool;
    /**
 * The first call to JS_CallOnce by any thread in a process will call 'func'.
 * Later calls to JS_CallOnce with the same JSCallOnceType object will be
 * suppressed.
 *
 * Equivalently: each distinct JSCallOnceType object will allow one JS_CallOnce
 * to invoke its JSInitCallback.
 */
    #[link_name = "?JS_CallOnce@@YA_NPEAUPRCallOnceType@@P6A_NXZ@Z"]
    pub fn JS_CallOnce(once: *mut JSCallOnceType, func: JSInitCallback)
     -> bool;
    /** Microseconds since the epoch, midnight, January 1, 1970 UTC. */
    #[link_name = "?JS_Now@@YA_JXZ"]
    pub fn JS_Now() -> i64;
    /** Don't want to export data, so provide accessors for non-inline Values. */
    #[link_name = "?JS_GetNaNValue@@YA?AVValue@JS@@PEAUJSContext@@@Z"]
    pub fn JS_GetNaNValue(cx: *mut JSContext) -> Value;
    #[link_name =
          "?JS_GetNegativeInfinityValue@@YA?AVValue@JS@@PEAUJSContext@@@Z"]
    pub fn JS_GetNegativeInfinityValue(cx: *mut JSContext) -> Value;
    #[link_name =
          "?JS_GetPositiveInfinityValue@@YA?AVValue@JS@@PEAUJSContext@@@Z"]
    pub fn JS_GetPositiveInfinityValue(cx: *mut JSContext) -> Value;
    #[link_name = "?JS_GetEmptyStringValue@@YA?AVValue@JS@@PEAUJSContext@@@Z"]
    pub fn JS_GetEmptyStringValue(cx: *mut JSContext) -> Value;
    #[link_name = "?JS_GetEmptyString@@YAPEAVJSString@@PEAUJSRuntime@@@Z"]
    pub fn JS_GetEmptyString(rt: *mut JSRuntime) -> *mut JSString;
    #[link_name =
          "?JS_ValueToObject@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@V?$MutableHandle@PEAVJSObject@@@3@@Z"]
    pub fn JS_ValueToObject(cx: *mut JSContext, v: HandleValue,
                            objp: MutableHandleObject) -> bool;
    #[link_name =
          "?JS_ValueToFunction@@YAPEAVJSFunction@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_ValueToFunction(cx: *mut JSContext, v: HandleValue)
     -> *mut JSFunction;
    #[link_name =
          "?JS_ValueToConstructor@@YAPEAVJSFunction@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_ValueToConstructor(cx: *mut JSContext, v: HandleValue)
     -> *mut JSFunction;
    #[link_name =
          "?JS_ValueToSource@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_ValueToSource(cx: *mut JSContext, v: Handle<Value>)
     -> *mut JSString;
    #[link_name = "?JS_DoubleIsInt32@@YA_NNPEAH@Z"]
    pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
    #[link_name =
          "?JS_TypeOfValue@@YA?AW4JSType@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_TypeOfValue(cx: *mut JSContext, v: Handle<Value>) -> JSType;
    #[link_name =
          "?JS_StrictlyEqual@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@1PEA_N@Z"]
    pub fn JS_StrictlyEqual(cx: *mut JSContext, v1: Handle<Value>,
                            v2: Handle<Value>, equal: *mut bool) -> bool;
    #[link_name =
          "?JS_LooselyEqual@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@1PEA_N@Z"]
    pub fn JS_LooselyEqual(cx: *mut JSContext, v1: Handle<Value>,
                           v2: Handle<Value>, equal: *mut bool) -> bool;
    #[link_name =
          "?JS_SameValue@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@1PEA_N@Z"]
    pub fn JS_SameValue(cx: *mut JSContext, v1: Handle<Value>,
                        v2: Handle<Value>, same: *mut bool) -> bool;
    /** True iff fun is the global eval function. */
    #[link_name = "?JS_IsBuiltinEvalFunction@@YA_NPEAVJSFunction@@@Z"]
    pub fn JS_IsBuiltinEvalFunction(fun: *mut JSFunction) -> bool;
    /** True iff fun is the Function constructor. */
    #[link_name = "?JS_IsBuiltinFunctionConstructor@@YA_NPEAVJSFunction@@@Z"]
    pub fn JS_IsBuiltinFunctionConstructor(fun: *mut JSFunction) -> bool;
    /************************************************************************/
    #[link_name = "?JS_NewRuntime@@YAPEAUJSRuntime@@IIPEAU1@@Z"]
    pub fn JS_NewRuntime(maxbytes: u32, maxNurseryBytes: u32,
                         parentRuntime: *mut JSRuntime) -> *mut JSRuntime;
    #[link_name = "?JS_DestroyRuntime@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_DestroyRuntime(rt: *mut JSRuntime);
    /**
 * The embedding can specify a time function that will be used in some
 * situations.  The function can return the time however it likes; but
 * the norm is to return times in units of milliseconds since an
 * arbitrary, but consistent, epoch.  If the time function is not set,
 * a built-in default will be used.
 */
    #[link_name = "?JS_SetCurrentEmbedderTimeFunction@@YAXP6ANXZ@Z"]
    pub fn JS_SetCurrentEmbedderTimeFunction(timeFn:
                                                 JS_CurrentEmbedderTimeFunction);
    /**
 * Return the time as computed using the current time function, or a
 * suitable default if one has not been set.
 */
    #[link_name = "?JS_GetCurrentEmbedderTime@@YANXZ"]
    pub fn JS_GetCurrentEmbedderTime() -> f64;
    #[link_name = "?JS_GetRuntimePrivate@@YAPEAXPEAUJSRuntime@@@Z"]
    pub fn JS_GetRuntimePrivate(rt: *mut JSRuntime)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_GetRuntime@@YAPEAUJSRuntime@@PEAUJSContext@@@Z"]
    pub fn JS_GetRuntime(cx: *mut JSContext) -> *mut JSRuntime;
    #[link_name = "?JS_GetParentRuntime@@YAPEAUJSRuntime@@PEAU1@@Z"]
    pub fn JS_GetParentRuntime(rt: *mut JSRuntime) -> *mut JSRuntime;
    #[link_name = "?JS_SetRuntimePrivate@@YAXPEAUJSRuntime@@PEAX@Z"]
    pub fn JS_SetRuntimePrivate(rt: *mut JSRuntime,
                                data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_BeginRequest@@YAXPEAUJSContext@@@Z"]
    pub fn JS_BeginRequest(cx: *mut JSContext);
    #[link_name = "?JS_EndRequest@@YAXPEAUJSContext@@@Z"]
    pub fn JS_EndRequest(cx: *mut JSContext);
    #[link_name = "?JS_SetFutexCanWait@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_SetFutexCanWait(rt: *mut JSRuntime);
    #[link_name =
          "?JS_SetContextCallback@@YAXPEAUJSRuntime@@P6A_NPEAUJSContext@@IPEAX@Z2@Z"]
    pub fn JS_SetContextCallback(rt: *mut JSRuntime,
                                 cxCallback: JSContextCallback,
                                 data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_NewContext@@YAPEAUJSContext@@PEAUJSRuntime@@_K@Z"]
    pub fn JS_NewContext(rt: *mut JSRuntime, stackChunkSize: usize)
     -> *mut JSContext;
    #[link_name = "?JS_DestroyContext@@YAXPEAUJSContext@@@Z"]
    pub fn JS_DestroyContext(cx: *mut JSContext);
    #[link_name = "?JS_DestroyContextNoGC@@YAXPEAUJSContext@@@Z"]
    pub fn JS_DestroyContextNoGC(cx: *mut JSContext);
    #[link_name = "?JS_GetContextPrivate@@YAPEAXPEAUJSContext@@@Z"]
    pub fn JS_GetContextPrivate(cx: *mut JSContext)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_SetContextPrivate@@YAXPEAUJSContext@@PEAX@Z"]
    pub fn JS_SetContextPrivate(cx: *mut JSContext,
                                data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_GetSecondContextPrivate@@YAPEAXPEAUJSContext@@@Z"]
    pub fn JS_GetSecondContextPrivate(cx: *mut JSContext)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_SetSecondContextPrivate@@YAXPEAUJSContext@@PEAX@Z"]
    pub fn JS_SetSecondContextPrivate(cx: *mut JSContext,
                                      data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_ContextIterator@@YAPEAUJSContext@@PEAUJSRuntime@@PEAPEAU1@@Z"]
    pub fn JS_ContextIterator(rt: *mut JSRuntime, iterp: *mut *mut JSContext)
     -> *mut JSContext;
    #[link_name = "?JS_GetVersion@@YA?AW4JSVersion@@PEAUJSContext@@@Z"]
    pub fn JS_GetVersion(cx: *mut JSContext) -> JSVersion;
    /**
 * Mutate the version on the compartment. This is generally discouraged, but
 * necessary to support the version mutation in the js and xpc shell command
 * set.
 *
 * It would be nice to put this in jsfriendapi, but the linkage requirements
 * of the shells make that impossible.
 */
    #[link_name =
          "?JS_SetVersionForCompartment@@YAXPEAUJSCompartment@@W4JSVersion@@@Z"]
    pub fn JS_SetVersionForCompartment(compartment: *mut JSCompartment,
                                       version: JSVersion);
    #[link_name = "?JS_VersionToString@@YAPEBDW4JSVersion@@@Z"]
    pub fn JS_VersionToString(version: JSVersion)
     -> *const ::std::os::raw::c_char;
    #[link_name = "?JS_StringToVersion@@YA?AW4JSVersion@@PEBD@Z"]
    pub fn JS_StringToVersion(string: *const ::std::os::raw::c_char)
     -> JSVersion;
    #[link_name =
          "?RuntimeOptionsRef@JS@@YAAEAVRuntimeOptions@1@PEAUJSRuntime@@@Z"]
    pub fn RuntimeOptionsRef(rt: *mut JSRuntime) -> *mut RuntimeOptions;
    #[link_name =
          "?RuntimeOptionsRef@JS@@YAAEAVRuntimeOptions@1@PEAUJSContext@@@Z"]
    pub fn RuntimeOptionsRef1(cx: *mut JSContext) -> *mut RuntimeOptions;
    #[link_name =
          "?ContextOptionsRef@JS@@YAAEAVContextOptions@1@PEAUJSContext@@@Z"]
    pub fn ContextOptionsRef(cx: *mut JSContext) -> *mut ContextOptions;
    #[link_name = "?JS_GetImplementationVersion@@YAPEBDXZ"]
    pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
    #[link_name =
          "?JS_SetDestroyCompartmentCallback@@YAXPEAUJSRuntime@@P6AXPEAUJSFreeOp@@PEAUJSCompartment@@@Z@Z"]
    pub fn JS_SetDestroyCompartmentCallback(rt: *mut JSRuntime,
                                            callback:
                                                JSDestroyCompartmentCallback);
    #[link_name =
          "?JS_SetSizeOfIncludingThisCompartmentCallback@@YAXPEAUJSRuntime@@P6A_KP6A_KPEBX@ZPEAUJSCompartment@@@Z@Z"]
    pub fn JS_SetSizeOfIncludingThisCompartmentCallback(rt: *mut JSRuntime,
                                                        callback:
                                                            JSSizeOfIncludingThisCompartmentCallback);
    #[link_name =
          "?JS_SetDestroyZoneCallback@@YAXPEAUJSRuntime@@P6AXPEAUZone@JS@@@Z@Z"]
    pub fn JS_SetDestroyZoneCallback(rt: *mut JSRuntime,
                                     callback: JSZoneCallback);
    #[link_name =
          "?JS_SetSweepZoneCallback@@YAXPEAUJSRuntime@@P6AXPEAUZone@JS@@@Z@Z"]
    pub fn JS_SetSweepZoneCallback(rt: *mut JSRuntime,
                                   callback: JSZoneCallback);
    #[link_name =
          "?JS_SetCompartmentNameCallback@@YAXPEAUJSRuntime@@P6AX0PEAUJSCompartment@@PEAD_K@Z@Z"]
    pub fn JS_SetCompartmentNameCallback(rt: *mut JSRuntime,
                                         callback: JSCompartmentNameCallback);
    #[link_name =
          "?JS_SetWrapObjectCallbacks@@YAXPEAUJSRuntime@@PEBUJSWrapObjectCallbacks@@@Z"]
    pub fn JS_SetWrapObjectCallbacks(rt: *mut JSRuntime,
                                     callbacks: *const JSWrapObjectCallbacks);
    #[link_name = "?JS_SetCompartmentPrivate@@YAXPEAUJSCompartment@@PEAX@Z"]
    pub fn JS_SetCompartmentPrivate(compartment: *mut JSCompartment,
                                    data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_GetCompartmentPrivate@@YAPEAXPEAUJSCompartment@@@Z"]
    pub fn JS_GetCompartmentPrivate(compartment: *mut JSCompartment)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_SetZoneUserData@@YAXPEAUZone@JS@@PEAX@Z"]
    pub fn JS_SetZoneUserData(zone: *mut Zone,
                              data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_GetZoneUserData@@YAPEAXPEAUZone@JS@@@Z"]
    pub fn JS_GetZoneUserData(zone: *mut Zone) -> *mut ::std::os::raw::c_void;
    #[link_name =
          "?JS_WrapObject@@YA_NPEAUJSContext@@V?$MutableHandle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_WrapObject(cx: *mut JSContext, objp: MutableHandleObject)
     -> bool;
    #[link_name =
          "?JS_WrapValue@@YA_NPEAUJSContext@@V?$MutableHandle@VValue@JS@@@JS@@@Z"]
    pub fn JS_WrapValue(cx: *mut JSContext, vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_TransplantObject@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_TransplantObject(cx: *mut JSContext, origobj: HandleObject,
                               target: HandleObject) -> *mut JSObject;
    #[link_name =
          "?JS_RefreshCrossCompartmentWrappers@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut JSContext,
                                              obj: Handle<*mut JSObject>)
     -> bool;
    /** NB: This API is infallible; a nullptr return value does not indicate error. */
    #[link_name =
          "?JS_EnterCompartment@@YAPEAUJSCompartment@@PEAUJSContext@@PEAVJSObject@@@Z"]
    pub fn JS_EnterCompartment(cx: *mut JSContext, target: *mut JSObject)
     -> *mut JSCompartment;
    #[link_name =
          "?JS_LeaveCompartment@@YAXPEAUJSContext@@PEAUJSCompartment@@@Z"]
    pub fn JS_LeaveCompartment(cx: *mut JSContext,
                               oldCompartment: *mut JSCompartment);
    /**
 * This function calls |compartmentCallback| on every compartment. Beware that
 * there is no guarantee that the compartment will survive after the callback
 * returns. Also, barriers are disabled via the TraceSession.
 */
    #[link_name =
          "?JS_IterateCompartments@@YAXPEAUJSRuntime@@PEAXP6AX01PEAUJSCompartment@@@Z@Z"]
    pub fn JS_IterateCompartments(rt: *mut JSRuntime,
                                  data: *mut ::std::os::raw::c_void,
                                  compartmentCallback:
                                      JSIterateCompartmentCallback);
    /**
 * Initialize standard JS class constructors, prototypes, and any top-level
 * functions and constants associated with the standard classes (e.g. isNaN
 * for Number).
 *
 * NB: This sets cx's global object to obj if it was null.
 */
    #[link_name =
          "?JS_InitStandardClasses@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_InitStandardClasses(cx: *mut JSContext,
                                  obj: Handle<*mut JSObject>) -> bool;
    /**
 * Resolve id, which must contain either a string or an int, to a standard
 * class name in obj if possible, defining the class's constructor and/or
 * prototype and storing true in *resolved.  If id does not name a standard
 * class or a top-level property induced by initializing a standard class,
 * store false in *resolved and just return true.  Return false on error,
 * as usual for bool result-typed API entry points.
 *
 * This API can be called directly from a global object class's resolve op,
 * to define standard classes lazily.  The class's enumerate op should call
 * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
 * loops any classes not yet resolved lazily.
 */
    #[link_name =
          "?JS_ResolveStandardClass@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@PEA_N@Z"]
    pub fn JS_ResolveStandardClass(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, resolved: *mut bool) -> bool;
    #[link_name =
          "?JS_MayResolveStandardClass@@YA_NAEBUJSAtomState@@Ujsid@@PEAVJSObject@@@Z"]
    pub fn JS_MayResolveStandardClass(names: *const JSAtomState, id: jsid,
                                      maybeObj: *mut JSObject) -> bool;
    #[link_name =
          "?JS_EnumerateStandardClasses@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_EnumerateStandardClasses(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "?JS_GetClassObject@@YA_NPEAUJSContext@@W4JSProtoKey@@V?$MutableHandle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetClassObject(cx: *mut JSContext, key: JSProtoKey,
                             objp: MutableHandle<*mut JSObject>) -> bool;
    #[link_name =
          "?JS_GetClassPrototype@@YA_NPEAUJSContext@@W4JSProtoKey@@V?$MutableHandle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetClassPrototype(cx: *mut JSContext, key: JSProtoKey,
                                objp: MutableHandle<*mut JSObject>) -> bool;
    #[link_name =
          "?IdentifyStandardInstance@JS@@YA?AW4JSProtoKey@@PEAVJSObject@@@Z"]
    pub fn IdentifyStandardInstance(obj: *mut JSObject) -> JSProtoKey;
    #[link_name =
          "?IdentifyStandardPrototype@JS@@YA?AW4JSProtoKey@@PEAVJSObject@@@Z"]
    pub fn IdentifyStandardPrototype(obj: *mut JSObject) -> JSProtoKey;
    #[link_name =
          "?IdentifyStandardInstanceOrPrototype@JS@@YA?AW4JSProtoKey@@PEAVJSObject@@@Z"]
    pub fn IdentifyStandardInstanceOrPrototype(obj: *mut JSObject)
     -> JSProtoKey;
    #[link_name =
          "?IdentifyStandardConstructor@JS@@YA?AW4JSProtoKey@@PEAVJSObject@@@Z"]
    pub fn IdentifyStandardConstructor(obj: *mut JSObject) -> JSProtoKey;
    #[link_name =
          "?ProtoKeyToId@JS@@YAXPEAUJSContext@@W4JSProtoKey@@V?$MutableHandle@Ujsid@@@1@@Z"]
    pub fn ProtoKeyToId(cx: *mut JSContext, key: JSProtoKey,
                        idp: MutableHandleId);
    #[link_name =
          "?JS_IdToProtoKey@@YA?AW4JSProtoKey@@PEAUJSContext@@V?$Handle@Ujsid@@@JS@@@Z"]
    pub fn JS_IdToProtoKey(cx: *mut JSContext, id: HandleId) -> JSProtoKey;
    /**
 * Returns the original value of |Function.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "?JS_GetFunctionPrototype@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetFunctionPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Object.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "?JS_GetObjectPrototype@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetObjectPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Array.prototype| from the global object in
 * which |forObj| was created.
 */
    #[link_name =
          "?JS_GetArrayPrototype@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetArrayPrototype(cx: *mut JSContext, forObj: HandleObject)
     -> *mut JSObject;
    /**
 * Returns the original value of |Error.prototype| from the global
 * object of the current compartment of cx.
 */
    #[link_name = "?JS_GetErrorPrototype@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn JS_GetErrorPrototype(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the %IteratorPrototype% object that all built-in iterator prototype
 * chains go through for the global object of the current compartment of cx.
 */
    #[link_name =
          "?JS_GetIteratorPrototype@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn JS_GetIteratorPrototype(cx: *mut JSContext) -> *mut JSObject;
    #[link_name =
          "?JS_GetGlobalForObject@@YAPEAVJSObject@@PEAUJSContext@@PEAV1@@Z"]
    pub fn JS_GetGlobalForObject(cx: *mut JSContext, obj: *mut JSObject)
     -> *mut JSObject;
    #[link_name = "?JS_IsGlobalObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsGlobalObject(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_GlobalLexicalScope@@YAPEAVJSObject@@PEAV1@@Z"]
    pub fn JS_GlobalLexicalScope(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?JS_HasExtensibleLexicalScope@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_HasExtensibleLexicalScope(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_ExtensibleLexicalScope@@YAPEAVJSObject@@PEAV1@@Z"]
    pub fn JS_ExtensibleLexicalScope(obj: *mut JSObject) -> *mut JSObject;
    /**
 * May return nullptr, if |c| never had a global (e.g. the atoms compartment),
 * or if |c|'s global has been collected.
 */
    #[link_name =
          "?JS_GetGlobalForCompartmentOrNull@@YAPEAVJSObject@@PEAUJSContext@@PEAUJSCompartment@@@Z"]
    pub fn JS_GetGlobalForCompartmentOrNull(cx: *mut JSContext,
                                            c: *mut JSCompartment)
     -> *mut JSObject;
    #[link_name =
          "?CurrentGlobalOrNull@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn CurrentGlobalOrNull(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
 * given global.
 */
    #[link_name =
          "?JS_InitReflectParse@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_InitReflectParse(cx: *mut JSContext, global: HandleObject)
     -> bool;
    /**
 * Add various profiling-related functions as properties of the given object.
 * Defined in builtin/Profilers.cpp.
 */
    #[link_name =
          "?JS_DefineProfilingFunctions@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_DefineProfilingFunctions(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "?JS_DefineDebuggerObject@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_DefineDebuggerObject(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name = "?JS_malloc@@YAPEAXPEAUJSContext@@_K@Z"]
    pub fn JS_malloc(cx: *mut JSContext, nbytes: usize)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_realloc@@YAPEAXPEAUJSContext@@PEAX_K2@Z"]
    pub fn JS_realloc(cx: *mut JSContext, p: *mut ::std::os::raw::c_void,
                      oldBytes: usize, newBytes: usize)
     -> *mut ::std::os::raw::c_void;
    /**
 * A wrapper for js_free(p) that may delay js_free(p) invocation as a
 * performance optimization.
 * cx may be nullptr.
 */
    #[link_name = "?JS_free@@YAXPEAUJSContext@@PEAX@Z"]
    pub fn JS_free(cx: *mut JSContext, p: *mut ::std::os::raw::c_void);
    /**
 * A wrapper for js_free(p) that may delay js_free(p) invocation as a
 * performance optimization as specified by the given JSFreeOp instance.
 */
    #[link_name = "?JS_freeop@@YAXPEAUJSFreeOp@@PEAX@Z"]
    pub fn JS_freeop(fop: *mut JSFreeOp, p: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_GetDefaultFreeOp@@YAPEAUJSFreeOp@@PEAUJSRuntime@@@Z"]
    pub fn JS_GetDefaultFreeOp(rt: *mut JSRuntime) -> *mut JSFreeOp;
    #[link_name = "?JS_updateMallocCounter@@YAXPEAUJSContext@@_K@Z"]
    pub fn JS_updateMallocCounter(cx: *mut JSContext, nbytes: usize);
    #[link_name = "?JS_strdup@@YAPEADPEAUJSContext@@PEBD@Z"]
    pub fn JS_strdup(cx: *mut JSContext, s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    /** Duplicate a string.  Does not report an error on failure. */
    #[link_name = "?JS_strdup@@YAPEADPEAUJSRuntime@@PEBD@Z"]
    pub fn JS_strdup1(rt: *mut JSRuntime, s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    /**
 * Register externally maintained GC roots.
 *
 * traceOp: the trace operation. For each root the implementation should call
 *          JS_CallTracer whenever the root contains a traceable thing.
 * data:    the data argument to pass to each invocation of traceOp.
 */
    #[link_name =
          "?JS_AddExtraGCRootsTracer@@YA_NPEAUJSRuntime@@P6AXPEAVJSTracer@@PEAX@Z2@Z"]
    pub fn JS_AddExtraGCRootsTracer(rt: *mut JSRuntime,
                                    traceOp: JSTraceDataOp,
                                    data: *mut ::std::os::raw::c_void)
     -> bool;
    /** Undo a call to JS_AddExtraGCRootsTracer. */
    #[link_name =
          "?JS_RemoveExtraGCRootsTracer@@YAXPEAUJSRuntime@@P6AXPEAVJSTracer@@PEAX@Z2@Z"]
    pub fn JS_RemoveExtraGCRootsTracer(rt: *mut JSRuntime,
                                       traceOp: JSTraceDataOp,
                                       data: *mut ::std::os::raw::c_void);
    #[link_name = "?JS_GC@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_GC(rt: *mut JSRuntime);
    #[link_name = "?JS_MaybeGC@@YAXPEAUJSContext@@@Z"]
    pub fn JS_MaybeGC(cx: *mut JSContext);
    #[link_name =
          "?JS_SetGCCallback@@YAXPEAUJSRuntime@@P6AX0W4JSGCStatus@@PEAX@Z2@Z"]
    pub fn JS_SetGCCallback(rt: *mut JSRuntime, cb: JSGCCallback,
                            data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_SetObjectsTenuredCallback@@YAXPEAUJSRuntime@@P6AX0PEAX@Z1@Z"]
    pub fn JS_SetObjectsTenuredCallback(rt: *mut JSRuntime,
                                        cb: JSObjectsTenuredCallback,
                                        data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_AddFinalizeCallback@@YA_NPEAUJSRuntime@@P6AXPEAUJSFreeOp@@W4JSFinalizeStatus@@_NPEAX@Z4@Z"]
    pub fn JS_AddFinalizeCallback(rt: *mut JSRuntime, cb: JSFinalizeCallback,
                                  data: *mut ::std::os::raw::c_void) -> bool;
    #[link_name =
          "?JS_RemoveFinalizeCallback@@YAXPEAUJSRuntime@@P6AXPEAUJSFreeOp@@W4JSFinalizeStatus@@_NPEAX@Z@Z"]
    pub fn JS_RemoveFinalizeCallback(rt: *mut JSRuntime,
                                     cb: JSFinalizeCallback);
    #[link_name =
          "?JS_AddWeakPointerZoneGroupCallback@@YA_NPEAUJSRuntime@@P6AX0PEAX@Z1@Z"]
    pub fn JS_AddWeakPointerZoneGroupCallback(rt: *mut JSRuntime,
                                              cb:
                                                  JSWeakPointerZoneGroupCallback,
                                              data:
                                                  *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?JS_RemoveWeakPointerZoneGroupCallback@@YAXPEAUJSRuntime@@P6AX0PEAX@Z@Z"]
    pub fn JS_RemoveWeakPointerZoneGroupCallback(rt: *mut JSRuntime,
                                                 cb:
                                                     JSWeakPointerZoneGroupCallback);
    #[link_name =
          "?JS_AddWeakPointerCompartmentCallback@@YA_NPEAUJSRuntime@@P6AX0PEAUJSCompartment@@PEAX@Z2@Z"]
    pub fn JS_AddWeakPointerCompartmentCallback(rt: *mut JSRuntime,
                                                cb:
                                                    JSWeakPointerCompartmentCallback,
                                                data:
                                                    *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?JS_RemoveWeakPointerCompartmentCallback@@YAXPEAUJSRuntime@@P6AX0PEAUJSCompartment@@PEAX@Z@Z"]
    pub fn JS_RemoveWeakPointerCompartmentCallback(rt: *mut JSRuntime,
                                                   cb:
                                                       JSWeakPointerCompartmentCallback);
    #[link_name =
          "?JS_UpdateWeakPointerAfterGC@@YAXPEAV?$Heap@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_UpdateWeakPointerAfterGC(objp: *mut Heap<*mut JSObject>);
    #[link_name =
          "?JS_UpdateWeakPointerAfterGCUnbarriered@@YAXPEAPEAVJSObject@@@Z"]
    pub fn JS_UpdateWeakPointerAfterGCUnbarriered(objp: *mut *mut JSObject);
    #[link_name = "?JS_SetGCParameter@@YAXPEAUJSRuntime@@W4JSGCParamKey@@I@Z"]
    pub fn JS_SetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey,
                             value: u32);
    #[link_name = "?JS_GetGCParameter@@YAIPEAUJSRuntime@@W4JSGCParamKey@@@Z"]
    pub fn JS_GetGCParameter(rt: *mut JSRuntime, key: JSGCParamKey) -> u32;
    #[link_name =
          "?JS_SetGCParametersBasedOnAvailableMemory@@YAXPEAUJSRuntime@@I@Z"]
    pub fn JS_SetGCParametersBasedOnAvailableMemory(rt: *mut JSRuntime,
                                                    availMem: u32);
    /**
 * Create a new JSString whose chars member refers to external memory, i.e.,
 * memory requiring application-specific finalization.
 */
    #[link_name =
          "?JS_NewExternalString@@YAPEAVJSString@@PEAUJSContext@@PEB_S_KPEBUJSStringFinalizer@@@Z"]
    pub fn JS_NewExternalString(cx: *mut JSContext,
                                chars: *const ::std::os::raw::c_ushort,
                                length: usize, fin: *const JSStringFinalizer)
     -> *mut JSString;
    /**
 * Return whether 'str' was created with JS_NewExternalString or
 * JS_NewExternalStringWithClosure.
 */
    #[link_name = "?JS_IsExternalString@@YA_NPEAVJSString@@@Z"]
    pub fn JS_IsExternalString(str: *mut JSString) -> bool;
    /**
 * Return the 'fin' arg passed to JS_NewExternalString.
 */
    #[link_name =
          "?JS_GetExternalStringFinalizer@@YAPEBUJSStringFinalizer@@PEAVJSString@@@Z"]
    pub fn JS_GetExternalStringFinalizer(str: *mut JSString)
     -> *const JSStringFinalizer;
    /**
 * Set the size of the native stack that should not be exceed. To disable
 * stack size checking pass 0.
 *
 * SpiderMonkey allows for a distinction between system code (such as GCs, which
 * may incidentally be triggered by script but are not strictly performed on
 * behalf of such script), trusted script (as determined by JS_SetTrustedPrincipals),
 * and untrusted script. Each kind of code may have a different stack quota,
 * allowing embedders to keep higher-priority machinery running in the face of
 * scripted stack exhaustion by something else.
 *
 * The stack quotas for each kind of code should be monotonically descending,
 * and may be specified with this function. If 0 is passed for a given kind
 * of code, it defaults to the value of the next-highest-priority kind.
 *
 * This function may only be called immediately after the runtime is initialized
 * and before any code is executed and/or interrupts requested.
 */
    #[link_name = "?JS_SetNativeStackQuota@@YAXPEAUJSRuntime@@_K11@Z"]
    pub fn JS_SetNativeStackQuota(cx: *mut JSRuntime,
                                  systemCodeStackSize: usize,
                                  trustedScriptStackSize: usize,
                                  untrustedScriptStackSize: usize);
    /************************************************************************/
    #[link_name =
          "?JS_ValueToId@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@V?$MutableHandle@Ujsid@@@3@@Z"]
    pub fn JS_ValueToId(cx: *mut JSContext, v: HandleValue,
                        idp: MutableHandleId) -> bool;
    #[link_name =
          "?JS_StringToId@@YA_NPEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@V?$MutableHandle@Ujsid@@@3@@Z"]
    pub fn JS_StringToId(cx: *mut JSContext, s: HandleString,
                         idp: MutableHandleId) -> bool;
    #[link_name =
          "?JS_IdToValue@@YA_NPEAUJSContext@@Ujsid@@V?$MutableHandle@VValue@JS@@@JS@@@Z"]
    pub fn JS_IdToValue(cx: *mut JSContext, id: jsid,
                        vp: MutableHandle<Value>) -> bool;
    /**
 * Convert obj to a primitive value. On success, store the result in vp and
 * return true.
 *
 * The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_VOID (no
 * hint).
 *
 * Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType]).
 */
    #[link_name =
          "?ToPrimitive@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@W4JSType@@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn ToPrimitive(cx: *mut JSContext, obj: HandleObject, hint: JSType,
                       vp: MutableHandleValue) -> bool;
    /**
 * If args.get(0) is one of the strings "string", "number", or "default", set
 * *result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_VOID accordingly and
 * return true. Otherwise, return false with a TypeError pending.
 *
 * This can be useful in implementing a @@toPrimitive method.
 */
    #[link_name =
          "?GetFirstArgumentAsTypeHint@JS@@YA_NPEAUJSContext@@VCallArgs@1@PEAW4JSType@@@Z"]
    pub fn GetFirstArgumentAsTypeHint(cx: *mut JSContext, args: CallArgs,
                                      result: *mut JSType) -> bool;
    #[link_name =
          "?JS_PropertyStub@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_PropertyStub(cx: *mut JSContext, obj: HandleObject,
                           id: HandleId, vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_StrictPropertyStub@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$MutableHandle@VValue@JS@@@3@AEAVObjectOpResult@3@@Z"]
    pub fn JS_StrictPropertyStub(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, vp: MutableHandleValue,
                                 result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "?JS_InitClass@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1PEBUJSClass@@P6A_N0IPEAVValue@4@@ZIPEBUJSPropertySpec@@PEBUJSFunctionSpec@@56@Z"]
    pub fn JS_InitClass(cx: *mut JSContext, obj: HandleObject,
                        parent_proto: HandleObject, clasp: *const JSClass,
                        constructor: JSNative, nargs: ::std::os::raw::c_uint,
                        ps: *const JSPropertySpec, fs: *const JSFunctionSpec,
                        static_ps: *const JSPropertySpec,
                        static_fs: *const JSFunctionSpec) -> *mut JSObject;
    /**
 * Set up ctor.prototype = proto and proto.constructor = ctor with the
 * right property flags.
 */
    #[link_name =
          "?JS_LinkConstructorAndPrototype@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_LinkConstructorAndPrototype(cx: *mut JSContext,
                                          ctor: Handle<*mut JSObject>,
                                          proto: Handle<*mut JSObject>)
     -> bool;
    #[link_name = "?JS_GetClass@@YAPEBUJSClass@@PEAVJSObject@@@Z"]
    pub fn JS_GetClass(obj: *mut JSObject) -> *const JSClass;
    #[link_name =
          "?JS_InstanceOf@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBUJSClass@@PEAVCallArgs@3@@Z"]
    pub fn JS_InstanceOf(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                         clasp: *const JSClass, args: *mut CallArgs) -> bool;
    #[link_name =
          "?JS_HasInstance@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@VValue@JS@@@3@PEA_N@Z"]
    pub fn JS_HasInstance(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                          v: Handle<Value>, bp: *mut bool) -> bool;
    #[link_name = "?JS_GetPrivate@@YAPEAXPEAVJSObject@@@Z"]
    pub fn JS_GetPrivate(obj: *mut JSObject) -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_SetPrivate@@YAXPEAVJSObject@@PEAX@Z"]
    pub fn JS_SetPrivate(obj: *mut JSObject,
                         data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_GetInstancePrivate@@YAPEAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBUJSClass@@PEAVCallArgs@3@@Z"]
    pub fn JS_GetInstancePrivate(cx: *mut JSContext,
                                 obj: Handle<*mut JSObject>,
                                 clasp: *const JSClass, args: *mut CallArgs)
     -> *mut ::std::os::raw::c_void;
    #[link_name =
          "?JS_GetConstructor@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetConstructor(cx: *mut JSContext, proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    #[link_name =
          "?CompartmentCreationOptionsRef@JS@@YAAEBVCompartmentCreationOptions@1@PEAUJSCompartment@@@Z"]
    pub fn CompartmentCreationOptionsRef(compartment: *mut JSCompartment)
     -> *const CompartmentCreationOptions;
    #[link_name =
          "?CompartmentCreationOptionsRef@JS@@YAAEBVCompartmentCreationOptions@1@PEAVJSObject@@@Z"]
    pub fn CompartmentCreationOptionsRef1(obj: *mut JSObject)
     -> *const CompartmentCreationOptions;
    #[link_name =
          "?CompartmentCreationOptionsRef@JS@@YAAEBVCompartmentCreationOptions@1@PEAUJSContext@@@Z"]
    pub fn CompartmentCreationOptionsRef2(cx: *mut JSContext)
     -> *const CompartmentCreationOptions;
    #[link_name =
          "?CompartmentBehaviorsRef@JS@@YAAEAVCompartmentBehaviors@1@PEAUJSCompartment@@@Z"]
    pub fn CompartmentBehaviorsRef(compartment: *mut JSCompartment)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "?CompartmentBehaviorsRef@JS@@YAAEAVCompartmentBehaviors@1@PEAVJSObject@@@Z"]
    pub fn CompartmentBehaviorsRef1(obj: *mut JSObject)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "?CompartmentBehaviorsRef@JS@@YAAEAVCompartmentBehaviors@1@PEAUJSContext@@@Z"]
    pub fn CompartmentBehaviorsRef2(cx: *mut JSContext)
     -> *mut CompartmentBehaviors;
    #[link_name =
          "?JS_NewGlobalObject@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@PEAUJSPrincipals@@W4OnNewGlobalHookOption@JS@@AEBVCompartmentOptions@6@@Z"]
    pub fn JS_NewGlobalObject(cx: *mut JSContext, clasp: *const JSClass,
                              principals: *mut JSPrincipals,
                              hookOption: OnNewGlobalHookOption,
                              options: *const CompartmentOptions)
     -> *mut JSObject;
    /**
 * Spidermonkey does not have a good way of keeping track of what compartments should be marked on
 * their own. We can mark the roots unconditionally, but marking GC things only relevant in live
 * compartments is hard. To mitigate this, we create a static trace hook, installed on each global
 * object, from which we can be sure the compartment is relevant, and mark it.
 *
 * It is still possible to specify custom trace hooks for global object classes. They can be
 * provided via the CompartmentOptions passed to JS_NewGlobalObject.
 */
    #[link_name =
          "?JS_GlobalObjectTraceHook@@YAXPEAVJSTracer@@PEAVJSObject@@@Z"]
    pub fn JS_GlobalObjectTraceHook(trc: *mut JSTracer,
                                    global: *mut JSObject);
    #[link_name =
          "?JS_FireOnNewGlobalObject@@YAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_FireOnNewGlobalObject(cx: *mut JSContext, global: HandleObject);
    #[link_name =
          "?JS_NewObject@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@@Z"]
    pub fn JS_NewObject(cx: *mut JSContext, clasp: *const JSClass)
     -> *mut JSObject;
    #[link_name = "?JS_IsNative@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsNative(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_GetObjectRuntime@@YAPEAUJSRuntime@@PEAVJSObject@@@Z"]
    pub fn JS_GetObjectRuntime(obj: *mut JSObject) -> *mut JSRuntime;
    /**
 * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
 * proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].
 */
    #[link_name =
          "?JS_NewObjectWithGivenProto@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewObjectWithGivenProto(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    /** Creates a new plain object, like `new Object()`, with Object.prototype as [[Prototype]]. */
    #[link_name = "?JS_NewPlainObject@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn JS_NewPlainObject(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Freeze obj, and all objects it refers to, recursively. This will not recurse
 * through non-extensible objects, on the assumption that those are already
 * deep-frozen.
 */
    #[link_name =
          "?JS_DeepFreezeObject@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_DeepFreezeObject(cx: *mut JSContext, obj: Handle<*mut JSObject>)
     -> bool;
    /**
 * Freezes an object; see ES5's Object.freeze(obj) method.
 */
    #[link_name =
          "?JS_FreezeObject@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_FreezeObject(cx: *mut JSContext, obj: Handle<*mut JSObject>)
     -> bool;
    #[link_name =
          "?ObjectToCompletePropertyDescriptor@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@V?$MutableHandle@UPropertyDescriptor@JS@@@1@@Z"]
    pub fn ObjectToCompletePropertyDescriptor(cx: *mut JSContext,
                                              obj: HandleObject,
                                              descriptor: HandleValue,
                                              desc:
                                                  MutableHandle<PropertyDescriptor>)
     -> bool;
    /**
 * Get the prototype of obj, storing it in result.
 *
 * Implements: ES6 [[GetPrototypeOf]] internal method.
 */
    #[link_name =
          "?JS_GetPrototype@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@PEAVJSObject@@@3@@Z"]
    pub fn JS_GetPrototype(cx: *mut JSContext, obj: HandleObject,
                           result: MutableHandleObject) -> bool;
    /**
 * Change the prototype of obj.
 *
 * Implements: ES6 [[SetPrototypeOf]] internal method.
 *
 * In cases where ES6 [[SetPrototypeOf]] returns false without an exception,
 * JS_SetPrototype throws a TypeError and returns false.
 *
 * Performance warning: JS_SetPrototype is very bad for performance. It may
 * cause compiled jit-code to be invalidated. It also causes not only obj but
 * all other objects in the same "group" as obj to be permanently deoptimized.
 * It's better to create the object with the right prototype from the start.
 */
    #[link_name =
          "?JS_SetPrototype@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_SetPrototype(cx: *mut JSContext, obj: HandleObject,
                           proto: HandleObject) -> bool;
    /**
 * Determine whether obj is extensible. Extensible objects can have new
 * properties defined on them. Inextensible objects can't, and their
 * [[Prototype]] slot is fixed as well.
 *
 * Implements: ES6 [[IsExtensible]] internal method.
 */
    #[link_name =
          "?JS_IsExtensible@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_IsExtensible(cx: *mut JSContext, obj: HandleObject,
                           extensible: *mut bool) -> bool;
    /**
 * Attempt to make |obj| non-extensible.
 *
 * Not all failures are treated as errors. See the comment on
 * JS::ObjectOpResult in js/public/Class.h.
 *
 * Implements: ES6 [[PreventExtensions]] internal method.
 */
    #[link_name =
          "?JS_PreventExtensions@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@AEAVObjectOpResult@3@@Z"]
    pub fn JS_PreventExtensions(cx: *mut JSContext, obj: HandleObject,
                                result: *mut ObjectOpResult) -> bool;
    /**
 * Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt
 * to modify it will fail.  If an error occurs during the attempt, return false
 * (with a pending exception set, depending upon the nature of the error).  If
 * no error occurs, return true with |*succeeded| set to indicate whether the
 * attempt successfully made the [[Prototype]] immutable.
 *
 * This is a nonstandard internal method.
 */
    #[link_name =
          "?JS_SetImmutablePrototype@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_SetImmutablePrototype(cx: *mut JSContext, obj: HandleObject,
                                    succeeded: *mut bool) -> bool;
    /**
 * Get a description of one of obj's own properties. If no such property exists
 * on obj, return true with desc.object() set to null.
 *
 * Implements: ES6 [[GetOwnProperty]] internal method.
 */
    #[link_name =
          "?JS_GetOwnPropertyDescriptorById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$MutableHandle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_GetOwnPropertyDescriptorById(cx: *mut JSContext,
                                           obj: HandleObject, id: HandleId,
                                           desc:
                                               MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "?JS_GetOwnPropertyDescriptor@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$MutableHandle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: HandleObject,
                                       name: *const ::std::os::raw::c_char,
                                       desc:
                                           MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "?JS_GetOwnUCPropertyDescriptor@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_SV?$MutableHandle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_GetOwnUCPropertyDescriptor(cx: *mut JSContext,
                                         obj: HandleObject,
                                         name:
                                             *const ::std::os::raw::c_ushort,
                                         desc:
                                             MutableHandle<PropertyDescriptor>)
     -> bool;
    /**
 * Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain
 * if no own property is found directly on obj. The object on which the
 * property is found is returned in desc.object(). If the property is not found
 * on the prototype chain, this returns true with desc.object() set to null.
 */
    #[link_name =
          "?JS_GetPropertyDescriptorById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$MutableHandle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_GetPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject,
                                        id: HandleId,
                                        desc:
                                            MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "?JS_GetPropertyDescriptor@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$MutableHandle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_GetPropertyDescriptor(cx: *mut JSContext, obj: HandleObject,
                                    name: *const ::std::os::raw::c_char,
                                    desc: MutableHandle<PropertyDescriptor>)
     -> bool;
    /**
 * Define a property on obj.
 *
 * This function uses JS::ObjectOpResult to indicate conditions that ES6
 * specifies as non-error failures. This is inconvenient at best, so use this
 * function only if you are implementing a proxy handler's defineProperty()
 * method. For all other purposes, use one of the many DefineProperty functions
 * below that throw an exception in all failure cases.
 *
 * Implements: ES6 [[DefineOwnProperty]] internal method.
 */
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@UPropertyDescriptor@JS@@@3@AEAVObjectOpResult@3@@Z"]
    pub fn JS_DefinePropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId,
                                 desc: Handle<PropertyDescriptor>,
                                 result: *mut ObjectOpResult) -> bool;
    /**
 * Define a property on obj, throwing a TypeError if the attempt fails.
 * This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`.
 */
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_DefinePropertyById1(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId,
                                  desc: Handle<PropertyDescriptor>) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@VValue@JS@@@3@IP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefinePropertyById2(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleValue,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@1IP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefinePropertyById3(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleObject,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@PEAVJSString@@@3@IP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefinePropertyById4(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: HandleString,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@HIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefinePropertyById5(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: i32,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@IIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefinePropertyById6(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: u32,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefinePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@NIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefinePropertyById7(cx: *mut JSContext, obj: HandleObject,
                                  id: HandleId, value: f64,
                                  attrs: ::std::os::raw::c_uint,
                                  getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$Handle@VValue@JS@@@3@IP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             value: HandleValue,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBD1IP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineProperty1(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char,
                              value: HandleObject,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$Handle@PEAVJSString@@@3@IP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineProperty2(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char,
                              value: HandleString,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDHIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineProperty3(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: i32,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDIIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineProperty4(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: u32,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDNIP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineProperty5(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char, value: f64,
                              attrs: ::std::os::raw::c_uint, getter: JSNative,
                              setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$Handle@UPropertyDescriptor@JS@@@3@AEAVObjectOpResult@3@@Z"]
    pub fn JS_DefineUCProperty(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize,
                               desc: Handle<PropertyDescriptor>,
                               result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$Handle@UPropertyDescriptor@JS@@@3@@Z"]
    pub fn JS_DefineUCProperty1(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize,
                                desc: Handle<PropertyDescriptor>) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$Handle@VValue@JS@@@3@IP6A_N0IPEAVValue@3@@Z6@Z"]
    pub fn JS_DefineUCProperty2(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleValue,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_K1IP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineUCProperty3(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleObject,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$Handle@PEAVJSString@@@3@IP6A_N0IPEAVValue@3@@Z6@Z"]
    pub fn JS_DefineUCProperty4(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: HandleString,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KHIP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineUCProperty5(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: i32,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KIIP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineUCProperty6(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: u32,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KNIP6A_N0IPEAVValue@3@@Z5@Z"]
    pub fn JS_DefineUCProperty7(cx: *mut JSContext, obj: HandleObject,
                                name: *const ::std::os::raw::c_ushort,
                                namelen: usize, value: f64,
                                attrs: ::std::os::raw::c_uint,
                                getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IV?$Handle@VValue@JS@@@3@IP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                            value: HandleValue, attrs: ::std::os::raw::c_uint,
                            getter: JSNative, setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I1IP6A_N0IPEAVValue@3@@Z3@Z"]
    pub fn JS_DefineElement1(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: HandleObject,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IV?$Handle@PEAVJSString@@@3@IP6A_N0IPEAVValue@3@@Z4@Z"]
    pub fn JS_DefineElement2(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: HandleString,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IHIP6A_N0IPEAVValue@3@@Z3@Z"]
    pub fn JS_DefineElement3(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: i32,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IIIP6A_N0IPEAVValue@3@@Z3@Z"]
    pub fn JS_DefineElement4(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: u32,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    #[link_name =
          "?JS_DefineElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@INIP6A_N0IPEAVValue@3@@Z3@Z"]
    pub fn JS_DefineElement5(cx: *mut JSContext, obj: HandleObject,
                             index: u32, value: f64,
                             attrs: ::std::os::raw::c_uint, getter: JSNative,
                             setter: JSNative) -> bool;
    /**
 * Compute the expression `id in obj`.
 *
 * If obj has an own or inherited property obj[id], set *foundp = true and
 * return true. If not, set *foundp = false and return true. On error, return
 * false with an exception pending.
 *
 * Implements: ES6 [[Has]] internal method.
 */
    #[link_name =
          "?JS_HasPropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@PEA_N@Z"]
    pub fn JS_HasPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "?JS_HasProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDPEA_N@Z"]
    pub fn JS_HasProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char,
                          foundp: *mut bool) -> bool;
    #[link_name =
          "?JS_HasUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KPEA_N@Z"]
    pub fn JS_HasUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, vp: *mut bool) -> bool;
    #[link_name =
          "?JS_HasElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IPEA_N@Z"]
    pub fn JS_HasElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         foundp: *mut bool) -> bool;
    /**
 * Determine whether obj has an own property with the key `id`.
 *
 * Implements: ES6 7.3.11 HasOwnProperty(O, P).
 */
    #[link_name =
          "?JS_HasOwnPropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@PEA_N@Z"]
    pub fn JS_HasOwnPropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "?JS_HasOwnProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDPEA_N@Z"]
    pub fn JS_HasOwnProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             foundp: *mut bool) -> bool;
    /**
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.
 *
 * Most callers don't need the `receiver` argument. Consider using
 * JS_GetProperty instead. (But if you're implementing a proxy handler's set()
 * method, it's often correct to call this function and pass the receiver
 * through.)
 *
 * Implements: ES6 [[Get]] internal method.
 */
    #[link_name =
          "?JS_ForwardGetPropertyTo@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@VValue@JS@@@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ForwardGetPropertyTo(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, receiver: HandleValue,
                                   vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ForwardGetElementTo@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I1V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ForwardGetElementTo(cx: *mut JSContext, obj: HandleObject,
                                  index: u32, receiver: HandleObject,
                                  vp: MutableHandleValue) -> bool;
    /**
 * Get the value of the property `obj[id]`, or undefined if no such property
 * exists. The result is stored in vp.
 *
 * Implements: ES6 7.3.1 Get(O, P).
 */
    #[link_name =
          "?JS_GetPropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_GetPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_GetProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_GetProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char,
                          vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_GetUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_GetUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_GetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IV?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_GetElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         vp: MutableHandleValue) -> bool;
    /**
 * Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.
 *
 * This function has a `receiver` argument that most callers don't need.
 * Consider using JS_SetProperty instead.
 *
 * Implements: ES6 [[Set]] internal method.
 */
    #[link_name =
          "?JS_ForwardSetPropertyTo@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@VValue@JS@@@3@3AEAVObjectOpResult@3@@Z"]
    pub fn JS_ForwardSetPropertyTo(cx: *mut JSContext, obj: HandleObject,
                                   id: HandleId, v: HandleValue,
                                   receiver: HandleValue,
                                   result: *mut ObjectOpResult) -> bool;
    /**
 * Perform the assignment `obj[id] = v`.
 *
 * This function performs non-strict assignment, so if the property is
 * read-only, nothing happens and no error is thrown.
 */
    #[link_name =
          "?JS_SetPropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@V?$Handle@VValue@JS@@@3@@Z"]
    pub fn JS_SetPropertyById(cx: *mut JSContext, obj: HandleObject,
                              id: HandleId, v: HandleValue) -> bool;
    #[link_name =
          "?JS_SetProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDV?$Handle@VValue@JS@@@3@@Z"]
    pub fn JS_SetProperty(cx: *mut JSContext, obj: HandleObject,
                          name: *const ::std::os::raw::c_char, v: HandleValue)
     -> bool;
    #[link_name =
          "?JS_SetUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KV?$Handle@VValue@JS@@@3@@Z"]
    pub fn JS_SetUCProperty(cx: *mut JSContext, obj: HandleObject,
                            name: *const ::std::os::raw::c_ushort,
                            namelen: usize, v: HandleValue) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IV?$Handle@VValue@JS@@@3@@Z"]
    pub fn JS_SetElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                         v: HandleValue) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I1@Z"]
    pub fn JS_SetElement1(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: HandleObject) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IV?$Handle@PEAVJSString@@@3@@Z"]
    pub fn JS_SetElement2(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: HandleString) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_SetElement3(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: i32) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@II@Z"]
    pub fn JS_SetElement4(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: u32) -> bool;
    #[link_name =
          "?JS_SetElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IN@Z"]
    pub fn JS_SetElement5(cx: *mut JSContext, obj: HandleObject, index: u32,
                          v: f64) -> bool;
    /**
 * Delete a property. This is the C++ equivalent of
 * `result = Reflect.deleteProperty(obj, id)`.
 *
 * This function has a `result` out parameter that most callers don't need.
 * Unless you can pass through an ObjectOpResult provided by your caller, it's
 * probably best to use the JS_DeletePropertyById signature with just 3
 * arguments.
 *
 * Implements: ES6 [[Delete]] internal method.
 */
    #[link_name =
          "?JS_DeletePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@AEAVObjectOpResult@3@@Z"]
    pub fn JS_DeletePropertyById(cx: *mut JSContext, obj: HandleObject,
                                 id: HandleId, result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "?JS_DeleteProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDAEAVObjectOpResult@3@@Z"]
    pub fn JS_DeleteProperty(cx: *mut JSContext, obj: HandleObject,
                             name: *const ::std::os::raw::c_char,
                             result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "?JS_DeleteUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KAEAVObjectOpResult@3@@Z"]
    pub fn JS_DeleteUCProperty(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize, result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "?JS_DeleteElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IAEAVObjectOpResult@3@@Z"]
    pub fn JS_DeleteElement(cx: *mut JSContext, obj: HandleObject, index: u32,
                            result: *mut ObjectOpResult) -> bool;
    /**
 * Delete a property, ignoring strict failures. This is the C++ equivalent of
 * the JS `delete obj[id]` in non-strict mode code.
 */
    #[link_name =
          "?JS_DeletePropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@Ujsid@@@Z"]
    pub fn JS_DeletePropertyById1(cx: *mut JSContext, obj: HandleObject,
                                  id: jsid) -> bool;
    #[link_name =
          "?JS_DeleteProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBD@Z"]
    pub fn JS_DeleteProperty1(cx: *mut JSContext, obj: HandleObject,
                              name: *const ::std::os::raw::c_char) -> bool;
    #[link_name =
          "?JS_DeleteElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I@Z"]
    pub fn JS_DeleteElement1(cx: *mut JSContext, obj: HandleObject,
                             index: u32) -> bool;
    /**
 * Return true if the given object is callable. In ES6 terms, an object is
 * callable if it has a [[Call]] internal method.
 *
 * Implements: ES6 7.2.3 IsCallable(argument).
 *
 * Functions are callable. A scripted proxy or wrapper is callable if its
 * target is callable. Most other objects aren't callable.
 */
    #[link_name = "?IsCallable@JS@@YA_NPEAVJSObject@@@Z"]
    pub fn IsCallable(obj: *mut JSObject) -> bool;
    /**
 * Return true if the given object is a constructor. In ES6 terms, an object is
 * a constructor if it has a [[Construct]] internal method. The expression
 * `new obj()` throws a TypeError if obj is not a constructor.
 *
 * Implements: ES6 7.2.4 IsConstructor(argument).
 *
 * JS functions and classes are constructors. Arrow functions and most builtin
 * functions are not. A scripted proxy or wrapper is a constructor if its
 * target is a constructor.
 */
    #[link_name = "?IsConstructor@JS@@YA_NPEAVJSObject@@@Z"]
    pub fn IsConstructor(obj: *mut JSObject) -> bool;
    /**
 * Call a function, passing a this-value and arguments. This is the C++
 * equivalent of `rval = Reflect.apply(fun, obj, args)`.
 *
 * Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
 * Use this function to invoke the [[Call]] internal method.
 */
    #[link_name =
          "?JS_CallFunctionValue@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@VValue@JS@@@3@AEBVHandleValueArray@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_CallFunctionValue(cx: *mut JSContext, obj: HandleObject,
                                fval: HandleValue,
                                args: *const HandleValueArray,
                                rval: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_CallFunction@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@PEAVJSFunction@@@3@AEBVHandleValueArray@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_CallFunction(cx: *mut JSContext, obj: HandleObject,
                           fun: HandleFunction, args: *const HandleValueArray,
                           rval: MutableHandleValue) -> bool;
    /**
 * Perform the method call `rval = obj[name](args)`.
 */
    #[link_name =
          "?JS_CallFunctionName@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDAEBVHandleValueArray@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_CallFunctionName(cx: *mut JSContext, obj: HandleObject,
                               name: *const ::std::os::raw::c_char,
                               args: *const HandleValueArray,
                               rval: MutableHandleValue) -> bool;
    #[link_name =
          "?Call@JS@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@1@1AEBVHandleValueArray@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Call(cx: *mut JSContext, thisv: HandleValue, fun: HandleValue,
                args: *const HandleValueArray, rval: MutableHandleValue)
     -> bool;
    /**
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = Reflect.construct(fun, args, newTarget)`.
 *
 * JS::Construct() takes a `newTarget` argument that most callers don't need.
 * Consider using the four-argument Construct signature instead. (But if you're
 * implementing a subclass or a proxy handler's construct() method, this is the
 * right function to call.)
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).
 * Use this function to invoke the [[Construct]] internal method.
 */
    #[link_name =
          "?Construct@JS@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@1@V?$Handle@PEAVJSObject@@@1@AEBVHandleValueArray@1@V?$MutableHandle@PEAVJSObject@@@1@@Z"]
    pub fn Construct(cx: *mut JSContext, fun: HandleValue,
                     newTarget: HandleObject, args: *const HandleValueArray,
                     objp: MutableHandleObject) -> bool;
    /**
 * Invoke a constructor. This is the C++ equivalent of
 * `rval = new fun(...args)`.
 *
 * Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when
 * newTarget is omitted.
 */
    #[link_name =
          "?Construct@JS@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@1@AEBVHandleValueArray@1@V?$MutableHandle@PEAVJSObject@@@1@@Z"]
    pub fn Construct1(cx: *mut JSContext, fun: HandleValue,
                      args: *const HandleValueArray,
                      objp: MutableHandleObject) -> bool;
    /**
 * Invoke a constructor, like the JS expression `new ctor(...args)`. Returns
 * the new object, or null on error.
 */
    #[link_name =
          "?JS_New@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@AEBVHandleValueArray@4@@Z"]
    pub fn JS_New(cx: *mut JSContext, ctor: HandleObject,
                  args: *const HandleValueArray) -> *mut JSObject;
    /*** Other property-defining functions ***********************************************************/
    #[link_name =
          "?JS_DefineObject@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDPEBUJSClass@@I@Z"]
    pub fn JS_DefineObject(cx: *mut JSContext, obj: HandleObject,
                           name: *const ::std::os::raw::c_char,
                           clasp: *const JSClass,
                           attrs: ::std::os::raw::c_uint) -> *mut JSObject;
    #[link_name =
          "?JS_DefineConstDoubles@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBU?$JSConstScalarSpec@N@@@Z"]
    pub fn JS_DefineConstDoubles(cx: *mut JSContext, obj: HandleObject,
                                 cds: *const JSConstDoubleSpec) -> bool;
    #[link_name =
          "?JS_DefineConstIntegers@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBU?$JSConstScalarSpec@H@@@Z"]
    pub fn JS_DefineConstIntegers(cx: *mut JSContext, obj: HandleObject,
                                  cis: *const JSConstIntegerSpec) -> bool;
    #[link_name =
          "?JS_DefineProperties@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBUJSPropertySpec@@@Z"]
    pub fn JS_DefineProperties(cx: *mut JSContext, obj: HandleObject,
                               ps: *const JSPropertySpec) -> bool;
    #[link_name =
          "?JS_AlreadyHasOwnPropertyById@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@3@PEA_N@Z"]
    pub fn JS_AlreadyHasOwnPropertyById(cx: *mut JSContext, obj: HandleObject,
                                        id: HandleId, foundp: *mut bool)
     -> bool;
    #[link_name =
          "?JS_AlreadyHasOwnProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDPEA_N@Z"]
    pub fn JS_AlreadyHasOwnProperty(cx: *mut JSContext, obj: HandleObject,
                                    name: *const ::std::os::raw::c_char,
                                    foundp: *mut bool) -> bool;
    #[link_name =
          "?JS_AlreadyHasOwnUCProperty@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KPEA_N@Z"]
    pub fn JS_AlreadyHasOwnUCProperty(cx: *mut JSContext, obj: HandleObject,
                                      name: *const ::std::os::raw::c_ushort,
                                      namelen: usize, foundp: *mut bool)
     -> bool;
    #[link_name =
          "?JS_AlreadyHasOwnElement@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IPEA_N@Z"]
    pub fn JS_AlreadyHasOwnElement(cx: *mut JSContext, obj: HandleObject,
                                   index: u32, foundp: *mut bool) -> bool;
    #[link_name =
          "?JS_NewArrayObject@@YAPEAVJSObject@@PEAUJSContext@@AEBVHandleValueArray@JS@@@Z"]
    pub fn JS_NewArrayObject(cx: *mut JSContext,
                             contents: *const HandleValueArray)
     -> *mut JSObject;
    #[link_name = "?JS_NewArrayObject@@YAPEAVJSObject@@PEAUJSContext@@_K@Z"]
    pub fn JS_NewArrayObject1(cx: *mut JSContext, length: usize)
     -> *mut JSObject;
    /**
 * Returns true and sets |*isArray| indicating whether |value| is an Array
 * object or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isArray == false| when passed a proxy whose
 * target is an Array, or when passed a revoked proxy.
 */
    #[link_name =
          "?JS_IsArrayObject@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEA_N@Z"]
    pub fn JS_IsArrayObject(cx: *mut JSContext, value: HandleValue,
                            isArray: *mut bool) -> bool;
    /**
 * Returns true and sets |*isArray| indicating whether |obj| is an Array object
 * or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isArray == false| when passed a proxy whose
 * target is an Array, or when passed a revoked proxy.
 */
    #[link_name =
          "?JS_IsArrayObject@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_IsArrayObject1(cx: *mut JSContext, obj: HandleObject,
                             isArray: *mut bool) -> bool;
    #[link_name =
          "?JS_GetArrayLength@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEAI@Z"]
    pub fn JS_GetArrayLength(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             lengthp: *mut u32) -> bool;
    #[link_name =
          "?JS_SetArrayLength@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I@Z"]
    pub fn JS_SetArrayLength(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             length: u32) -> bool;
    /**
 * Assign 'undefined' to all of the object's non-reserved slots. Note: this is
 * done for all slots, regardless of the associated property descriptor.
 */
    #[link_name =
          "?JS_SetAllNonReservedSlotsToUndefined@@YAXPEAUJSContext@@PEAVJSObject@@@Z"]
    pub fn JS_SetAllNonReservedSlotsToUndefined(cx: *mut JSContext,
                                                objArg: *mut JSObject);
    /**
 * Create a new array buffer with the given contents. It must be legal to pass
 * these contents to free(). On success, the ownership is transferred to the
 * new array buffer.
 */
    #[link_name =
          "?JS_NewArrayBufferWithContents@@YAPEAVJSObject@@PEAUJSContext@@_KPEAX@Z"]
    pub fn JS_NewArrayBufferWithContents(cx: *mut JSContext, nbytes: usize,
                                         contents:
                                             *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Steal the contents of the given array buffer. The array buffer has its
 * length set to 0 and its contents array cleared. The caller takes ownership
 * of the return value and must free it or transfer ownership via
 * JS_NewArrayBufferWithContents when done using it.
 */
    #[link_name =
          "?JS_StealArrayBufferContents@@YAPEAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_StealArrayBufferContents(cx: *mut JSContext, obj: HandleObject)
     -> *mut ::std::os::raw::c_void;
    /**
 * Create a new mapped array buffer with the given memory mapped contents. It
 * must be legal to free the contents pointer by unmapping it. On success,
 * ownership is transferred to the new mapped array buffer.
 */
    #[link_name =
          "?JS_NewMappedArrayBufferWithContents@@YAPEAVJSObject@@PEAUJSContext@@_KPEAX@Z"]
    pub fn JS_NewMappedArrayBufferWithContents(cx: *mut JSContext,
                                               nbytes: usize,
                                               contents:
                                                   *mut ::std::os::raw::c_void)
     -> *mut JSObject;
    /**
 * Create memory mapped array buffer contents.
 * Caller must take care of closing fd after calling this function.
 */
    #[link_name = "?JS_CreateMappedArrayBufferContents@@YAPEAXH_K0@Z"]
    pub fn JS_CreateMappedArrayBufferContents(fd: ::std::os::raw::c_int,
                                              offset: usize, length: usize)
     -> *mut ::std::os::raw::c_void;
    /**
 * Release the allocated resource of mapped array buffer contents before the
 * object is created.
 * If a new object has been created by JS_NewMappedArrayBufferWithContents()
 * with this content, then JS_DetachArrayBuffer() should be used instead to
 * release the resource used by the object.
 */
    #[link_name = "?JS_ReleaseMappedArrayBufferContents@@YAXPEAX_K@Z"]
    pub fn JS_ReleaseMappedArrayBufferContents(contents:
                                                   *mut ::std::os::raw::c_void,
                                               length: usize);
    #[link_name = "?JS_GetReservedSlot@@YA?AVValue@JS@@PEAVJSObject@@I@Z"]
    pub fn JS_GetReservedSlot(obj: *mut JSObject, index: u32) -> Value;
    #[link_name = "?JS_SetReservedSlot@@YAXPEAVJSObject@@IVValue@JS@@@Z"]
    pub fn JS_SetReservedSlot(obj: *mut JSObject, index: u32, v: Value);
    /************************************************************************/
    #[link_name =
          "?JS_NewFunction@@YAPEAVJSFunction@@PEAUJSContext@@P6A_N0IPEAVValue@JS@@@ZIIPEBD@Z"]
    pub fn JS_NewFunction(cx: *mut JSContext, call: JSNative,
                          nargs: ::std::os::raw::c_uint,
                          flags: ::std::os::raw::c_uint,
                          name: *const ::std::os::raw::c_char)
     -> *mut JSFunction;
    #[link_name =
          "?GetSelfHostedFunction@JS@@YAPEAVJSFunction@@PEAUJSContext@@PEBDV?$Handle@Ujsid@@@1@I@Z"]
    pub fn GetSelfHostedFunction(cx: *mut JSContext,
                                 selfHostedName:
                                     *const ::std::os::raw::c_char,
                                 id: HandleId, nargs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    /**
 * Create a new function based on the given JSFunctionSpec, *fs.
 * id is the result of a successful call to
 * `PropertySpecNameToPermanentId(cx, fs->name, &id)`.
 *
 * Unlike JS_DefineFunctions, this does not treat fs as an array.
 * *fs must not be JS_FS_END.
 */
    #[link_name =
          "?NewFunctionFromSpec@JS@@YAPEAVJSFunction@@PEAUJSContext@@PEBUJSFunctionSpec@@V?$Handle@Ujsid@@@1@@Z"]
    pub fn NewFunctionFromSpec(cx: *mut JSContext, fs: *const JSFunctionSpec,
                               id: HandleId) -> *mut JSFunction;
    #[link_name = "?JS_GetFunctionObject@@YAPEAVJSObject@@PEAVJSFunction@@@Z"]
    pub fn JS_GetFunctionObject(fun: *mut JSFunction) -> *mut JSObject;
    /**
 * Return the function's identifier as a JSString, or null if fun is unnamed.
 * The returned string lives as long as fun, so you don't need to root a saved
 * reference to it if fun is well-connected or rooted, and provided you bound
 * the use of the saved reference by fun's lifetime.
 */
    #[link_name = "?JS_GetFunctionId@@YAPEAVJSString@@PEAVJSFunction@@@Z"]
    pub fn JS_GetFunctionId(fun: *mut JSFunction) -> *mut JSString;
    /**
 * Return a function's display name. This is the defined name if one was given
 * where the function was defined, or it could be an inferred name by the JS
 * engine in the case that the function was defined to be anonymous. This can
 * still return nullptr if a useful display name could not be inferred. The
 * same restrictions on rooting as those in JS_GetFunctionId apply.
 */
    #[link_name =
          "?JS_GetFunctionDisplayId@@YAPEAVJSString@@PEAVJSFunction@@@Z"]
    pub fn JS_GetFunctionDisplayId(fun: *mut JSFunction) -> *mut JSString;
    #[link_name = "?JS_GetFunctionArity@@YAGPEAVJSFunction@@@Z"]
    pub fn JS_GetFunctionArity(fun: *mut JSFunction) -> u16;
    /**
 * Infallible predicate to test whether obj is a function object (faster than
 * comparing obj's class name to "Function", but equivalent unless someone has
 * overwritten the "Function" identifier with a different constructor and then
 * created instances using that constructor that might be passed in as obj).
 */
    #[link_name = "?JS_ObjectIsFunction@@YA_NPEAUJSContext@@PEAVJSObject@@@Z"]
    pub fn JS_ObjectIsFunction(cx: *mut JSContext, obj: *mut JSObject)
     -> bool;
    #[link_name =
          "?JS_IsNativeFunction@@YA_NPEAVJSObject@@P6A_NPEAUJSContext@@IPEAVValue@JS@@@Z@Z"]
    pub fn JS_IsNativeFunction(funobj: *mut JSObject, call: JSNative) -> bool;
    /** Return whether the given function is a valid constructor. */
    #[link_name = "?JS_IsConstructor@@YA_NPEAVJSFunction@@@Z"]
    pub fn JS_IsConstructor(fun: *mut JSFunction) -> bool;
    #[link_name =
          "?JS_DefineFunctions@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBUJSFunctionSpec@@@Z"]
    pub fn JS_DefineFunctions(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                              fs: *const JSFunctionSpec) -> bool;
    #[link_name =
          "?JS_DefineFunction@@YAPEAVJSFunction@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBDP6A_N0IPEAVValue@4@@ZII@Z"]
    pub fn JS_DefineFunction(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                             name: *const ::std::os::raw::c_char,
                             call: JSNative, nargs: ::std::os::raw::c_uint,
                             attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "?JS_DefineUCFunction@@YAPEAVJSFunction@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEB_S_KP6A_N0IPEAVValue@4@@ZII@Z"]
    pub fn JS_DefineUCFunction(cx: *mut JSContext, obj: Handle<*mut JSObject>,
                               name: *const ::std::os::raw::c_ushort,
                               namelen: usize, call: JSNative,
                               nargs: ::std::os::raw::c_uint,
                               attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "?JS_DefineFunctionById@@YAPEAVJSFunction@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@P6A_N0IPEAVValue@4@@ZII@Z"]
    pub fn JS_DefineFunctionById(cx: *mut JSContext,
                                 obj: Handle<*mut JSObject>, id: Handle<jsid>,
                                 call: JSNative,
                                 nargs: ::std::os::raw::c_uint,
                                 attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    /**
 * Clone a top-level function into cx's global. This function will dynamically
 * fail if funobj was lexically nested inside some other function.
 */
    #[link_name =
          "?CloneFunctionObject@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn CloneFunctionObject(cx: *mut JSContext, funobj: HandleObject)
     -> *mut JSObject;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the clone's scope chain.
 */
    #[link_name =
          "?CloneFunctionObject@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@@Z"]
    pub fn CloneFunctionObject1(cx: *mut JSContext, funobj: HandleObject,
                                scopeChain: *mut AutoObjectVector)
     -> *mut JSObject;
    /**
 * Given a buffer, return false if the buffer might become a valid
 * javascript statement with the addition of more lines.  Otherwise return
 * true.  The intent is to support interactive compilation - accumulate
 * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
 * the compiler.
 */
    #[link_name =
          "?JS_BufferIsCompilableUnit@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBD_K@Z"]
    pub fn JS_BufferIsCompilableUnit(cx: *mut JSContext,
                                     obj: Handle<*mut JSObject>,
                                     utf8: *const ::std::os::raw::c_char,
                                     length: usize) -> bool;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "?JS_CompileScript@@YA_NPEAUJSContext@@PEBD_KAEBVCompileOptions@JS@@V?$MutableHandle@PEAVJSScript@@@3@@Z"]
    pub fn JS_CompileScript(cx: *mut JSContext,
                            ascii: *const ::std::os::raw::c_char,
                            length: usize, options: *const CompileOptions,
                            script: MutableHandleScript) -> bool;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "?JS_CompileUCScript@@YA_NPEAUJSContext@@PEB_S_KAEBVCompileOptions@JS@@V?$MutableHandle@PEAVJSScript@@@3@@Z"]
    pub fn JS_CompileUCScript(cx: *mut JSContext,
                              chars: *const ::std::os::raw::c_ushort,
                              length: usize, options: *const CompileOptions,
                              script: MutableHandleScript) -> bool;
    #[link_name = "?JS_GetGlobalFromScript@@YAPEAVJSObject@@PEAVJSScript@@@Z"]
    pub fn JS_GetGlobalFromScript(script: *mut JSScript) -> *mut JSObject;
    #[link_name = "?JS_GetScriptFilename@@YAPEBDPEAVJSScript@@@Z"]
    pub fn JS_GetScriptFilename(script: *mut JSScript)
     -> *const ::std::os::raw::c_char;
    #[link_name =
          "?JS_GetScriptBaseLineNumber@@YAIPEAUJSContext@@PEAVJSScript@@@Z"]
    pub fn JS_GetScriptBaseLineNumber(cx: *mut JSContext,
                                      script: *mut JSScript)
     -> ::std::os::raw::c_uint;
    #[link_name =
          "?JS_GetFunctionScript@@YAPEAVJSScript@@PEAUJSContext@@V?$Handle@PEAVJSFunction@@@JS@@@Z"]
    pub fn JS_GetFunctionScript(cx: *mut JSContext, fun: HandleFunction)
     -> *mut JSScript;
    /**
 * |script| will always be set. On failure, it will be set to nullptr.
 */
    #[link_name =
          "?Compile@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@AEAVSourceBufferHolder@1@V?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn Compile(cx: *mut JSContext, options: *const ReadOnlyCompileOptions,
                   srcBuf: *mut SourceBufferHolder,
                   script: MutableHandleScript) -> bool;
    #[link_name =
          "?Compile@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBD_KV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn Compile1(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    bytes: *const ::std::os::raw::c_char, length: usize,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "?Compile@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEB_S_KV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn Compile2(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    chars: *const ::std::os::raw::c_ushort, length: usize,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "?Compile@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEAU_iobuf@@V?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn Compile3(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions, file: *mut FILE,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "?Compile@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBDV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn Compile4(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    filename: *const ::std::os::raw::c_char,
                    script: MutableHandleScript) -> bool;
    #[link_name =
          "?CompileForNonSyntacticScope@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@AEAVSourceBufferHolder@1@V?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn CompileForNonSyntacticScope(cx: *mut JSContext,
                                       options: *const ReadOnlyCompileOptions,
                                       srcBuf: *mut SourceBufferHolder,
                                       script: MutableHandleScript) -> bool;
    #[link_name =
          "?CompileForNonSyntacticScope@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBD_KV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn CompileForNonSyntacticScope1(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        bytes: *const ::std::os::raw::c_char,
                                        length: usize,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "?CompileForNonSyntacticScope@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEB_S_KV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn CompileForNonSyntacticScope2(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        chars:
                                            *const ::std::os::raw::c_ushort,
                                        length: usize,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "?CompileForNonSyntacticScope@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEAU_iobuf@@V?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn CompileForNonSyntacticScope3(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        file: *mut FILE,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "?CompileForNonSyntacticScope@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBDV?$MutableHandle@PEAVJSScript@@@1@@Z"]
    pub fn CompileForNonSyntacticScope4(cx: *mut JSContext,
                                        options:
                                            *const ReadOnlyCompileOptions,
                                        filename:
                                            *const ::std::os::raw::c_char,
                                        script: MutableHandleScript) -> bool;
    #[link_name =
          "?CanCompileOffThread@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@_K@Z"]
    pub fn CanCompileOffThread(cx: *mut JSContext,
                               options: *const ReadOnlyCompileOptions,
                               length: usize) -> bool;
    #[link_name =
          "?CompileOffThread@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEB_S_KP6AXPEAX4@Z4@Z"]
    pub fn CompileOffThread(cx: *mut JSContext,
                            options: *const ReadOnlyCompileOptions,
                            chars: *const ::std::os::raw::c_ushort,
                            length: usize, callback: OffThreadCompileCallback,
                            callbackData: *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?FinishOffThreadScript@JS@@YAPEAVJSScript@@PEAUJSContext@@PEAUJSRuntime@@PEAX@Z"]
    pub fn FinishOffThreadScript(maybecx: *mut JSContext, rt: *mut JSRuntime,
                                 token: *mut ::std::os::raw::c_void)
     -> *mut JSScript;
    /**
 * Compile a function with scopeChain plus the global as its scope chain.
 * scopeChain must contain objects in the current compartment of cx.  The actual
 * scope chain used for the function will consist of With wrappers for those
 * objects, followed by the current global of the compartment cx is in.  This
 * global must not be explicitly included in the scope chain.
 */
    #[link_name =
          "?CompileFunction@JS@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@AEBVReadOnlyCompileOptions@1@PEBDIPEBQEBDPEB_S_KV?$MutableHandle@PEAVJSFunction@@@1@@Z"]
    pub fn CompileFunction(cx: *mut JSContext,
                           scopeChain: *mut AutoObjectVector,
                           options: *const ReadOnlyCompileOptions,
                           name: *const ::std::os::raw::c_char,
                           nargs: ::std::os::raw::c_uint,
                           argnames: *const *const ::std::os::raw::c_char,
                           chars: *const ::std::os::raw::c_ushort,
                           length: usize, fun: MutableHandleFunction) -> bool;
    /**
 * Same as above, but taking a SourceBufferHolder for the function body.
 */
    #[link_name =
          "?CompileFunction@JS@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@AEBVReadOnlyCompileOptions@1@PEBDIPEBQEBDAEAVSourceBufferHolder@1@V?$MutableHandle@PEAVJSFunction@@@1@@Z"]
    pub fn CompileFunction1(cx: *mut JSContext,
                            scopeChain: *mut AutoObjectVector,
                            options: *const ReadOnlyCompileOptions,
                            name: *const ::std::os::raw::c_char,
                            nargs: ::std::os::raw::c_uint,
                            argnames: *const *const ::std::os::raw::c_char,
                            srcBuf: *mut SourceBufferHolder,
                            fun: MutableHandleFunction) -> bool;
    /**
 * Same as above, but taking a const char * for the function body.
 */
    #[link_name =
          "?CompileFunction@JS@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@AEBVReadOnlyCompileOptions@1@PEBDIPEBQEBD3_KV?$MutableHandle@PEAVJSFunction@@@1@@Z"]
    pub fn CompileFunction2(cx: *mut JSContext,
                            scopeChain: *mut AutoObjectVector,
                            options: *const ReadOnlyCompileOptions,
                            name: *const ::std::os::raw::c_char,
                            nargs: ::std::os::raw::c_uint,
                            argnames: *const *const ::std::os::raw::c_char,
                            bytes: *const ::std::os::raw::c_char,
                            length: usize, fun: MutableHandleFunction)
     -> bool;
    #[link_name =
          "?JS_DecompileScript@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSScript@@@JS@@PEBDI@Z"]
    pub fn JS_DecompileScript(cx: *mut JSContext,
                              script: Handle<*mut JSScript>,
                              name: *const ::std::os::raw::c_char,
                              indent: ::std::os::raw::c_uint)
     -> *mut JSString;
    #[link_name =
          "?JS_DecompileFunction@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSFunction@@@JS@@I@Z"]
    pub fn JS_DecompileFunction(cx: *mut JSContext,
                                fun: Handle<*mut JSFunction>,
                                indent: ::std::os::raw::c_uint)
     -> *mut JSString;
    /**
 * Evaluate a script in the scope of the current global of cx.
 */
    #[link_name =
          "?JS_ExecuteScript@@YA_NPEAUJSContext@@V?$Handle@PEAVJSScript@@@JS@@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ExecuteScript(cx: *mut JSContext, script: HandleScript,
                            rval: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ExecuteScript@@YA_NPEAUJSContext@@V?$Handle@PEAVJSScript@@@JS@@@Z"]
    pub fn JS_ExecuteScript1(cx: *mut JSContext, script: HandleScript)
     -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "?JS_ExecuteScript@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@JS@@V?$Handle@PEAVJSScript@@@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ExecuteScript2(cx: *mut JSContext,
                             scopeChain: *mut AutoObjectVector,
                             script: HandleScript, rval: MutableHandleValue)
     -> bool;
    #[link_name =
          "?JS_ExecuteScript@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@JS@@V?$Handle@PEAVJSScript@@@3@@Z"]
    pub fn JS_ExecuteScript3(cx: *mut JSContext,
                             scopeChain: *mut AutoObjectVector,
                             script: HandleScript) -> bool;
    /**
 * Like the above, but handles a cross-compartment script. If the script is
 * cross-compartment, it is cloned into the current compartment before executing.
 */
    #[link_name =
          "?CloneAndExecuteScript@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSScript@@@1@@Z"]
    pub fn CloneAndExecuteScript(cx: *mut JSContext,
                                 script: Handle<*mut JSScript>) -> bool;
    /**
 * Evaluate the given source buffer in the scope of the current global of cx.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@AEAVSourceBufferHolder@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate(cx: *mut JSContext,
                    options: *const ReadOnlyCompileOptions,
                    srcBuf: *mut SourceBufferHolder, rval: MutableHandleValue)
     -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@AEBVReadOnlyCompileOptions@1@AEAVSourceBufferHolder@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate1(cx: *mut JSContext, scopeChain: *mut AutoObjectVector,
                     options: *const ReadOnlyCompileOptions,
                     srcBuf: *mut SourceBufferHolder,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given character buffer in the scope of the current global of cx.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEB_S_KV?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate2(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     chars: *const ::std::os::raw::c_ushort, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * As above, but providing an explicit scope chain.  scopeChain must not include
 * the global object on it; that's implicit.  It needs to contain the other
 * objects that should end up on the script's scope chain.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@PEAVJSObject@@@1@AEBVReadOnlyCompileOptions@1@PEB_S_KV?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate3(cx: *mut JSContext, scopeChain: *mut AutoObjectVector,
                     options: *const ReadOnlyCompileOptions,
                     chars: *const ::std::os::raw::c_ushort, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given byte buffer in the scope of the current global of cx.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBD_KV?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate4(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     bytes: *const ::std::os::raw::c_char, length: usize,
                     rval: MutableHandleValue) -> bool;
    /**
 * Evaluate the given file in the scope of the current global of cx.
 */
    #[link_name =
          "?Evaluate@JS@@YA_NPEAUJSContext@@AEBVReadOnlyCompileOptions@1@PEBDV?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn Evaluate5(cx: *mut JSContext,
                     options: *const ReadOnlyCompileOptions,
                     filename: *const ::std::os::raw::c_char,
                     rval: MutableHandleValue) -> bool;
    #[link_name = "?JS_CheckForInterrupt@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_CheckForInterrupt(cx: *mut JSContext) -> bool;
    #[link_name =
          "?JS_SetInterruptCallback@@YAP6A_NPEAUJSContext@@@ZPEAUJSRuntime@@P6A_N0@Z@Z"]
    pub fn JS_SetInterruptCallback(rt: *mut JSRuntime,
                                   callback: JSInterruptCallback)
     -> JSInterruptCallback;
    #[link_name =
          "?JS_GetInterruptCallback@@YAP6A_NPEAUJSContext@@@ZPEAUJSRuntime@@@Z"]
    pub fn JS_GetInterruptCallback(rt: *mut JSRuntime) -> JSInterruptCallback;
    #[link_name = "?JS_RequestInterruptCallback@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_RequestInterruptCallback(rt: *mut JSRuntime);
    /**
 * Sets the callback that's invoked whenever a Promise job should be enqeued.
 *
 * SpiderMonkey doesn't schedule Promise resolution jobs itself; instead,
 * using this function the embedding can provide a callback to do that
 * scheduling. The provided `callback` is invoked with the promise job
 * and the `data` pointer passed here as arguments.
 */
    #[link_name =
          "?SetEnqueuePromiseJobCallback@JS@@YAXPEAUJSRuntime@@P6A_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@PEAX@Z3@Z"]
    pub fn SetEnqueuePromiseJobCallback(rt: *mut JSRuntime,
                                        callback: JSEnqueuePromiseJobCallback,
                                        data: *mut ::std::os::raw::c_void);
    /**
 * Returns a new instance of the Promise builtin class in the current
 * compartment, with the right slot layout. If a `proto` is passed, that gets
 * set as the instance's [[Prototype]] instead of the original value of
 * `Promise.prototype`.
 */
    #[link_name =
          "?NewPromiseObject@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@1@Z"]
    pub fn NewPromiseObject(cx: *mut JSContext, executor: HandleObject,
                            proto: HandleObject) -> *mut JSObject;
    /**
 * Returns true if the given object is an unwrapped PromiseObject, false
 * otherwise.
 */
    #[link_name = "?IsPromiseObject@JS@@YA_NV?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn IsPromiseObject(obj: HandleObject) -> bool;
    /**
 * Returns the current compartment's original Promise constructor.
 */
    #[link_name =
          "?GetPromiseConstructor@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn GetPromiseConstructor(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the current compartment's original Promise.prototype.
 */
    #[link_name =
          "?GetPromisePrototype@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn GetPromisePrototype(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Returns the given Promise's state as a JS::PromiseState enum value.
 */
    #[link_name =
          "?GetPromiseState@JS@@YA?AW4PromiseState@1@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn GetPromiseState(promise: HandleObject) -> PromiseState;
    /**
 * Returns the given Promise's process-unique ID.
 */
    #[link_name = "?GetPromiseID@JS@@YANV?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn GetPromiseID(promise: HandleObject) -> f64;
    /**
 * Returns the given Promise's result: either the resolution value for
 * fulfilled promises, or the rejection reason for rejected ones.
 */
    #[link_name =
          "?GetPromiseResult@JS@@YA?AVValue@1@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn GetPromiseResult(promise: HandleObject) -> Value;
    /**
 * Returns a js::SavedFrame linked list of the stack that lead to the given
 * Promise's allocation.
 */
    #[link_name =
          "?GetPromiseAllocationSite@JS@@YAPEAVJSObject@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn GetPromiseAllocationSite(promise: HandleObject) -> *mut JSObject;
    #[link_name =
          "?GetPromiseResolutionSite@JS@@YAPEAVJSObject@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn GetPromiseResolutionSite(promise: HandleObject) -> *mut JSObject;
    /**
 * Calls the current compartment's original Promise.resolve on the original
 * Promise constructor, with `resolutionValue` passed as an argument.
 */
    #[link_name =
          "?CallOriginalPromiseResolve@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@VValue@JS@@@1@@Z"]
    pub fn CallOriginalPromiseResolve(cx: *mut JSContext,
                                      resolutionValue: HandleValue)
     -> *mut JSObject;
    /**
 * Calls the current compartment's original Promise.reject on the original
 * Promise constructor, with `resolutionValue` passed as an argument.
 */
    #[link_name =
          "?CallOriginalPromiseReject@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@VValue@JS@@@1@@Z"]
    pub fn CallOriginalPromiseReject(cx: *mut JSContext,
                                     rejectionValue: HandleValue)
     -> *mut JSObject;
    /**
 * Resolves the given Promise with the given `resolutionValue`.
 *
 * Calls the `resolve` function that was passed to the executor function when
 * the Promise was created.
 */
    #[link_name =
          "?ResolvePromise@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@@Z"]
    pub fn ResolvePromise(cx: *mut JSContext, promise: HandleObject,
                          resolutionValue: HandleValue) -> bool;
    /**
 * Rejects the given `promise` with the given `rejectionValue`.
 *
 * Calls the `reject` function that was passed to the executor function when
 * the Promise was created.
 */
    #[link_name =
          "?RejectPromise@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@@Z"]
    pub fn RejectPromise(cx: *mut JSContext, promise: HandleObject,
                         rejectionValue: HandleValue) -> bool;
    /**
 * Calls the current compartment's original Promise.prototype.then on the
 * given `promise`, with `onResolve` and `onReject` passed as arguments.
 *
 * Asserts if the passed-in `promise` object isn't an unwrapped instance of
 * `Promise` or a subclass or `onResolve` and `onReject` aren't both either
 * `nullptr` or callable objects.
 */
    #[link_name =
          "?CallOriginalPromiseThen@JS@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@11@Z"]
    pub fn CallOriginalPromiseThen(cx: *mut JSContext, promise: HandleObject,
                                   onResolve: HandleObject,
                                   onReject: HandleObject) -> *mut JSObject;
    /**
 * Unforgeable, optimized version of the JS builtin Promise.prototype.then.
 *
 * Takes a Promise instance and `onResolve`, `onReject` callables to enqueue
 * as reactions for that promise. In difference to Promise.prototype.then,
 * this doesn't create and return a new Promise instance.
 *
 * Asserts if the passed-in `promise` object isn't an unwrapped instance of
 * `Promise` or a subclass or `onResolve` and `onReject` aren't both callable
 * objects.
 */
    #[link_name =
          "?AddPromiseReactions@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@11@Z"]
    pub fn AddPromiseReactions(cx: *mut JSContext, promise: HandleObject,
                               onResolve: HandleObject,
                               onReject: HandleObject) -> bool;
    /**
 * Unforgeable version of the JS builtin Promise.all.
 *
 * Takes an AutoObjectVector of Promise objects and returns a promise that's
 * resolved with an array of resolution values when all those promises ahve
 * been resolved, or rejected with the rejection value of the first rejected
 * promise.
 *
 * Asserts if the array isn't dense or one of the entries isn't an unwrapped
 * instance of Promise or a subclass.
 */
    #[link_name =
          "?GetWaitForAllPromise@JS@@YAPEAVJSObject@@PEAUJSContext@@AEBV?$AutoVectorRooter@PEAVJSObject@@@1@@Z"]
    pub fn GetWaitForAllPromise(cx: *mut JSContext,
                                promises: *const AutoObjectVector)
     -> *mut JSObject;
    #[link_name = "?JS_IsRunning@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_IsRunning(cx: *mut JSContext) -> bool;
    #[link_name = "?JS_SaveFrameChain@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_SaveFrameChain(cx: *mut JSContext) -> bool;
    #[link_name = "?JS_RestoreFrameChain@@YAXPEAUJSContext@@@Z"]
    pub fn JS_RestoreFrameChain(cx: *mut JSContext);
    #[link_name =
          "?JS_NewStringCopyN@@YAPEAVJSString@@PEAUJSContext@@PEBD_K@Z"]
    pub fn JS_NewStringCopyN(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char, n: usize)
     -> *mut JSString;
    #[link_name = "?JS_NewStringCopyZ@@YAPEAVJSString@@PEAUJSContext@@PEBD@Z"]
    pub fn JS_NewStringCopyZ(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name =
          "?JS_AtomizeAndPinJSString@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@@Z"]
    pub fn JS_AtomizeAndPinJSString(cx: *mut JSContext, str: HandleString)
     -> *mut JSString;
    #[link_name =
          "?JS_AtomizeStringN@@YAPEAVJSString@@PEAUJSContext@@PEBD_K@Z"]
    pub fn JS_AtomizeStringN(cx: *mut JSContext,
                             s: *const ::std::os::raw::c_char, length: usize)
     -> *mut JSString;
    #[link_name = "?JS_AtomizeString@@YAPEAVJSString@@PEAUJSContext@@PEBD@Z"]
    pub fn JS_AtomizeString(cx: *mut JSContext,
                            s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name =
          "?JS_AtomizeAndPinStringN@@YAPEAVJSString@@PEAUJSContext@@PEBD_K@Z"]
    pub fn JS_AtomizeAndPinStringN(cx: *mut JSContext,
                                   s: *const ::std::os::raw::c_char,
                                   length: usize) -> *mut JSString;
    #[link_name =
          "?JS_AtomizeAndPinString@@YAPEAVJSString@@PEAUJSContext@@PEBD@Z"]
    pub fn JS_AtomizeAndPinString(cx: *mut JSContext,
                                  s: *const ::std::os::raw::c_char)
     -> *mut JSString;
    #[link_name = "?JS_NewUCString@@YAPEAVJSString@@PEAUJSContext@@PEA_S_K@Z"]
    pub fn JS_NewUCString(cx: *mut JSContext,
                          chars: *mut ::std::os::raw::c_ushort, length: usize)
     -> *mut JSString;
    #[link_name =
          "?JS_NewUCStringCopyN@@YAPEAVJSString@@PEAUJSContext@@PEB_S_K@Z"]
    pub fn JS_NewUCStringCopyN(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort, n: usize)
     -> *mut JSString;
    #[link_name =
          "?JS_NewUCStringCopyZ@@YAPEAVJSString@@PEAUJSContext@@PEB_S@Z"]
    pub fn JS_NewUCStringCopyZ(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name =
          "?JS_AtomizeUCStringN@@YAPEAVJSString@@PEAUJSContext@@PEB_S_K@Z"]
    pub fn JS_AtomizeUCStringN(cx: *mut JSContext,
                               s: *const ::std::os::raw::c_ushort,
                               length: usize) -> *mut JSString;
    #[link_name =
          "?JS_AtomizeUCString@@YAPEAVJSString@@PEAUJSContext@@PEB_S@Z"]
    pub fn JS_AtomizeUCString(cx: *mut JSContext,
                              s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name =
          "?JS_AtomizeAndPinUCStringN@@YAPEAVJSString@@PEAUJSContext@@PEB_S_K@Z"]
    pub fn JS_AtomizeAndPinUCStringN(cx: *mut JSContext,
                                     s: *const ::std::os::raw::c_ushort,
                                     length: usize) -> *mut JSString;
    #[link_name =
          "?JS_AtomizeAndPinUCString@@YAPEAVJSString@@PEAUJSContext@@PEB_S@Z"]
    pub fn JS_AtomizeAndPinUCString(cx: *mut JSContext,
                                    s: *const ::std::os::raw::c_ushort)
     -> *mut JSString;
    #[link_name =
          "?JS_CompareStrings@@YA_NPEAUJSContext@@PEAVJSString@@1PEAH@Z"]
    pub fn JS_CompareStrings(cx: *mut JSContext, str1: *mut JSString,
                             str2: *mut JSString, result: *mut i32) -> bool;
    #[link_name =
          "?JS_StringEqualsAscii@@YA_NPEAUJSContext@@PEAVJSString@@PEBDPEA_N@Z"]
    pub fn JS_StringEqualsAscii(cx: *mut JSContext, str: *mut JSString,
                                asciiBytes: *const ::std::os::raw::c_char,
                                match_: *mut bool) -> bool;
    #[link_name =
          "?JS_PutEscapedString@@YA_KPEAUJSContext@@PEAD_KPEAVJSString@@D@Z"]
    pub fn JS_PutEscapedString(cx: *mut JSContext,
                               buffer: *mut ::std::os::raw::c_char,
                               size: usize, str: *mut JSString,
                               quote: ::std::os::raw::c_char) -> usize;
    #[link_name = "?JS_FileEscapedString@@YA_NPEAU_iobuf@@PEAVJSString@@D@Z"]
    pub fn JS_FileEscapedString(fp: *mut FILE, str: *mut JSString,
                                quote: ::std::os::raw::c_char) -> bool;
    #[link_name = "?JS_GetStringLength@@YA_KPEAVJSString@@@Z"]
    pub fn JS_GetStringLength(str: *mut JSString) -> usize;
    #[link_name = "?JS_StringIsFlat@@YA_NPEAVJSString@@@Z"]
    pub fn JS_StringIsFlat(str: *mut JSString) -> bool;
    /** Returns true iff the string's characters are stored as Latin1. */
    #[link_name = "?JS_StringHasLatin1Chars@@YA_NPEAVJSString@@@Z"]
    pub fn JS_StringHasLatin1Chars(str: *mut JSString) -> bool;
    #[link_name =
          "?JS_GetLatin1StringCharsAndLength@@YAPEBEPEAUJSContext@@AEBVAutoCheckCannotGC@JS@@PEAVJSString@@PEA_K@Z"]
    pub fn JS_GetLatin1StringCharsAndLength(cx: *mut JSContext,
                                            nogc: *const AutoCheckCannotGC,
                                            str: *mut JSString,
                                            length: *mut usize)
     -> *const Latin1Char;
    #[link_name =
          "?JS_GetTwoByteStringCharsAndLength@@YAPEB_SPEAUJSContext@@AEBVAutoCheckCannotGC@JS@@PEAVJSString@@PEA_K@Z"]
    pub fn JS_GetTwoByteStringCharsAndLength(cx: *mut JSContext,
                                             nogc: *const AutoCheckCannotGC,
                                             str: *mut JSString,
                                             length: *mut usize)
     -> *const ::std::os::raw::c_ushort;
    #[link_name =
          "?JS_GetStringCharAt@@YA_NPEAUJSContext@@PEAVJSString@@_KPEA_S@Z"]
    pub fn JS_GetStringCharAt(cx: *mut JSContext, str: *mut JSString,
                              index: usize,
                              res: *mut ::std::os::raw::c_ushort) -> bool;
    #[link_name = "?JS_GetFlatStringCharAt@@YA_SPEAVJSFlatString@@_K@Z"]
    pub fn JS_GetFlatStringCharAt(str: *mut JSFlatString, index: usize)
     -> ::std::os::raw::c_ushort;
    #[link_name =
          "?JS_GetTwoByteExternalStringChars@@YAPEB_SPEAVJSString@@@Z"]
    pub fn JS_GetTwoByteExternalStringChars(str: *mut JSString)
     -> *const ::std::os::raw::c_ushort;
    #[link_name =
          "?JS_CopyStringChars@@YA_NPEAUJSContext@@V?$Range@_S@mozilla@@PEAVJSString@@@Z"]
    pub fn JS_CopyStringChars(cx: *mut JSContext,
                              dest: Range<::std::os::raw::c_ushort>,
                              str: *mut JSString) -> bool;
    #[link_name =
          "?JS_FlattenString@@YAPEAVJSFlatString@@PEAUJSContext@@PEAVJSString@@@Z"]
    pub fn JS_FlattenString(cx: *mut JSContext, str: *mut JSString)
     -> *mut JSFlatString;
    #[link_name =
          "?JS_GetLatin1FlatStringChars@@YAPEBEAEBVAutoCheckCannotGC@JS@@PEAVJSFlatString@@@Z"]
    pub fn JS_GetLatin1FlatStringChars(nogc: *const AutoCheckCannotGC,
                                       str: *mut JSFlatString)
     -> *const Latin1Char;
    #[link_name =
          "?JS_GetTwoByteFlatStringChars@@YAPEB_SAEBVAutoCheckCannotGC@JS@@PEAVJSFlatString@@@Z"]
    pub fn JS_GetTwoByteFlatStringChars(nogc: *const AutoCheckCannotGC,
                                        str: *mut JSFlatString)
     -> *const ::std::os::raw::c_ushort;
    #[link_name = "?JS_FlatStringEqualsAscii@@YA_NPEAVJSFlatString@@PEBD@Z"]
    pub fn JS_FlatStringEqualsAscii(str: *mut JSFlatString,
                                    asciiBytes: *const ::std::os::raw::c_char)
     -> bool;
    #[link_name = "?JS_PutEscapedFlatString@@YA_KPEAD_KPEAVJSFlatString@@D@Z"]
    pub fn JS_PutEscapedFlatString(buffer: *mut ::std::os::raw::c_char,
                                   size: usize, str: *mut JSFlatString,
                                   quote: ::std::os::raw::c_char) -> usize;
    /**
 * Create a dependent string, i.e., a string that owns no character storage,
 * but that refers to a slice of another string's chars.  Dependent strings
 * are mutable by definition, so the thread safety comments above apply.
 */
    #[link_name =
          "?JS_NewDependentString@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@_K2@Z"]
    pub fn JS_NewDependentString(cx: *mut JSContext, str: HandleString,
                                 start: usize, length: usize)
     -> *mut JSString;
    /**
 * Concatenate two strings, possibly resulting in a rope.
 * See above for thread safety comments.
 */
    #[link_name =
          "?JS_ConcatStrings@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@1@Z"]
    pub fn JS_ConcatStrings(cx: *mut JSContext, left: HandleString,
                            right: HandleString) -> *mut JSString;
    /**
 * For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before
 * the call; on return, *dstlenp contains the number of characters actually
 * stored. To determine the necessary destination buffer size, make a sizing
 * call that passes nullptr for dst.
 *
 * On errors, the functions report the error. In that case, *dstlenp contains
 * the number of characters or bytes transferred so far.  If cx is nullptr, no
 * error is reported on failure, and the functions simply return false.
 *
 * NB: This function does not store an additional zero byte or char16_t after the
 * transcoded string.
 */
    #[link_name = "?JS_DecodeBytes@@YA_NPEAUJSContext@@PEBD_KPEA_SPEA_K@Z"]
    pub fn JS_DecodeBytes(cx: *mut JSContext,
                          src: *const ::std::os::raw::c_char, srclen: usize,
                          dst: *mut ::std::os::raw::c_ushort,
                          dstlenp: *mut usize) -> bool;
    /**
 * A variation on JS_EncodeCharacters where a null terminated string is
 * returned that you are expected to call JS_free on when done.
 */
    #[link_name = "?JS_EncodeString@@YAPEADPEAUJSContext@@PEAVJSString@@@Z"]
    pub fn JS_EncodeString(cx: *mut JSContext, str: *mut JSString)
     -> *mut ::std::os::raw::c_char;
    /**
 * Same behavior as JS_EncodeString(), but encode into UTF-8 string
 */
    #[link_name =
          "?JS_EncodeStringToUTF8@@YAPEADPEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@@Z"]
    pub fn JS_EncodeStringToUTF8(cx: *mut JSContext, str: HandleString)
     -> *mut ::std::os::raw::c_char;
    /**
 * Get number of bytes in the string encoding (without accounting for a
 * terminating zero bytes. The function returns (size_t) -1 if the string
 * can not be encoded into bytes and reports an error using cx accordingly.
 */
    #[link_name =
          "?JS_GetStringEncodingLength@@YA_KPEAUJSContext@@PEAVJSString@@@Z"]
    pub fn JS_GetStringEncodingLength(cx: *mut JSContext, str: *mut JSString)
     -> usize;
    /**
 * Encode string into a buffer. The function does not stores an additional
 * zero byte. The function returns (size_t) -1 if the string can not be
 * encoded into bytes with no error reported. Otherwise it returns the number
 * of bytes that are necessary to encode the string. If that exceeds the
 * length parameter, the string will be cut and only length bytes will be
 * written into the buffer.
 */
    #[link_name =
          "?JS_EncodeStringToBuffer@@YA_KPEAUJSContext@@PEAVJSString@@PEAD_K@Z"]
    pub fn JS_EncodeStringToBuffer(cx: *mut JSContext, str: *mut JSString,
                                   buffer: *mut ::std::os::raw::c_char,
                                   length: usize) -> usize;
    #[link_name =
          "?NewAddonId@JS@@YAPEAVJSAddonId@@PEAUJSContext@@V?$Handle@PEAVJSString@@@1@@Z"]
    pub fn NewAddonId(cx: *mut JSContext, str: HandleString)
     -> *mut JSAddonId;
    #[link_name = "?StringOfAddonId@JS@@YAPEAVJSString@@PEAVJSAddonId@@@Z"]
    pub fn StringOfAddonId(id: *mut JSAddonId) -> *mut JSString;
    #[link_name = "?AddonIdOfObject@JS@@YAPEAVJSAddonId@@PEAVJSObject@@@Z"]
    pub fn AddonIdOfObject(obj: *mut JSObject) -> *mut JSAddonId;
    /**
 * Create a new Symbol with the given description. This function never returns
 * a Symbol that is in the Runtime-wide symbol registry.
 *
 * If description is null, the new Symbol's [[Description]] attribute is
 * undefined.
 */
    #[link_name =
          "?NewSymbol@JS@@YAPEAVSymbol@1@PEAUJSContext@@V?$Handle@PEAVJSString@@@1@@Z"]
    pub fn NewSymbol(cx: *mut JSContext, description: HandleString)
     -> *mut Symbol;
    /**
 * Symbol.for as specified in ES6.
 *
 * Get a Symbol with the description 'key' from the Runtime-wide symbol registry.
 * If there is not already a Symbol with that description in the registry, a new
 * Symbol is created and registered. 'key' must not be null.
 */
    #[link_name =
          "?GetSymbolFor@JS@@YAPEAVSymbol@1@PEAUJSContext@@V?$Handle@PEAVJSString@@@1@@Z"]
    pub fn GetSymbolFor(cx: *mut JSContext, key: HandleString) -> *mut Symbol;
    /**
 * Get the [[Description]] attribute of the given symbol.
 *
 * This function is infallible. If it returns null, that means the symbol's
 * [[Description]] is undefined.
 */
    #[link_name =
          "?GetSymbolDescription@JS@@YAPEAVJSString@@V?$Handle@PEAVSymbol@JS@@@1@@Z"]
    pub fn GetSymbolDescription(symbol: HandleSymbol) -> *mut JSString;
    /**
 * Return the SymbolCode telling what sort of symbol `symbol` is.
 *
 * A symbol's SymbolCode never changes once it is created.
 */
    #[link_name =
          "?GetSymbolCode@JS@@YA?AW4SymbolCode@1@V?$Handle@PEAVSymbol@JS@@@1@@Z"]
    pub fn GetSymbolCode(symbol: Handle<*mut Symbol>) -> SymbolCode;
    /**
 * Get one of the well-known symbols defined by ES6. A single set of well-known
 * symbols is shared by all compartments in a JSRuntime.
 *
 * `which` must be in the range [0, WellKnownSymbolLimit).
 */
    #[link_name =
          "?GetWellKnownSymbol@JS@@YAPEAVSymbol@1@PEAUJSContext@@W4SymbolCode@1@@Z"]
    pub fn GetWellKnownSymbol(cx: *mut JSContext, which: SymbolCode)
     -> *mut Symbol;
    #[link_name =
          "?PropertySpecNameEqualsId@JS@@YA_NPEBDV?$Handle@Ujsid@@@1@@Z"]
    pub fn PropertySpecNameEqualsId(name: *const ::std::os::raw::c_char,
                                    id: HandleId) -> bool;
    /**
 * Create a jsid that does not need to be marked for GC.
 *
 * 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The
 * resulting jsid, on success, is either an interned string or a well-known
 * symbol; either way it is immune to GC so there is no need to visit *idp
 * during GC marking.
 */
    #[link_name =
          "?PropertySpecNameToPermanentId@JS@@YA_NPEAUJSContext@@PEBDPEAUjsid@@@Z"]
    pub fn PropertySpecNameToPermanentId(cx: *mut JSContext,
                                         name: *const ::std::os::raw::c_char,
                                         idp: *mut jsid) -> bool;
    /**
 * JSON.stringify as specified by ES5.
 */
    #[link_name =
          "?JS_Stringify@@YA_NPEAUJSContext@@V?$MutableHandle@VValue@JS@@@JS@@V?$Handle@PEAVJSObject@@@3@V?$Handle@VValue@JS@@@3@P6A_NPEB_SIPEAX@Z5@Z"]
    pub fn JS_Stringify(cx: *mut JSContext, value: MutableHandleValue,
                        replacer: HandleObject, space: HandleValue,
                        callback: JSONWriteCallback,
                        data: *mut ::std::os::raw::c_void) -> bool;
    /**
 * An API akin to JS_Stringify but with the goal of not having observable
 * side-effects when the stringification is performed.  This means it does not
 * allow a replacer or a custom space, and has the following constraints on its
 * input:
 *
 * 1) The input must be a plain object or array, not an abitrary value.
 * 2) Every value in the graph reached by the algorithm starting with this
 *    object must be one of the following: null, undefined, a string (NOT a
 *    string object!), a boolean, a finite number (i.e. no NaN or Infinity or
 *    -Infinity), a plain object with no accessor properties, or an Array with
 *    no holes.
 *
 * The actual behavior differs from JS_Stringify only in asserting the above and
 * NOT attempting to get the "toJSON" property from things, since that could
 * clearly have side-effects.
 */
    #[link_name =
          "?ToJSONMaybeSafely@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@P6A_NPEB_SIPEAX@Z3@Z"]
    pub fn ToJSONMaybeSafely(cx: *mut JSContext, input: HandleObject,
                             callback: JSONWriteCallback,
                             data: *mut ::std::os::raw::c_void) -> bool;
    /**
 * JSON.parse as specified by ES5.
 */
    #[link_name =
          "?JS_ParseJSON@@YA_NPEAUJSContext@@PEB_SIV?$MutableHandle@VValue@JS@@@JS@@@Z"]
    pub fn JS_ParseJSON(cx: *mut JSContext,
                        chars: *const ::std::os::raw::c_ushort, len: u32,
                        vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ParseJSON@@YA_NPEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ParseJSON1(cx: *mut JSContext, str: HandleString,
                         vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ParseJSONWithReviver@@YA_NPEAUJSContext@@PEB_SIV?$Handle@VValue@JS@@@JS@@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ParseJSONWithReviver(cx: *mut JSContext,
                                   chars: *const ::std::os::raw::c_ushort,
                                   len: u32, reviver: HandleValue,
                                   vp: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ParseJSONWithReviver@@YA_NPEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@V?$Handle@VValue@JS@@@3@V?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ParseJSONWithReviver1(cx: *mut JSContext, str: HandleString,
                                    reviver: HandleValue,
                                    vp: MutableHandleValue) -> bool;
    /**
 * The default locale for the ECMAScript Internationalization API
 * (Intl.Collator, Intl.NumberFormat, Intl.DateTimeFormat).
 * Note that the Internationalization API encourages clients to
 * specify their own locales.
 * The locale string remains owned by the caller.
 */
    #[link_name = "?JS_SetDefaultLocale@@YA_NPEAUJSRuntime@@PEBD@Z"]
    pub fn JS_SetDefaultLocale(rt: *mut JSRuntime,
                               locale: *const ::std::os::raw::c_char) -> bool;
    /**
 * Reset the default locale to OS defaults.
 */
    #[link_name = "?JS_ResetDefaultLocale@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_ResetDefaultLocale(rt: *mut JSRuntime);
    /**
 * Establish locale callbacks. The pointer must persist as long as the
 * JSRuntime.  Passing nullptr restores the default behaviour.
 */
    #[link_name =
          "?JS_SetLocaleCallbacks@@YAXPEAUJSRuntime@@PEBUJSLocaleCallbacks@@@Z"]
    pub fn JS_SetLocaleCallbacks(rt: *mut JSRuntime,
                                 callbacks: *const JSLocaleCallbacks);
    /**
 * Return the address of the current locale callbacks struct, which may
 * be nullptr.
 */
    #[link_name =
          "?JS_GetLocaleCallbacks@@YAPEBUJSLocaleCallbacks@@PEAUJSRuntime@@@Z"]
    pub fn JS_GetLocaleCallbacks(rt: *mut JSRuntime)
     -> *const JSLocaleCallbacks;
    /**
 * Report an exception represented by the sprintf-like conversion of format
 * and its arguments.  This exception message string is passed to a pre-set
 * JSErrorReporter function (set by JS_SetErrorReporter).
 */
    #[link_name = "?JS_ReportError@@YAXPEAUJSContext@@PEBDZZ"]
    pub fn JS_ReportError(cx: *mut JSContext,
                          format: *const ::std::os::raw::c_char, ...);
    #[link_name =
          "?JS_ReportErrorNumber@@YAXPEAUJSContext@@P6APEBUJSErrorFormatString@@PEAXI@Z1IZZ"]
    pub fn JS_ReportErrorNumber(cx: *mut JSContext,
                                errorCallback: JSErrorCallback,
                                userRef: *mut ::std::os::raw::c_void,
                                errorNumber: ::std::os::raw::c_uint, ...);
    #[link_name =
          "?JS_ReportErrorNumberUC@@YAXPEAUJSContext@@P6APEBUJSErrorFormatString@@PEAXI@Z1IZZ"]
    pub fn JS_ReportErrorNumberUC(cx: *mut JSContext,
                                  errorCallback: JSErrorCallback,
                                  userRef: *mut ::std::os::raw::c_void,
                                  errorNumber: ::std::os::raw::c_uint, ...);
    #[link_name =
          "?JS_ReportErrorNumberUCArray@@YAXPEAUJSContext@@P6APEBUJSErrorFormatString@@PEAXI@Z1IPEAPEB_S@Z"]
    pub fn JS_ReportErrorNumberUCArray(cx: *mut JSContext,
                                       errorCallback: JSErrorCallback,
                                       userRef: *mut ::std::os::raw::c_void,
                                       errorNumber: ::std::os::raw::c_uint,
                                       args:
                                           *mut *const ::std::os::raw::c_ushort);
    /**
 * As above, but report a warning instead (JSREPORT_IS_WARNING(report.flags)).
 * Return true if there was no error trying to issue the warning, and if the
 * warning was not converted into an error due to the JSOPTION_WERROR option
 * being set, false otherwise.
 */
    #[link_name = "?JS_ReportWarning@@YA_NPEAUJSContext@@PEBDZZ"]
    pub fn JS_ReportWarning(cx: *mut JSContext,
                            format: *const ::std::os::raw::c_char, ...)
     -> bool;
    #[link_name =
          "?JS_ReportErrorFlagsAndNumber@@YA_NPEAUJSContext@@IP6APEBUJSErrorFormatString@@PEAXI@Z1IZZ"]
    pub fn JS_ReportErrorFlagsAndNumber(cx: *mut JSContext,
                                        flags: ::std::os::raw::c_uint,
                                        errorCallback: JSErrorCallback,
                                        userRef: *mut ::std::os::raw::c_void,
                                        errorNumber:
                                            ::std::os::raw::c_uint, ...)
     -> bool;
    #[link_name =
          "?JS_ReportErrorFlagsAndNumberUC@@YA_NPEAUJSContext@@IP6APEBUJSErrorFormatString@@PEAXI@Z1IZZ"]
    pub fn JS_ReportErrorFlagsAndNumberUC(cx: *mut JSContext,
                                          flags: ::std::os::raw::c_uint,
                                          errorCallback: JSErrorCallback,
                                          userRef:
                                              *mut ::std::os::raw::c_void,
                                          errorNumber:
                                              ::std::os::raw::c_uint, ...)
     -> bool;
    /**
 * Complain when out of memory.
 */
    #[link_name = "?JS_ReportOutOfMemory@@YAXPEAUJSContext@@@Z"]
    pub fn JS_ReportOutOfMemory(cx: *mut JSContext);
    /**
 * Complain when an allocation size overflows the maximum supported limit.
 */
    #[link_name = "?JS_ReportAllocationOverflow@@YAXPEAUJSContext@@@Z"]
    pub fn JS_ReportAllocationOverflow(cx: *mut JSContext);
    #[link_name =
          "?JS_GetErrorReporter@@YAP6AXPEAUJSContext@@PEBDPEAVJSErrorReport@@@ZPEAUJSRuntime@@@Z"]
    pub fn JS_GetErrorReporter(rt: *mut JSRuntime) -> JSErrorReporter;
    #[link_name =
          "?JS_SetErrorReporter@@YAP6AXPEAUJSContext@@PEBDPEAVJSErrorReport@@@ZPEAUJSRuntime@@P6AX012@Z@Z"]
    pub fn JS_SetErrorReporter(rt: *mut JSRuntime, er: JSErrorReporter)
     -> JSErrorReporter;
    #[link_name =
          "?CreateError@JS@@YA_NPEAUJSContext@@W4JSExnType@@V?$Handle@PEAVJSObject@@@1@V?$Handle@PEAVJSString@@@1@IIPEAVJSErrorReport@@3V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn CreateError(cx: *mut JSContext, type_: JSExnType,
                       stack: HandleObject, fileName: HandleString,
                       lineNumber: u32, columnNumber: u32,
                       report: *mut JSErrorReport, message: HandleString,
                       rval: MutableHandleValue) -> bool;
    /************************************************************************/
    #[link_name = "?NewWeakMapObject@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn NewWeakMapObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name = "?IsWeakMapObject@JS@@YA_NPEAVJSObject@@@Z"]
    pub fn IsWeakMapObject(obj: *mut JSObject) -> bool;
    #[link_name =
          "?GetWeakMapEntry@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@1V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn GetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject,
                           key: HandleObject, val: MutableHandleValue)
     -> bool;
    #[link_name =
          "?SetWeakMapEntry@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@1V?$Handle@VValue@JS@@@1@@Z"]
    pub fn SetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject,
                           key: HandleObject, val: HandleValue) -> bool;
    #[link_name = "?NewMapObject@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn NewMapObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name =
          "?MapSize@JS@@YAIPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn MapSize(cx: *mut JSContext, obj: HandleObject) -> u32;
    #[link_name =
          "?MapGet@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn MapGet(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: MutableHandleValue) -> bool;
    #[link_name =
          "?MapHas@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@PEA_N@Z"]
    pub fn MapHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: *mut bool) -> bool;
    #[link_name =
          "?MapSet@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@2@Z"]
    pub fn MapSet(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  val: HandleValue) -> bool;
    #[link_name =
          "?MapDelete@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@PEA_N@Z"]
    pub fn MapDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                     rval: *mut bool) -> bool;
    #[link_name =
          "?MapClear@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn MapClear(cx: *mut JSContext, obj: HandleObject) -> bool;
    #[link_name =
          "?MapKeys@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn MapKeys(cx: *mut JSContext, obj: HandleObject,
                   rval: MutableHandleValue) -> bool;
    #[link_name =
          "?MapValues@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn MapValues(cx: *mut JSContext, obj: HandleObject,
                     rval: MutableHandleValue) -> bool;
    #[link_name =
          "?MapEntries@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn MapEntries(cx: *mut JSContext, obj: HandleObject,
                      rval: MutableHandleValue) -> bool;
    #[link_name =
          "?MapForEach@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@2@Z"]
    pub fn MapForEach(cx: *mut JSContext, obj: HandleObject,
                      callbackFn: HandleValue, thisVal: HandleValue) -> bool;
    #[link_name = "?NewSetObject@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn NewSetObject(cx: *mut JSContext) -> *mut JSObject;
    #[link_name =
          "?SetSize@JS@@YAIPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn SetSize(cx: *mut JSContext, obj: HandleObject) -> u32;
    #[link_name =
          "?SetHas@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@PEA_N@Z"]
    pub fn SetHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                  rval: *mut bool) -> bool;
    #[link_name =
          "?SetDelete@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@PEA_N@Z"]
    pub fn SetDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue,
                     rval: *mut bool) -> bool;
    #[link_name =
          "?SetAdd@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@@Z"]
    pub fn SetAdd(cx: *mut JSContext, obj: HandleObject, key: HandleValue)
     -> bool;
    #[link_name =
          "?SetClear@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn SetClear(cx: *mut JSContext, obj: HandleObject) -> bool;
    #[link_name =
          "?SetKeys@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn SetKeys(cx: *mut JSContext, obj: HandleObject,
                   rval: MutableHandleValue) -> bool;
    #[link_name =
          "?SetValues@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn SetValues(cx: *mut JSContext, obj: HandleObject,
                     rval: MutableHandleValue) -> bool;
    #[link_name =
          "?SetEntries@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn SetEntries(cx: *mut JSContext, obj: HandleObject,
                      rval: MutableHandleValue) -> bool;
    #[link_name =
          "?SetForEach@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@VValue@JS@@@1@2@Z"]
    pub fn SetForEach(cx: *mut JSContext, obj: HandleObject,
                      callbackFn: HandleValue, thisVal: HandleValue) -> bool;
    #[link_name =
          "?JS_NewDateObject@@YAPEAVJSObject@@PEAUJSContext@@HHHHHH@Z"]
    pub fn JS_NewDateObject(cx: *mut JSContext, year: ::std::os::raw::c_int,
                            mon: ::std::os::raw::c_int,
                            mday: ::std::os::raw::c_int,
                            hour: ::std::os::raw::c_int,
                            min: ::std::os::raw::c_int,
                            sec: ::std::os::raw::c_int) -> *mut JSObject;
    /**
 * Returns true and sets |*isDate| indicating whether |obj| is a Date object or
 * a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isDate == false| when passed a proxy whose
 * target is a Date, or when passed a revoked proxy.
 */
    #[link_name =
          "?JS_ObjectIsDate@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_ObjectIsDate(cx: *mut JSContext, obj: HandleObject,
                           isDate: *mut bool) -> bool;
    #[link_name =
          "?JS_NewRegExpObject@@YAPEAVJSObject@@PEAUJSContext@@PEBD_KI@Z"]
    pub fn JS_NewRegExpObject(cx: *mut JSContext,
                              bytes: *const ::std::os::raw::c_char,
                              length: usize, flags: ::std::os::raw::c_uint)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUCRegExpObject@@YAPEAVJSObject@@PEAUJSContext@@PEB_S_KI@Z"]
    pub fn JS_NewUCRegExpObject(cx: *mut JSContext,
                                chars: *const ::std::os::raw::c_ushort,
                                length: usize, flags: ::std::os::raw::c_uint)
     -> *mut JSObject;
    #[link_name =
          "?JS_SetRegExpInput@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@PEAVJSString@@@3@@Z"]
    pub fn JS_SetRegExpInput(cx: *mut JSContext, obj: HandleObject,
                             input: HandleString) -> bool;
    #[link_name =
          "?JS_ClearRegExpStatics@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_ClearRegExpStatics(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    #[link_name =
          "?JS_ExecuteRegExp@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1PEA_S_KPEA_K_NV?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ExecuteRegExp(cx: *mut JSContext, obj: HandleObject,
                            reobj: HandleObject,
                            chars: *mut ::std::os::raw::c_ushort,
                            length: usize, indexp: *mut usize, test: bool,
                            rval: MutableHandleValue) -> bool;
    #[link_name =
          "?JS_ExecuteRegExpNoStatics@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_S_KPEA_K_NV?$MutableHandle@VValue@JS@@@3@@Z"]
    pub fn JS_ExecuteRegExpNoStatics(cx: *mut JSContext, reobj: HandleObject,
                                     chars: *mut ::std::os::raw::c_ushort,
                                     length: usize, indexp: *mut usize,
                                     test: bool, rval: MutableHandleValue)
     -> bool;
    /**
 * Returns true and sets |*isRegExp| indicating whether |obj| is a RegExp
 * object or a wrapper around one, otherwise returns false on failure.
 *
 * This method returns true with |*isRegExp == false| when passed a proxy whose
 * target is a RegExp, or when passed a revoked proxy.
 */
    #[link_name =
          "?JS_ObjectIsRegExp@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_ObjectIsRegExp(cx: *mut JSContext, obj: HandleObject,
                             isRegExp: *mut bool) -> bool;
    #[link_name =
          "?JS_GetRegExpFlags@@YAIPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetRegExpFlags(cx: *mut JSContext, obj: HandleObject)
     -> ::std::os::raw::c_uint;
    #[link_name =
          "?JS_GetRegExpSource@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_GetRegExpSource(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSString;
    /************************************************************************/
    #[link_name = "?JS_IsExceptionPending@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_IsExceptionPending(cx: *mut JSContext) -> bool;
    #[link_name =
          "?JS_GetPendingException@@YA_NPEAUJSContext@@V?$MutableHandle@VValue@JS@@@JS@@@Z"]
    pub fn JS_GetPendingException(cx: *mut JSContext, vp: MutableHandleValue)
     -> bool;
    #[link_name =
          "?JS_SetPendingException@@YAXPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn JS_SetPendingException(cx: *mut JSContext, v: HandleValue);
    #[link_name = "?JS_ClearPendingException@@YAXPEAUJSContext@@@Z"]
    pub fn JS_ClearPendingException(cx: *mut JSContext);
    #[link_name = "?JS_ReportPendingException@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_ReportPendingException(cx: *mut JSContext) -> bool;
    #[link_name =
          "?JS_SaveExceptionState@@YAPEAUJSExceptionState@@PEAUJSContext@@@Z"]
    pub fn JS_SaveExceptionState(cx: *mut JSContext) -> *mut JSExceptionState;
    #[link_name =
          "?JS_RestoreExceptionState@@YAXPEAUJSContext@@PEAUJSExceptionState@@@Z"]
    pub fn JS_RestoreExceptionState(cx: *mut JSContext,
                                    state: *mut JSExceptionState);
    #[link_name =
          "?JS_DropExceptionState@@YAXPEAUJSContext@@PEAUJSExceptionState@@@Z"]
    pub fn JS_DropExceptionState(cx: *mut JSContext,
                                 state: *mut JSExceptionState);
    /**
 * If the given object is an exception object, the exception will have (or be
 * able to lazily create) an error report struct, and this function will return
 * the address of that struct.  Otherwise, it returns nullptr. The lifetime
 * of the error report struct that might be returned is the same as the
 * lifetime of the exception object.
 */
    #[link_name =
          "?JS_ErrorFromException@@YAPEAVJSErrorReport@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_ErrorFromException(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSErrorReport;
    /**
 * If the given object is an exception object (or an unwrappable
 * cross-compartment wrapper for one), return the stack for that exception, if
 * any.  Will return null if the given object is not an exception object
 * (including if it's null or a security wrapper that can't be unwrapped) or if
 * the exception has no stack.
 */
    #[link_name =
          "?ExceptionStackOrNull@@YAPEAVJSObject@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn ExceptionStackOrNull(obj: HandleObject) -> *mut JSObject;
    #[link_name = "?JS_ThrowStopIteration@@YA_NPEAUJSContext@@@Z"]
    pub fn JS_ThrowStopIteration(cx: *mut JSContext) -> bool;
    #[link_name = "?JS_IsStopIteration@@YA_NVValue@JS@@@Z"]
    pub fn JS_IsStopIteration(v: Value) -> bool;
    #[link_name = "?JS_GetCurrentThread@@YA_JXZ"]
    pub fn JS_GetCurrentThread() -> isize;
    /**
 * A JS runtime always has an "owner thread". The owner thread is set when the
 * runtime is created (to the current thread) and practically all entry points
 * into the JS engine check that a runtime (or anything contained in the
 * runtime: context, compartment, object, etc) is only touched by its owner
 * thread. Embeddings may check this invariant outside the JS engine by calling
 * JS_AbortIfWrongThread (which will abort if not on the owner thread, even for
 * non-debug builds).
 */
    #[link_name = "?JS_AbortIfWrongThread@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_AbortIfWrongThread(rt: *mut JSRuntime);
    /**
 * A constructor can request that the JS engine create a default new 'this'
 * object of the given class, using the callee to determine parentage and
 * [[Prototype]].
 */
    #[link_name =
          "?JS_NewObjectForConstructor@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@AEBVCallArgs@JS@@@Z"]
    pub fn JS_NewObjectForConstructor(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      args: *const CallArgs) -> *mut JSObject;
    #[link_name = "?JS_GetGCZealBits@@YAXPEAUJSContext@@PEAI11@Z"]
    pub fn JS_GetGCZealBits(cx: *mut JSContext, zealBits: *mut u32,
                            frequency: *mut u32, nextScheduled: *mut u32);
    #[link_name = "?JS_SetGCZeal@@YAXPEAUJSContext@@EI@Z"]
    pub fn JS_SetGCZeal(cx: *mut JSContext, zeal: u8, frequency: u32);
    #[link_name = "?JS_ScheduleGC@@YAXPEAUJSContext@@I@Z"]
    pub fn JS_ScheduleGC(cx: *mut JSContext, count: u32);
    #[link_name = "?JS_SetParallelParsingEnabled@@YAXPEAUJSRuntime@@_N@Z"]
    pub fn JS_SetParallelParsingEnabled(rt: *mut JSRuntime, enabled: bool);
    #[link_name =
          "?JS_SetOffthreadIonCompilationEnabled@@YAXPEAUJSRuntime@@_N@Z"]
    pub fn JS_SetOffthreadIonCompilationEnabled(rt: *mut JSRuntime,
                                                enabled: bool);
    #[link_name =
          "?JS_SetGlobalJitCompilerOption@@YAXPEAUJSRuntime@@W4JSJitCompilerOption@@I@Z"]
    pub fn JS_SetGlobalJitCompilerOption(rt: *mut JSRuntime,
                                         opt: JSJitCompilerOption,
                                         value: u32);
    #[link_name =
          "?JS_GetGlobalJitCompilerOption@@YAHPEAUJSRuntime@@W4JSJitCompilerOption@@@Z"]
    pub fn JS_GetGlobalJitCompilerOption(rt: *mut JSRuntime,
                                         opt: JSJitCompilerOption)
     -> ::std::os::raw::c_int;
    /**
 * Convert a uint32_t index into a jsid.
 */
    #[link_name =
          "?JS_IndexToId@@YA_NPEAUJSContext@@IV?$MutableHandle@Ujsid@@@JS@@@Z"]
    pub fn JS_IndexToId(cx: *mut JSContext, index: u32, arg1: MutableHandleId)
     -> bool;
    /**
 * Convert chars into a jsid.
 *
 * |chars| may not be an index.
 */
    #[link_name =
          "?JS_CharsToId@@YA_NPEAUJSContext@@VTwoByteChars@JS@@V?$MutableHandle@Ujsid@@@3@@Z"]
    pub fn JS_CharsToId(cx: *mut JSContext, chars: TwoByteChars,
                        arg1: MutableHandleId) -> bool;
    /**
 *  Test if the given string is a valid ECMAScript identifier
 */
    #[link_name =
          "?JS_IsIdentifier@@YA_NPEAUJSContext@@V?$Handle@PEAVJSString@@@JS@@PEA_N@Z"]
    pub fn JS_IsIdentifier(cx: *mut JSContext, str: HandleString,
                           isIdentifier: *mut bool) -> bool;
    /**
 * Test whether the given chars + length are a valid ECMAScript identifier.
 * This version is infallible, so just returns whether the chars are an
 * identifier.
 */
    #[link_name = "?JS_IsIdentifier@@YA_NPEB_S_K@Z"]
    pub fn JS_IsIdentifier1(chars: *const ::std::os::raw::c_ushort,
                            length: usize) -> bool;
    /**
 * Return the current filename, line number and column number of the most
 * currently running frame. Returns true if a scripted frame was found, false
 * otherwise.
 *
 * If a the embedding has hidden the scripted caller for the topmost activation
 * record, this will also return false.
 */
    #[link_name =
          "?DescribeScriptedCaller@JS@@YA_NPEAUJSContext@@PEAVAutoFilename@1@PEAI2@Z"]
    pub fn DescribeScriptedCaller(cx: *mut JSContext,
                                  filename: *mut AutoFilename,
                                  lineno: *mut ::std::os::raw::c_uint,
                                  column: *mut ::std::os::raw::c_uint)
     -> bool;
    #[link_name =
          "?GetScriptedCallerGlobal@JS@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn GetScriptedCallerGlobal(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Informs the JS engine that the scripted caller should be hidden. This can be
 * used by the embedding to maintain an override of the scripted caller in its
 * calculations, by hiding the scripted caller in the JS engine and pushing data
 * onto a separate stack, which it inspects when DescribeScriptedCaller returns
 * null.
 *
 * We maintain a counter on each activation record. Add() increments the counter
 * of the topmost activation, and Remove() decrements it. The count may never
 * drop below zero, and must always be exactly zero when the activation is
 * popped from the stack.
 */
    #[link_name = "?HideScriptedCaller@JS@@YAXPEAUJSContext@@@Z"]
    pub fn HideScriptedCaller(cx: *mut JSContext);
    #[link_name = "?UnhideScriptedCaller@JS@@YAXPEAUJSContext@@@Z"]
    pub fn UnhideScriptedCaller(cx: *mut JSContext);
    #[link_name =
          "?JS_EncodeScript@@YAPEAXPEAUJSContext@@V?$Handle@PEAVJSScript@@@JS@@PEAI@Z"]
    pub fn JS_EncodeScript(cx: *mut JSContext, script: HandleScript,
                           lengthp: *mut u32) -> *mut ::std::os::raw::c_void;
    #[link_name =
          "?JS_EncodeInterpretedFunction@@YAPEAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEAI@Z"]
    pub fn JS_EncodeInterpretedFunction(cx: *mut JSContext,
                                        funobj: HandleObject,
                                        lengthp: *mut u32)
     -> *mut ::std::os::raw::c_void;
    #[link_name = "?JS_DecodeScript@@YAPEAVJSScript@@PEAUJSContext@@PEBXI@Z"]
    pub fn JS_DecodeScript(cx: *mut JSContext,
                           data: *const ::std::os::raw::c_void, length: u32)
     -> *mut JSScript;
    #[link_name =
          "?JS_DecodeInterpretedFunction@@YAPEAVJSObject@@PEAUJSContext@@PEBXI@Z"]
    pub fn JS_DecodeInterpretedFunction(cx: *mut JSContext,
                                        data: *const ::std::os::raw::c_void,
                                        length: u32) -> *mut JSObject;
    #[link_name =
          "?SetAsmJSCacheOps@JS@@YAXPEAUJSRuntime@@PEBUAsmJSCacheOps@1@@Z"]
    pub fn SetAsmJSCacheOps(rt: *mut JSRuntime,
                            callbacks: *const AsmJSCacheOps);
    #[link_name =
          "?SetBuildIdOp@JS@@YAXPEAUJSRuntime@@P6A_NPEAV?$Vector@D$0A@VSystemAllocPolicy@js@@@mozilla@@@Z@Z"]
    pub fn SetBuildIdOp(rt: *mut JSRuntime, buildIdOp: BuildIdOp);
    #[link_name =
          "?SetLargeAllocationFailureCallback@JS@@YAXPEAUJSRuntime@@P6AXPEAX@Z1@Z"]
    pub fn SetLargeAllocationFailureCallback(rt: *mut JSRuntime,
                                             afc:
                                                 LargeAllocationFailureCallback,
                                             data:
                                                 *mut ::std::os::raw::c_void);
    #[link_name =
          "?SetOutOfMemoryCallback@JS@@YAXPEAUJSRuntime@@P6AXPEAUJSContext@@PEAX@Z2@Z"]
    pub fn SetOutOfMemoryCallback(rt: *mut JSRuntime, cb: OutOfMemoryCallback,
                                  data: *mut ::std::os::raw::c_void);
    /**
 * Capture the current call stack as a chain of SavedFrame JSObjects, and set
 * |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there
 * are no JS frames on the stack. If |maxFrameCount| is non-zero, capture at
 * most the youngest |maxFrameCount| frames.
 */
    #[link_name =
          "?CaptureCurrentStack@JS@@YA_NPEAUJSContext@@V?$MutableHandle@PEAVJSObject@@@1@I@Z"]
    pub fn CaptureCurrentStack(cx: *mut JSContext,
                               stackp: MutableHandleObject,
                               maxFrameCount: ::std::os::raw::c_uint) -> bool;
    #[link_name =
          "?CopyAsyncStack@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$Handle@PEAVJSString@@@1@V?$MutableHandle@PEAVJSObject@@@1@I@Z"]
    pub fn CopyAsyncStack(cx: *mut JSContext, asyncStack: HandleObject,
                          asyncCause: HandleString,
                          stackp: MutableHandleObject,
                          maxFrameCount: ::std::os::raw::c_uint) -> bool;
    /**
 * Given a SavedFrame JSObject, get its source property. Defaults to the empty
 * string.
 */
    #[link_name =
          "?GetSavedFrameSource@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSString@@@1@W4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameSource(cx: *mut JSContext, savedFrame: HandleObject,
                               sourcep: MutableHandleString,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its line property. Defaults to 0.
 */
    #[link_name =
          "?GetSavedFrameLine@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@PEAIW4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameLine(cx: *mut JSContext, savedFrame: HandleObject,
                             linep: *mut u32,
                             selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its column property. Defaults to 0.
 */
    #[link_name =
          "?GetSavedFrameColumn@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@PEAIW4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameColumn(cx: *mut JSContext, savedFrame: HandleObject,
                               columnp: *mut u32,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr
 * if SpiderMonkey was unable to infer a name for the captured frame's
 * function. Defaults to nullptr.
 */
    #[link_name =
          "?GetSavedFrameFunctionDisplayName@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSString@@@1@W4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameFunctionDisplayName(cx: *mut JSContext,
                                            savedFrame: HandleObject,
                                            namep: MutableHandleString,
                                            selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr.
 */
    #[link_name =
          "?GetSavedFrameAsyncCause@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSString@@@1@W4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameAsyncCause(cx: *mut JSContext,
                                   savedFrame: HandleObject,
                                   asyncCausep: MutableHandleString,
                                   selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr
 * if there is no asyncParent. The `asyncParentp` out parameter is _NOT_
 * guaranteed to be in the cx's compartment. Defaults to nullptr.
 */
    #[link_name =
          "?GetSavedFrameAsyncParent@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSObject@@@1@W4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameAsyncParent(cx: *mut JSContext,
                                    savedFrame: HandleObject,
                                    asyncParentp: MutableHandleObject,
                                    selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if
 * it is the oldest frame in the stack. The `parentp` out parameter is _NOT_
 * guaranteed to be in the cx's compartment. Defaults to nullptr.
 */
    #[link_name =
          "?GetSavedFrameParent@JS@@YA?AW4SavedFrameResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSObject@@@1@W4SavedFrameSelfHosted@1@@Z"]
    pub fn GetSavedFrameParent(cx: *mut JSContext, savedFrame: HandleObject,
                               parentp: MutableHandleObject,
                               selfHosted: SavedFrameSelfHosted)
     -> SavedFrameResult;
    /**
 * Given a SavedFrame JSObject stack, stringify it in the same format as
 * Error.prototype.stack. The stringified stack out parameter is placed in the
 * cx's compartment. Defaults to the empty string.
 *
 * The same notes above about SavedFrame accessors applies here as well: cx
 * doesn't need to be in stack's compartment, and stack can be null, a
 * SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.
 *
 * Optional indent parameter specifies the number of white spaces to indent
 * each line.
 */
    #[link_name =
          "?BuildStackString@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@V?$MutableHandle@PEAVJSString@@@1@_K@Z"]
    pub fn BuildStackString(cx: *mut JSContext, stack: HandleObject,
                            stringp: MutableHandleString, indent: usize)
     -> bool;
    /**
 * Commit any Performance Monitoring data.
 *
 * Until `FlushMonitoring` has been called, all PerformanceMonitoring data is invisible
 * to the outside world and can cancelled with a call to `ResetMonitoring`.
 */
    #[link_name = "?FlushPerformanceMonitoring@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn FlushPerformanceMonitoring(arg1: *mut JSRuntime) -> bool;
    /**
 * Cancel any measurement that hasn't been committed.
 */
    #[link_name = "?ResetPerformanceMonitoring@js@@YAXPEAUJSRuntime@@@Z"]
    pub fn ResetPerformanceMonitoring(arg1: *mut JSRuntime);
    /**
 * Cleanup any memory used by performance monitoring.
 */
    #[link_name = "?DisposePerformanceMonitoring@js@@YAXPEAUJSRuntime@@@Z"]
    pub fn DisposePerformanceMonitoring(arg1: *mut JSRuntime);
    /**
 * Turn on/off stopwatch-based CPU monitoring.
 *
 * `SetStopwatchIsMonitoringCPOW` or `SetStopwatchIsMonitoringJank`
 * may return `false` if monitoring could not be activated, which may
 * happen if we are out of memory.
 */
    #[link_name = "?SetStopwatchIsMonitoringCPOW@js@@YA_NPEAUJSRuntime@@_N@Z"]
    pub fn SetStopwatchIsMonitoringCPOW(arg1: *mut JSRuntime, arg2: bool)
     -> bool;
    #[link_name = "?GetStopwatchIsMonitoringCPOW@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn GetStopwatchIsMonitoringCPOW(arg1: *mut JSRuntime) -> bool;
    #[link_name = "?SetStopwatchIsMonitoringJank@js@@YA_NPEAUJSRuntime@@_N@Z"]
    pub fn SetStopwatchIsMonitoringJank(arg1: *mut JSRuntime, arg2: bool)
     -> bool;
    #[link_name = "?GetStopwatchIsMonitoringJank@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn GetStopwatchIsMonitoringJank(arg1: *mut JSRuntime) -> bool;
    #[link_name = "?IsStopwatchActive@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn IsStopwatchActive(arg1: *mut JSRuntime) -> bool;
    #[link_name =
          "?GetPerfMonitoringTestCpuRescheduling@js@@YAXPEAUJSRuntime@@PEA_K1@Z"]
    pub fn GetPerfMonitoringTestCpuRescheduling(arg1: *mut JSRuntime,
                                                stayed: *mut u64,
                                                moved: *mut u64);
    /**
 * Add a number of microseconds to the time spent waiting on CPOWs
 * since process start.
 */
    #[link_name = "?AddCPOWPerformanceDelta@js@@YAXPEAUJSRuntime@@_K@Z"]
    pub fn AddCPOWPerformanceDelta(arg1: *mut JSRuntime, delta: u64);
    #[link_name =
          "?SetStopwatchStartCallback@js@@YA_NPEAUJSRuntime@@P6A_N_KPEAX@Z2@Z"]
    pub fn SetStopwatchStartCallback(arg1: *mut JSRuntime,
                                     arg2: StopwatchStartCallback,
                                     arg3: *mut ::std::os::raw::c_void)
     -> bool;
    #[link_name =
          "?CallMethodIfWrapped@detail@JS@@YA_NPEAUJSContext@@P6A_NV?$Handle@VValue@JS@@@2@@ZP6A_N0AEBVCallArgs@2@@Z3@Z"]
    pub fn CallMethodIfWrapped(cx: *mut JSContext, test: IsAcceptableThis,
                               impl_: NativeImpl, args: *const CallArgs)
     -> bool;
    #[link_name =
          "?JS_SetGrayGCRootsTracer@@YAXPEAUJSRuntime@@P6AXPEAVJSTracer@@PEAX@Z2@Z"]
    pub fn JS_SetGrayGCRootsTracer(rt: *mut JSRuntime, traceOp: JSTraceDataOp,
                                   data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_FindCompilationScope@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_FindCompilationScope(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSObject;
    #[link_name = "?JS_GetObjectFunction@@YAPEAVJSFunction@@PEAVJSObject@@@Z"]
    pub fn JS_GetObjectFunction(obj: *mut JSObject) -> *mut JSFunction;
    #[link_name =
          "?JS_SplicePrototype@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_SplicePrototype(cx: *mut JSContext, obj: HandleObject,
                              proto: HandleObject) -> bool;
    #[link_name =
          "?JS_NewObjectWithUniqueType@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewObjectWithUniqueType(cx: *mut JSContext,
                                      clasp: *const JSClass,
                                      proto: HandleObject) -> *mut JSObject;
    /**
 * Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but
 * without invoking the metadata callback on it.  This allows creation of
 * internal bookkeeping objects that are guaranteed to not have metadata
 * attached to them.
 */
    #[link_name =
          "?JS_NewObjectWithoutMetadata@@YAPEAVJSObject@@PEAUJSContext@@PEBUJSClass@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewObjectWithoutMetadata(cx: *mut JSContext,
                                       clasp: *const JSClass,
                                       proto: Handle<*mut JSObject>)
     -> *mut JSObject;
    #[link_name =
          "?JS_ObjectCountDynamicSlots@@YAIV?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_ObjectCountDynamicSlots(obj: HandleObject) -> u32;
    #[link_name = "?JS_SetProtoCalled@@YA_KPEAUJSContext@@@Z"]
    pub fn JS_SetProtoCalled(cx: *mut JSContext) -> usize;
    #[link_name = "?JS_ImmutablePrototypesEnabled@@YA_NXZ"]
    pub fn JS_ImmutablePrototypesEnabled() -> bool;
    #[link_name = "?JS_GetCustomIteratorCount@@YA_KPEAUJSContext@@@Z"]
    pub fn JS_GetCustomIteratorCount(cx: *mut JSContext) -> usize;
    #[link_name =
          "?JS_NondeterministicGetWeakMapKeys@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@PEAVJSObject@@@3@@Z"]
    pub fn JS_NondeterministicGetWeakMapKeys(cx: *mut JSContext,
                                             obj: HandleObject,
                                             ret: MutableHandleObject)
     -> bool;
    #[link_name =
          "?JS_NondeterministicGetWeakSetKeys@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@PEAVJSObject@@@3@@Z"]
    pub fn JS_NondeterministicGetWeakSetKeys(cx: *mut JSContext,
                                             obj: HandleObject,
                                             ret: MutableHandleObject)
     -> bool;
    #[link_name = "?JS_PCToLineNumber@@YAIPEAVJSScript@@PEAEPEAI@Z"]
    pub fn JS_PCToLineNumber(script: *mut JSScript, pc: *mut jsbytecode,
                             columnp: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    /**
 * Determine whether the given object is backed by a DeadObjectProxy.
 *
 * Such objects hold no other objects (they have no outgoing reference edges)
 * and will throw if you touch them (e.g. by reading/writing a property).
 */
    #[link_name = "?JS_IsDeadWrapper@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsDeadWrapper(obj: *mut JSObject) -> bool;
    #[link_name =
          "?JS_TraceShapeCycleCollectorChildren@@YAXPEAVCallbackTracer@JS@@VGCCellPtr@2@@Z"]
    pub fn JS_TraceShapeCycleCollectorChildren(trc: *mut CallbackTracer,
                                               shape: GCCellPtr);
    #[link_name =
          "?JS_TraceObjectGroupCycleCollectorChildren@@YAXPEAVCallbackTracer@JS@@VGCCellPtr@2@@Z"]
    pub fn JS_TraceObjectGroupCycleCollectorChildren(trc: *mut CallbackTracer,
                                                     group: GCCellPtr);
    #[link_name =
          "?JS_SetAccumulateTelemetryCallback@@YAXPEAUJSRuntime@@P6AXHIPEBD@Z@Z"]
    pub fn JS_SetAccumulateTelemetryCallback(rt: *mut JSRuntime,
                                             callback:
                                                 JSAccumulateTelemetryDataCallback);
    #[link_name =
          "?JS_GetCompartmentPrincipals@@YAPEAUJSPrincipals@@PEAUJSCompartment@@@Z"]
    pub fn JS_GetCompartmentPrincipals(compartment: *mut JSCompartment)
     -> *mut JSPrincipals;
    #[link_name =
          "?JS_SetCompartmentPrincipals@@YAXPEAUJSCompartment@@PEAUJSPrincipals@@@Z"]
    pub fn JS_SetCompartmentPrincipals(compartment: *mut JSCompartment,
                                       principals: *mut JSPrincipals);
    #[link_name =
          "?JS_GetScriptPrincipals@@YAPEAUJSPrincipals@@PEAVJSScript@@@Z"]
    pub fn JS_GetScriptPrincipals(script: *mut JSScript) -> *mut JSPrincipals;
    #[link_name = "?JS_ScriptHasMutedErrors@@YA_NPEAVJSScript@@@Z"]
    pub fn JS_ScriptHasMutedErrors(script: *mut JSScript) -> bool;
    #[link_name =
          "?JS_CloneObject@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_CloneObject(cx: *mut JSContext, obj: HandleObject,
                          proto: HandleObject) -> *mut JSObject;
    /**
 * Copy the own properties of src to dst in a fast way.  src and dst must both
 * be native and must be in the compartment of cx.  They must have the same
 * class, the same parent, and the same prototype.  Class reserved slots will
 * NOT be copied.
 *
 * dst must not have any properties on it before this function is called.
 *
 * src must have been allocated via JS_NewObjectWithoutMetadata so that we can
 * be sure it has no metadata that needs copying to dst.  This also means that
 * dst needs to have the compartment global as its parent.  This function will
 * preserve the existing metadata on dst, if any.
 */
    #[link_name =
          "?JS_InitializePropertiesFromCompatibleNativeObject@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx:
                                                                 *mut JSContext,
                                                             dst:
                                                                 HandleObject,
                                                             src:
                                                                 HandleObject)
     -> bool;
    #[link_name =
          "?JS_BasicObjectToString@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_BasicObjectToString(cx: *mut JSContext, obj: HandleObject)
     -> *mut JSString;
    #[link_name =
          "?GetBuiltinClass@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEAW4ESClassValue@1@@Z"]
    pub fn GetBuiltinClass(cx: *mut JSContext, obj: HandleObject,
                           classValue: *mut ESClassValue) -> bool;
    #[link_name =
          "?ObjectClassName@js@@YAPEBDPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn ObjectClassName(cx: *mut JSContext, obj: HandleObject)
     -> *const ::std::os::raw::c_char;
    #[link_name = "?ReportOverRecursed@js@@YAXPEAUJSContext@@@Z"]
    pub fn ReportOverRecursed(maybecx: *mut JSContext);
    #[link_name =
          "?AddRawValueRoot@js@@YA_NPEAUJSContext@@PEAVValue@JS@@PEBD@Z"]
    pub fn AddRawValueRoot(cx: *mut JSContext, vp: *mut Value,
                           name: *const ::std::os::raw::c_char) -> bool;
    #[link_name =
          "?RemoveRawValueRoot@js@@YAXPEAUJSContext@@PEAVValue@JS@@@Z"]
    pub fn RemoveRawValueRoot(cx: *mut JSContext, vp: *mut Value);
    #[link_name =
          "?GetPropertyNameFromPC@js@@YAPEAVJSAtom@@PEAVJSScript@@PEAE@Z"]
    pub fn GetPropertyNameFromPC(script: *mut JSScript, pc: *mut jsbytecode)
     -> *mut JSAtom;
    #[link_name = "?DumpString@js@@YAXPEAVJSString@@@Z"]
    pub fn DumpString(str: *mut JSString);
    #[link_name = "?DumpAtom@js@@YAXPEAVJSAtom@@@Z"]
    pub fn DumpAtom(atom: *mut JSAtom);
    #[link_name = "?DumpObject@js@@YAXPEAVJSObject@@@Z"]
    pub fn DumpObject(obj: *mut JSObject);
    #[link_name = "?DumpChars@js@@YAXPEB_S_K@Z"]
    pub fn DumpChars(s: *const ::std::os::raw::c_ushort, n: usize);
    #[link_name = "?DumpValue@js@@YAXAEBVValue@JS@@@Z"]
    pub fn DumpValue(val: *const Value);
    #[link_name = "?DumpId@js@@YAXUjsid@@@Z"]
    pub fn DumpId(id: jsid);
    #[link_name =
          "?DumpInterpreterFrame@js@@YAXPEAUJSContext@@PEAVInterpreterFrame@1@@Z"]
    pub fn DumpInterpreterFrame(cx: *mut JSContext,
                                start: *mut InterpreterFrame);
    #[link_name = "?DumpPC@js@@YA_NPEAUJSContext@@@Z"]
    pub fn DumpPC(cx: *mut JSContext) -> bool;
    #[link_name = "?DumpScript@js@@YA_NPEAUJSContext@@PEAVJSScript@@@Z"]
    pub fn DumpScript(cx: *mut JSContext, scriptArg: *mut JSScript) -> bool;
    #[link_name = "?DumpBacktrace@js@@YAXPEAUJSContext@@@Z"]
    pub fn DumpBacktrace(cx: *mut JSContext);
    /** Exposed for DumpJSStack */
    #[link_name = "?FormatStackDump@JS@@YAPEADPEAUJSContext@@PEAD_N22@Z"]
    pub fn FormatStackDump(cx: *mut JSContext,
                           buf: *mut ::std::os::raw::c_char, showArgs: bool,
                           showLocals: bool, showThisProps: bool)
     -> *mut ::std::os::raw::c_char;
    /**
 * Set all of the uninitialized lexicals on an object to undefined. Return
 * true if any lexicals were initialized and false otherwise.
 * */
    #[link_name =
          "?ForceLexicalInitialization@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@@Z"]
    pub fn ForceLexicalInitialization(cx: *mut JSContext, obj: HandleObject)
     -> bool;
    /**
 * Copies all own properties from |obj| to |target|. |obj| must be a "native"
 * object (that is to say, normal-ish - not an Array or a Proxy).
 *
 * This function immediately enters a compartment, and does not impose any
 * restrictions on the compartment of |cx|.
 */
    #[link_name =
          "?JS_CopyPropertiesFrom@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn JS_CopyPropertiesFrom(cx: *mut JSContext, target: HandleObject,
                                 obj: HandleObject) -> bool;
    #[link_name =
          "?JS_CopyPropertyFrom@@YA_NPEAUJSContext@@V?$Handle@Ujsid@@@JS@@V?$Handle@PEAVJSObject@@@3@2W4PropertyCopyBehavior@@@Z"]
    pub fn JS_CopyPropertyFrom(cx: *mut JSContext, id: HandleId,
                               target: HandleObject, obj: HandleObject,
                               copyBehavior: PropertyCopyBehavior) -> bool;
    #[link_name =
          "?JS_WrapPropertyDescriptor@@YA_NPEAUJSContext@@V?$MutableHandle@UPropertyDescriptor@JS@@@JS@@@Z"]
    pub fn JS_WrapPropertyDescriptor(cx: *mut JSContext,
                                     desc: MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "?JS_DefineFunctionsWithHelp@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEBUJSFunctionSpecWithHelp@@@Z"]
    pub fn JS_DefineFunctionsWithHelp(cx: *mut JSContext, obj: HandleObject,
                                      fs: *const JSFunctionSpecWithHelp)
     -> bool;
    #[link_name =
          "?proxy_LookupProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@V?$MutableHandle@PEAVJSObject@@@4@V?$MutableHandle@PEAVShape@js@@@4@@Z"]
    pub fn proxy_LookupProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId, objp: MutableHandleObject,
                                propp: MutableHandle<*mut Shape>) -> bool;
    #[link_name =
          "?proxy_DefineProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@V?$Handle@UPropertyDescriptor@JS@@@4@AEAVObjectOpResult@4@@Z"]
    pub fn proxy_DefineProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId,
                                desc: Handle<PropertyDescriptor>,
                                result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "?proxy_HasProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@PEA_N@Z"]
    pub fn proxy_HasProperty(cx: *mut JSContext, obj: HandleObject,
                             id: HandleId, foundp: *mut bool) -> bool;
    #[link_name =
          "?proxy_GetProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@VValue@JS@@@4@V?$Handle@Ujsid@@@4@V?$MutableHandle@VValue@JS@@@4@@Z"]
    pub fn proxy_GetProperty(cx: *mut JSContext, obj: HandleObject,
                             receiver: HandleValue, id: HandleId,
                             vp: MutableHandleValue) -> bool;
    #[link_name =
          "?proxy_SetProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@V?$Handle@VValue@JS@@@4@3AEAVObjectOpResult@4@@Z"]
    pub fn proxy_SetProperty(cx: *mut JSContext, obj: HandleObject,
                             id: HandleId, bp: HandleValue,
                             receiver: HandleValue,
                             result: *mut ObjectOpResult) -> bool;
    #[link_name =
          "?proxy_GetOwnPropertyDescriptor@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@V?$MutableHandle@UPropertyDescriptor@JS@@@4@@Z"]
    pub fn proxy_GetOwnPropertyDescriptor(cx: *mut JSContext,
                                          obj: HandleObject, id: HandleId,
                                          desc:
                                              MutableHandle<PropertyDescriptor>)
     -> bool;
    #[link_name =
          "?proxy_DeleteProperty@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@AEAVObjectOpResult@4@@Z"]
    pub fn proxy_DeleteProperty(cx: *mut JSContext, obj: HandleObject,
                                id: HandleId, result: *mut ObjectOpResult)
     -> bool;
    #[link_name = "?proxy_Trace@js@@YAXPEAVJSTracer@@PEAVJSObject@@@Z"]
    pub fn proxy_Trace(trc: *mut JSTracer, obj: *mut JSObject);
    #[link_name = "?proxy_WeakmapKeyDelegate@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn proxy_WeakmapKeyDelegate(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?proxy_Convert@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@W4JSType@@V?$MutableHandle@VValue@JS@@@4@@Z"]
    pub fn proxy_Convert(cx: *mut JSContext, proxy: HandleObject,
                         hint: JSType, vp: MutableHandleValue) -> bool;
    #[link_name = "?proxy_Finalize@js@@YAXPEAVFreeOp@1@PEAVJSObject@@@Z"]
    pub fn proxy_Finalize(fop: *mut FreeOp, obj: *mut JSObject);
    #[link_name = "?proxy_ObjectMoved@js@@YAXPEAVJSObject@@PEBV2@@Z"]
    pub fn proxy_ObjectMoved(obj: *mut JSObject, old: *const JSObject);
    #[link_name =
          "?proxy_HasInstance@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@VValue@JS@@@4@PEA_N@Z"]
    pub fn proxy_HasInstance(cx: *mut JSContext, proxy: HandleObject,
                             v: MutableHandleValue, bp: *mut bool) -> bool;
    #[link_name = "?proxy_Call@js@@YA_NPEAUJSContext@@IPEAVValue@JS@@@Z"]
    pub fn proxy_Call(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                      vp: *mut Value) -> bool;
    #[link_name = "?proxy_Construct@js@@YA_NPEAUJSContext@@IPEAVValue@JS@@@Z"]
    pub fn proxy_Construct(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                           vp: *mut Value) -> bool;
    #[link_name = "?proxy_innerObject@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn proxy_innerObject(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?proxy_Watch@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@1@Z"]
    pub fn proxy_Watch(cx: *mut JSContext, obj: HandleObject, id: HandleId,
                       callable: HandleObject) -> bool;
    #[link_name =
          "?proxy_Unwatch@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@@Z"]
    pub fn proxy_Unwatch(cx: *mut JSContext, obj: HandleObject, id: HandleId)
     -> bool;
    #[link_name =
          "?proxy_GetElements@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IIPEAVElementAdder@1@@Z"]
    pub fn proxy_GetElements(cx: *mut JSContext, proxy: HandleObject,
                             begin: u32, end: u32, adder: *mut ElementAdder)
     -> bool;
    #[link_name =
          "?proxy_FunToString@js@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@I@Z"]
    pub fn proxy_FunToString(cx: *mut JSContext, proxy: HandleObject,
                             indent: ::std::os::raw::c_uint) -> *mut JSString;
    #[link_name =
          "?GetCompartmentZone@js@@YAPEAUZone@JS@@PEAUJSCompartment@@@Z"]
    pub fn GetCompartmentZone(comp: *mut JSCompartment) -> *mut Zone;
    /**
  * Dump the complete object graph of heap-allocated things.
  * fp is the file for the dump output.
  */
    #[link_name =
          "?DumpHeap@js@@YAXPEAUJSRuntime@@PEAU_iobuf@@W4DumpHeapNurseryBehaviour@1@@Z"]
    pub fn DumpHeap(rt: *mut JSRuntime, fp: *mut FILE,
                    nurseryBehaviour: DumpHeapNurseryBehaviour);
    #[link_name =
          "?obj_defineGetter@js@@YA_NPEAUJSContext@@IPEAVValue@JS@@@Z"]
    pub fn obj_defineGetter(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                            vp: *mut Value) -> bool;
    #[link_name =
          "?obj_defineSetter@js@@YA_NPEAUJSContext@@IPEAVValue@JS@@@Z"]
    pub fn obj_defineSetter(cx: *mut JSContext, argc: ::std::os::raw::c_uint,
                            vp: *mut Value) -> bool;
    #[link_name = "?IsSystemCompartment@js@@YA_NPEAUJSCompartment@@@Z"]
    pub fn IsSystemCompartment(comp: *mut JSCompartment) -> bool;
    #[link_name = "?IsSystemZone@js@@YA_NPEAUZone@JS@@@Z"]
    pub fn IsSystemZone(zone: *mut Zone) -> bool;
    #[link_name = "?IsAtomsCompartment@js@@YA_NPEAUJSCompartment@@@Z"]
    pub fn IsAtomsCompartment(comp: *mut JSCompartment) -> bool;
    #[link_name = "?IsAtomsZone@js@@YA_NPEAUZone@JS@@@Z"]
    pub fn IsAtomsZone(zone: *mut Zone) -> bool;
    #[link_name = "?TraceWeakMaps@js@@YAXPEAUWeakMapTracer@1@@Z"]
    pub fn TraceWeakMaps(trc: *mut WeakMapTracer);
    #[link_name = "?AreGCGrayBitsValid@js@@YA_NPEAUJSRuntime@@@Z"]
    pub fn AreGCGrayBitsValid(rt: *mut JSRuntime) -> bool;
    #[link_name = "?ZoneGlobalsAreAllGray@js@@YA_NPEAUZone@JS@@@Z"]
    pub fn ZoneGlobalsAreAllGray(zone: *mut Zone) -> bool;
    #[link_name =
          "?VisitGrayWrapperTargets@js@@YAXPEAUZone@JS@@P6AXPEAXVGCCellPtr@3@@Z1@Z"]
    pub fn VisitGrayWrapperTargets(zone: *mut Zone, callback: GCThingCallback,
                                   closure: *mut ::std::os::raw::c_void);
    #[link_name = "?GetWeakmapKeyDelegate@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn GetWeakmapKeyDelegate(key: *mut JSObject) -> *mut JSObject;
    #[link_name = "?GCThingTraceKind@js@@YA?AW4TraceKind@JS@@PEAX@Z"]
    pub fn GCThingTraceKind(thing: *mut ::std::os::raw::c_void) -> TraceKind;
    /**
 * Invoke cellCallback on every gray JS_OBJECT in the given zone.
 */
    #[link_name =
          "?IterateGrayObjects@js@@YAXPEAUZone@JS@@P6AXPEAXVGCCellPtr@3@@Z1@Z"]
    pub fn IterateGrayObjects(zone: *mut Zone, cellCallback: GCThingCallback,
                              data: *mut ::std::os::raw::c_void);
    #[link_name =
          "?GetAnyCompartmentInZone@js@@YAPEAUJSCompartment@@PEAUZone@JS@@@Z"]
    pub fn GetAnyCompartmentInZone(zone: *mut Zone) -> *mut JSCompartment;
    #[link_name = "?ProtoKeyToClass@js@@YAPEBUClass@1@W4JSProtoKey@@@Z"]
    pub fn ProtoKeyToClass(key: JSProtoKey) -> *const Class;
    #[link_name = "?IsFunctionObject@js@@YA_NPEAVJSObject@@@Z"]
    pub fn IsFunctionObject(obj: *mut JSObject) -> bool;
    #[link_name =
          "?GetGlobalForObjectCrossCompartment@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn GetGlobalForObjectCrossCompartment(obj: *mut JSObject)
     -> *mut JSObject;
    #[link_name = "?GetPrototypeNoProxy@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn GetPrototypeNoProxy(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?AssertSameCompartment@js@@YAXPEAUJSContext@@PEAVJSObject@@@Z"]
    pub fn AssertSameCompartment(cx: *mut JSContext, obj: *mut JSObject);
    #[link_name = "?AssertSameCompartment@js@@YAXPEAVJSObject@@0@Z"]
    pub fn AssertSameCompartment1(objA: *mut JSObject, objB: *mut JSObject);
    #[link_name = "?NotifyAnimationActivity@js@@YAXPEAVJSObject@@@Z"]
    pub fn NotifyAnimationActivity(obj: *mut JSObject);
    /**
 * Return the outermost enclosing function (script) of the scripted caller.
 * This function returns nullptr in several cases:
 *  - no script is running on the context
 *  - the caller is in global or eval code
 * In particular, this function will "stop" its outermost search at eval() and
 * thus it will really return the outermost enclosing function *since the
 * innermost eval*.
 */
    #[link_name =
          "?GetOutermostEnclosingFunctionOfScriptedCaller@js@@YAPEAVJSFunction@@PEAUJSContext@@@Z"]
    pub fn GetOutermostEnclosingFunctionOfScriptedCaller(cx: *mut JSContext)
     -> *mut JSFunction;
    #[link_name =
          "?DefineFunctionWithReserved@js@@YAPEAVJSFunction@@PEAUJSContext@@PEAVJSObject@@PEBDP6A_N0IPEAVValue@JS@@@ZII@Z"]
    pub fn DefineFunctionWithReserved(cx: *mut JSContext, obj: *mut JSObject,
                                      name: *const ::std::os::raw::c_char,
                                      call: JSNative,
                                      nargs: ::std::os::raw::c_uint,
                                      attrs: ::std::os::raw::c_uint)
     -> *mut JSFunction;
    #[link_name =
          "?NewFunctionWithReserved@js@@YAPEAVJSFunction@@PEAUJSContext@@P6A_N0IPEAVValue@JS@@@ZIIPEBD@Z"]
    pub fn NewFunctionWithReserved(cx: *mut JSContext, call: JSNative,
                                   nargs: ::std::os::raw::c_uint,
                                   flags: ::std::os::raw::c_uint,
                                   name: *const ::std::os::raw::c_char)
     -> *mut JSFunction;
    #[link_name =
          "?NewFunctionByIdWithReserved@js@@YAPEAVJSFunction@@PEAUJSContext@@P6A_N0IPEAVValue@JS@@@ZIIUjsid@@@Z"]
    pub fn NewFunctionByIdWithReserved(cx: *mut JSContext, native: JSNative,
                                       nargs: ::std::os::raw::c_uint,
                                       flags: ::std::os::raw::c_uint,
                                       id: jsid) -> *mut JSFunction;
    #[link_name =
          "?GetFunctionNativeReserved@js@@YAAEBVValue@JS@@PEAVJSObject@@_K@Z"]
    pub fn GetFunctionNativeReserved(fun: *mut JSObject, which: usize)
     -> *const Value;
    #[link_name =
          "?SetFunctionNativeReserved@js@@YAXPEAVJSObject@@_KAEBVValue@JS@@@Z"]
    pub fn SetFunctionNativeReserved(fun: *mut JSObject, which: usize,
                                     val: *const Value);
    #[link_name = "?FunctionHasNativeReserved@js@@YA_NPEAVJSObject@@@Z"]
    pub fn FunctionHasNativeReserved(fun: *mut JSObject) -> bool;
    #[link_name =
          "?GetObjectProto@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@PEAVJSObject@@@4@@Z"]
    pub fn GetObjectProto(cx: *mut JSContext, obj: HandleObject,
                          proto: MutableHandleObject) -> bool;
    #[link_name =
          "?GetOriginalEval@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$MutableHandle@PEAVJSObject@@@4@@Z"]
    pub fn GetOriginalEval(cx: *mut JSContext, scope: HandleObject,
                           eval: MutableHandleObject) -> bool;
    #[link_name =
          "?SetReservedOrProxyPrivateSlotWithBarrier@js@@YAXPEAVJSObject@@_KAEBVValue@JS@@@Z"]
    pub fn SetReservedOrProxyPrivateSlotWithBarrier(obj: *mut JSObject,
                                                    slot: usize,
                                                    value: *const Value);
    #[link_name = "?GetObjectSlotSpan@js@@YAIPEAVJSObject@@@Z"]
    pub fn GetObjectSlotSpan(obj: *mut JSObject) -> u32;
    #[link_name =
          "?StringToLinearStringSlow@js@@YAPEAVJSLinearString@@PEAUJSContext@@PEAVJSString@@@Z"]
    pub fn StringToLinearStringSlow(cx: *mut JSContext, str: *mut JSString)
     -> *mut JSLinearString;
    /**
 * Add some or all property keys of obj to the id vector *props.
 *
 * The flags parameter controls which property keys are added. Pass a
 * combination of the following bits:
 *
 *     JSITER_OWNONLY - Don't also search the prototype chain; only consider
 *       obj's own properties.
 *
 *     JSITER_HIDDEN - Include nonenumerable properties.
 *
 *     JSITER_SYMBOLS - Include property keys that are symbols. The default
 *       behavior is to filter out symbols.
 *
 *     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.
 *
 * This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or
 * equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass
 * `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get
 * results that match the output of Reflect.ownKeys.
 */
    #[link_name =
          "?GetPropertyKeys@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IPEAV?$AutoVectorRooter@Ujsid@@@4@@Z"]
    pub fn GetPropertyKeys(cx: *mut JSContext, obj: HandleObject,
                           flags: ::std::os::raw::c_uint,
                           props: *mut AutoIdVector) -> bool;
    #[link_name =
          "?AppendUnique@js@@YA_NPEAUJSContext@@AEAV?$AutoVectorRooter@Ujsid@@@JS@@1@Z"]
    pub fn AppendUnique(cx: *mut JSContext, base: *mut AutoIdVector,
                        others: *mut AutoIdVector) -> bool;
    #[link_name = "?StringIsArrayIndex@js@@YA_NPEAVJSLinearString@@PEAI@Z"]
    pub fn StringIsArrayIndex(str: *mut JSLinearString, indexp: *mut u32)
     -> bool;
    #[link_name =
          "?SetPreserveWrapperCallback@js@@YAXPEAUJSRuntime@@P6A_NPEAUJSContext@@PEAVJSObject@@@Z@Z"]
    pub fn SetPreserveWrapperCallback(rt: *mut JSRuntime,
                                      callback: PreserveWrapperCallback);
    #[link_name =
          "?IsObjectInContextCompartment@js@@YA_NPEAVJSObject@@PEBUJSContext@@@Z"]
    pub fn IsObjectInContextCompartment(obj: *mut JSObject,
                                        cx: *const JSContext) -> bool;
    #[link_name = "?RunningWithTrustedPrincipals@js@@YA_NPEAUJSContext@@@Z"]
    pub fn RunningWithTrustedPrincipals(cx: *mut JSContext) -> bool;
    #[link_name = "?StartPCCountProfiling@js@@YAXPEAUJSContext@@@Z"]
    pub fn StartPCCountProfiling(cx: *mut JSContext);
    #[link_name = "?StopPCCountProfiling@js@@YAXPEAUJSContext@@@Z"]
    pub fn StopPCCountProfiling(cx: *mut JSContext);
    #[link_name = "?PurgePCCounts@js@@YAXPEAUJSContext@@@Z"]
    pub fn PurgePCCounts(cx: *mut JSContext);
    #[link_name = "?GetPCCountScriptCount@js@@YA_KPEAUJSContext@@@Z"]
    pub fn GetPCCountScriptCount(cx: *mut JSContext) -> usize;
    #[link_name =
          "?GetPCCountScriptSummary@js@@YAPEAVJSString@@PEAUJSContext@@_K@Z"]
    pub fn GetPCCountScriptSummary(cx: *mut JSContext, script: usize)
     -> *mut JSString;
    #[link_name =
          "?GetPCCountScriptContents@js@@YAPEAVJSString@@PEAUJSContext@@_K@Z"]
    pub fn GetPCCountScriptContents(cx: *mut JSContext, script: usize)
     -> *mut JSString;
    /**
 * Generate lcov trace file content for the current compartment, and allocate a
 * new buffer and return the content in it, the size of the newly allocated
 * content within the buffer would be set to the length out-param.
 *
 * In case of out-of-memory, this function returns nullptr and does not set any
 * value to the length out-param.
 */
    #[link_name = "?GetCodeCoverageSummary@js@@YAPEADPEAUJSContext@@PEA_K@Z"]
    pub fn GetCodeCoverageSummary(cx: *mut JSContext, length: *mut usize)
     -> *mut ::std::os::raw::c_char;
    #[link_name = "?ContextHasOutstandingRequests@js@@YA_NPEBUJSContext@@@Z"]
    pub fn ContextHasOutstandingRequests(cx: *const JSContext) -> bool;
    /**
 * Sets a callback that is run whenever the runtime goes idle - the
 * last active request ceases - and begins activity - when it was
 * idle and a request begins.
 */
    #[link_name =
          "?SetActivityCallback@js@@YAXPEAUJSRuntime@@P6AXPEAX_N@Z1@Z"]
    pub fn SetActivityCallback(rt: *mut JSRuntime, cb: ActivityCallback,
                               arg: *mut ::std::os::raw::c_void);
    #[link_name =
          "?SetDOMCallbacks@js@@YAXPEAUJSRuntime@@PEBUJSDOMCallbacks@1@@Z"]
    pub fn SetDOMCallbacks(rt: *mut JSRuntime,
                           callbacks: *const DOMCallbacks);
    #[link_name =
          "?GetDOMCallbacks@js@@YAPEBUJSDOMCallbacks@1@PEAUJSRuntime@@@Z"]
    pub fn GetDOMCallbacks(rt: *mut JSRuntime) -> *const DOMCallbacks;
    #[link_name =
          "?GetTestingFunctions@js@@YAPEAVJSObject@@PEAUJSContext@@@Z"]
    pub fn GetTestingFunctions(cx: *mut JSContext) -> *mut JSObject;
    /**
 * Get an error type name from a JSExnType constant.
 * Returns nullptr for invalid arguments and JSEXN_INTERNALERR
 */
    #[link_name =
          "?GetErrorTypeName@js@@YAPEAVJSFlatString@@PEAUJSRuntime@@F@Z"]
    pub fn GetErrorTypeName(rt: *mut JSRuntime, exnType: i16)
     -> *mut JSFlatString;
    #[link_name = "?GetEnterCompartmentDepth@js@@YAIPEAUJSContext@@@Z"]
    pub fn GetEnterCompartmentDepth(cx: *mut JSContext)
     -> ::std::os::raw::c_uint;
    #[link_name =
          "?RegExpToSharedNonInline@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEAVRegExpGuard@1@@Z"]
    pub fn RegExpToSharedNonInline(cx: *mut JSContext, regexp: HandleObject,
                                   shared: *mut RegExpGuard) -> bool;
    #[link_name =
          "?NukeCrossCompartmentWrappers@js@@YA_NPEAUJSContext@@AEBUCompartmentFilter@1@1W4NukeReferencesToWindow@1@@Z"]
    pub fn NukeCrossCompartmentWrappers(cx: *mut JSContext,
                                        sourceFilter:
                                            *const CompartmentFilter,
                                        targetFilter:
                                            *const CompartmentFilter,
                                        nukeReferencesToWindow:
                                            NukeReferencesToWindow) -> bool;
    #[link_name =
          "?SetDOMProxyInformation@js@@YAXPEBXIP6A?AW4DOMProxyShadowsResult@1@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@5@@Z@Z"]
    pub fn SetDOMProxyInformation(domProxyHandlerFamily:
                                      *const ::std::os::raw::c_void,
                                  domProxyExpandoSlot: u32,
                                  domProxyShadowsCheck: DOMProxyShadowsCheck);
    /** Detect whether the internal date value is NaN. */
    #[link_name =
          "?DateIsValid@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn DateIsValid(cx: *mut JSContext, obj: HandleObject,
                       isValid: *mut bool) -> bool;
    #[link_name =
          "?DateGetMsecSinceEpoch@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEAN@Z"]
    pub fn DateGetMsecSinceEpoch(cx: *mut JSContext, obj: HandleObject,
                                 msecSinceEpoch: *mut f64) -> bool;
    #[link_name = "?GetErrorMessage@js@@YAPEBUJSErrorFormatString@@PEAXI@Z"]
    pub fn GetErrorMessage(userRef: *mut ::std::os::raw::c_void,
                           errorNumber: ::std::os::raw::c_uint)
     -> *const JSErrorFormatString;
    #[link_name = "?GetSCOffset@js@@YA_KPEAUJSStructuredCloneWriter@@@Z"]
    pub fn GetSCOffset(writer: *mut JSStructuredCloneWriter) -> u64;
    #[link_name = "?JS_NewInt8Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewInt8Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewUint8Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewUint8Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint8ClampedArray@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewUint8ClampedArray(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewInt16Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewInt16Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewUint16Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewUint16Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewInt32Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewInt32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewUint32Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewUint32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewFloat32Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewFloat32Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name = "?JS_NewFloat64Array@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewFloat64Array(cx: *mut JSContext, nelements: u32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewInt8ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewInt8ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint8ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewUint8ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint8ClampedArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewUint8ClampedArrayFromArray(cx: *mut JSContext,
                                            array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewInt16ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewInt16ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint16ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewUint16ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewInt32ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewInt32ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint32ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewUint32ArrayFromArray(cx: *mut JSContext, array: HandleObject)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewFloat32ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewFloat32ArrayFromArray(cx: *mut JSContext,
                                       array: HandleObject) -> *mut JSObject;
    #[link_name =
          "?JS_NewFloat64ArrayFromArray@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@@Z"]
    pub fn JS_NewFloat64ArrayFromArray(cx: *mut JSContext,
                                       array: HandleObject) -> *mut JSObject;
    #[link_name =
          "?JS_NewInt8ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewInt8ArrayWithBuffer(cx: *mut JSContext,
                                     arrayBuffer: HandleObject,
                                     byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint8ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewUint8ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint8ClampedArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewUint8ClampedArrayWithBuffer(cx: *mut JSContext,
                                             arrayBuffer: HandleObject,
                                             byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewInt16ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewInt16ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint16ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewUint16ArrayWithBuffer(cx: *mut JSContext,
                                       arrayBuffer: HandleObject,
                                       byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewInt32ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewInt32ArrayWithBuffer(cx: *mut JSContext,
                                      arrayBuffer: HandleObject,
                                      byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewUint32ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewUint32ArrayWithBuffer(cx: *mut JSContext,
                                       arrayBuffer: HandleObject,
                                       byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewFloat32ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewFloat32ArrayWithBuffer(cx: *mut JSContext,
                                        arrayBuffer: HandleObject,
                                        byteOffset: u32, length: i32)
     -> *mut JSObject;
    #[link_name =
          "?JS_NewFloat64ArrayWithBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewFloat64ArrayWithBuffer(cx: *mut JSContext,
                                        arrayBuffer: HandleObject,
                                        byteOffset: u32, length: i32)
     -> *mut JSObject;
    /**
 * Create a new SharedArrayBuffer with the given byte length.  This
 * may only be called if
 * JS::CompartmentCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
 * true.
 */
    #[link_name =
          "?JS_NewSharedArrayBuffer@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewSharedArrayBuffer(cx: *mut JSContext, nbytes: u32)
     -> *mut JSObject;
    /**
 * Create a new ArrayBuffer with the given byte length.
 */
    #[link_name = "?JS_NewArrayBuffer@@YAPEAVJSObject@@PEAUJSContext@@I@Z"]
    pub fn JS_NewArrayBuffer(cx: *mut JSContext, nbytes: u32)
     -> *mut JSObject;
    /**
 * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
 * false if a security wrapper is encountered that denies the unwrapping. If
 * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
 * the various accessor JSAPI calls defined below.
 */
    #[link_name = "?JS_IsTypedArrayObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsTypedArrayObject(obj: *mut JSObject) -> bool;
    /**
 * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
 * return false if a security wrapper is encountered that denies the
 * unwrapping. If this test or one of the more specific tests succeeds, then it
 * is safe to call the various ArrayBufferView accessor JSAPI calls defined
 * below.
 */
    #[link_name = "?JS_IsArrayBufferViewObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsArrayBufferViewObject(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsInt8Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsInt8Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsUint8Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsUint8Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsUint8ClampedArray@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsUint8ClampedArray(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsInt16Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsInt16Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsUint16Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsUint16Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsInt32Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsInt32Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsUint32Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsUint32Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsFloat32Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsFloat32Array(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsFloat64Array@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsFloat64Array(obj: *mut JSObject) -> bool;
    /**
 * Return the isShared flag of a typed array, which denotes whether
 * the underlying buffer is a SharedArrayBuffer.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetTypedArraySharedness@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_GetTypedArraySharedness(obj: *mut JSObject) -> bool;
    #[link_name = "?UnwrapInt8Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapInt8Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapUint8Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapUint8Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapUint8ClampedArray@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapUint8ClampedArray(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapInt16Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapInt16Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapUint16Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapUint16Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapInt32Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapInt32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapUint32Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapUint32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapFloat32Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapFloat32Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapFloat64Array@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapFloat64Array(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapArrayBuffer@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapArrayBuffer(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapArrayBufferView@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapArrayBufferView(obj: *mut JSObject) -> *mut JSObject;
    #[link_name = "?UnwrapSharedArrayBuffer@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn UnwrapSharedArrayBuffer(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?GetArrayBufferViewLengthAndData@js@@YAXPEAVJSObject@@PEAIPEA_NPEAPEAE@Z"]
    pub fn GetArrayBufferViewLengthAndData(obj: *mut JSObject,
                                           length: *mut u32,
                                           isSharedMemory: *mut bool,
                                           data: *mut *mut u8);
    #[link_name =
          "?GetArrayBufferLengthAndData@js@@YAXPEAVJSObject@@PEAIPEA_NPEAPEAE@Z"]
    pub fn GetArrayBufferLengthAndData(obj: *mut JSObject, length: *mut u32,
                                       isSharedMemory: *mut bool,
                                       data: *mut *mut u8);
    #[link_name =
          "?GetSharedArrayBufferLengthAndData@js@@YAXPEAVJSObject@@PEAIPEA_NPEAPEAE@Z"]
    pub fn GetSharedArrayBufferLengthAndData(obj: *mut JSObject,
                                             length: *mut u32,
                                             isSharedMemory: *mut bool,
                                             data: *mut *mut u8);
    #[link_name =
          "?JS_GetSharedArrayBufferData@@YAPEAEPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetSharedArrayBufferData(obj: *mut JSObject,
                                       isSharedMemory: *mut bool,
                                       arg1: *const AutoCheckCannotGC)
     -> *mut u8;
    #[link_name =
          "?JS_GetObjectAsInt8Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAC@Z"]
    pub fn JS_GetObjectAsInt8Array(obj: *mut JSObject, length: *mut u32,
                                   isSharedMemory: *mut bool,
                                   data: *mut *mut i8) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsUint8Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAE@Z"]
    pub fn JS_GetObjectAsUint8Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut u8) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsUint8ClampedArray@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAE@Z"]
    pub fn JS_GetObjectAsUint8ClampedArray(obj: *mut JSObject,
                                           length: *mut u32,
                                           isSharedMemory: *mut bool,
                                           data: *mut *mut u8)
     -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsInt16Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAF@Z"]
    pub fn JS_GetObjectAsInt16Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut i16) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsUint16Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAG@Z"]
    pub fn JS_GetObjectAsUint16Array(obj: *mut JSObject, length: *mut u32,
                                     isSharedMemory: *mut bool,
                                     data: *mut *mut u16) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsInt32Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAH@Z"]
    pub fn JS_GetObjectAsInt32Array(obj: *mut JSObject, length: *mut u32,
                                    isSharedMemory: *mut bool,
                                    data: *mut *mut i32) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsUint32Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAI@Z"]
    pub fn JS_GetObjectAsUint32Array(obj: *mut JSObject, length: *mut u32,
                                     isSharedMemory: *mut bool,
                                     data: *mut *mut u32) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsFloat32Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAM@Z"]
    pub fn JS_GetObjectAsFloat32Array(obj: *mut JSObject, length: *mut u32,
                                      isSharedMemory: *mut bool,
                                      data: *mut *mut f32) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsFloat64Array@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAN@Z"]
    pub fn JS_GetObjectAsFloat64Array(obj: *mut JSObject, length: *mut u32,
                                      isSharedMemory: *mut bool,
                                      data: *mut *mut f64) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsArrayBufferView@@YAPEAVJSObject@@PEAV1@PEAIPEA_NPEAPEAE@Z"]
    pub fn JS_GetObjectAsArrayBufferView(obj: *mut JSObject, length: *mut u32,
                                         isSharedMemory: *mut bool,
                                         data: *mut *mut u8) -> *mut JSObject;
    #[link_name =
          "?JS_GetObjectAsArrayBuffer@@YAPEAVJSObject@@PEAV1@PEAIPEAPEAE@Z"]
    pub fn JS_GetObjectAsArrayBuffer(obj: *mut JSObject, length: *mut u32,
                                     data: *mut *mut u8) -> *mut JSObject;
    #[link_name =
          "?JS_GetArrayBufferViewType@@YA?AW4Type@Scalar@js@@PEAVJSObject@@@Z"]
    pub fn JS_GetArrayBufferViewType(obj: *mut JSObject) -> Type;
    #[link_name =
          "?JS_GetSharedArrayBufferViewType@@YA?AW4Type@Scalar@js@@PEAVJSObject@@@Z"]
    pub fn JS_GetSharedArrayBufferViewType(obj: *mut JSObject) -> Type;
    #[link_name = "?JS_IsArrayBufferObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsArrayBufferObject(obj: *mut JSObject) -> bool;
    #[link_name = "?JS_IsSharedArrayBufferObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsSharedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Return the available byte length of an array buffer.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetArrayBufferByteLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetArrayBufferByteLength(obj: *mut JSObject) -> u32;
    #[link_name = "?JS_GetSharedArrayBufferByteLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetSharedArrayBufferByteLength(obj: *mut JSObject) -> u32;
    /**
 * Return true if the arrayBuffer contains any data. This will return false for
 * ArrayBuffer.prototype and detached ArrayBuffers.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 */
    #[link_name = "?JS_ArrayBufferHasData@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_ArrayBufferHasData(obj: *mut JSObject) -> bool;
    /**
 * Return a pointer to the start of the data referenced by a typed array. The
 * data is still owned by the typed array, and should not be modified on
 * another thread. Furthermore, the pointer can become invalid on GC (if the
 * data is small and fits inside the array's GC header), so callers must take
 * care not to hold on across anything that could GC.
 *
 * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 * ArrayBuffer, and the unwrapping will succeed.
 *
 * *isSharedMemory will be set to false, the argument is present to simplify
 * its use from code that also interacts with SharedArrayBuffer.
 */
    #[link_name =
          "?JS_GetArrayBufferData@@YAPEAEPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetArrayBufferData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u8;
    /**
 * Check whether the obj is ArrayBufferObject and memory mapped. Note that this
 * may return false if a security wrapper is encountered that denies the
 * unwrapping.
 */
    #[link_name = "?JS_IsMappedArrayBufferObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsMappedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Return the number of elements in a typed array.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetTypedArrayLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetTypedArrayLength(obj: *mut JSObject) -> u32;
    /**
 * Return the byte offset from the start of an array buffer to the start of a
 * typed array view.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetTypedArrayByteOffset@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetTypedArrayByteOffset(obj: *mut JSObject) -> u32;
    /**
 * Return the byte length of a typed array.
 *
 * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 * be known that it would pass such a test: it is a typed array or a wrapper of
 * a typed array, and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetTypedArrayByteLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetTypedArrayByteLength(obj: *mut JSObject) -> u32;
    /**
 * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
 */
    #[link_name = "?JS_GetArrayBufferViewByteLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetArrayBufferViewByteLength(obj: *mut JSObject) -> u32;
    #[link_name =
          "?JS_GetInt8ArrayData@@YAPEACPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetInt8ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                               arg1: *const AutoCheckCannotGC) -> *mut i8;
    #[link_name =
          "?JS_GetUint8ArrayData@@YAPEAEPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetUint8ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut u8;
    #[link_name =
          "?JS_GetUint8ClampedArrayData@@YAPEAEPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetUint8ClampedArrayData(obj: *mut JSObject,
                                       isSharedMemory: *mut bool,
                                       arg1: *const AutoCheckCannotGC)
     -> *mut u8;
    #[link_name =
          "?JS_GetInt16ArrayData@@YAPEAFPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetInt16ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut i16;
    #[link_name =
          "?JS_GetUint16ArrayData@@YAPEAGPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetUint16ArrayData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u16;
    #[link_name =
          "?JS_GetInt32ArrayData@@YAPEAHPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetInt32ArrayData(obj: *mut JSObject, isSharedMemory: *mut bool,
                                arg1: *const AutoCheckCannotGC) -> *mut i32;
    #[link_name =
          "?JS_GetUint32ArrayData@@YAPEAIPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetUint32ArrayData(obj: *mut JSObject,
                                 isSharedMemory: *mut bool,
                                 arg1: *const AutoCheckCannotGC) -> *mut u32;
    #[link_name =
          "?JS_GetFloat32ArrayData@@YAPEAMPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetFloat32ArrayData(obj: *mut JSObject,
                                  isSharedMemory: *mut bool,
                                  arg1: *const AutoCheckCannotGC) -> *mut f32;
    #[link_name =
          "?JS_GetFloat64ArrayData@@YAPEANPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetFloat64ArrayData(obj: *mut JSObject,
                                  isSharedMemory: *mut bool,
                                  arg1: *const AutoCheckCannotGC) -> *mut f64;
    /**
 * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
 * versions when possible.
 */
    #[link_name =
          "?JS_GetArrayBufferViewData@@YAPEAXPEAVJSObject@@PEA_NAEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetArrayBufferViewData(obj: *mut JSObject,
                                     isSharedMemory: *mut bool,
                                     arg1: *const AutoCheckCannotGC)
     -> *mut ::std::os::raw::c_void;
    /**
 * Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.
 * This may return a detached buffer.  |obj| must be an object that would
 * return true for JS_IsArrayBufferViewObject().
 */
    #[link_name =
          "?JS_GetArrayBufferViewBuffer@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@PEA_N@Z"]
    pub fn JS_GetArrayBufferViewBuffer(cx: *mut JSContext, obj: HandleObject,
                                       isSharedMemory: *mut bool)
     -> *mut JSObject;
    /**
 * Detach an ArrayBuffer, causing all associated views to no longer refer to
 * the ArrayBuffer's original attached memory.
 *
 * The |changeData| argument is a hint to inform internal behavior with respect
 * to the ArrayBuffer's internal pointer to associated data.  |ChangeData|
 * attempts to set the internal pointer to fresh memory of the same size as the
 * original memory; |KeepData| attempts to preserve the original pointer, even
 * while the ArrayBuffer appears observably detached.  There is no guarantee
 * this parameter is respected -- it's only a hint.
 */
    #[link_name =
          "?JS_DetachArrayBuffer@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@W4DetachDataDisposition@@@Z"]
    pub fn JS_DetachArrayBuffer(cx: *mut JSContext, obj: HandleObject,
                                changeData: DetachDataDisposition) -> bool;
    /**
 * Check whether the obj is a detached ArrayBufferObject. Note that this may
 * return false if a security wrapper is encountered that denies the
 * unwrapping.
 */
    #[link_name = "?JS_IsDetachedArrayBufferObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsDetachedArrayBufferObject(obj: *mut JSObject) -> bool;
    /**
 * Check whether obj supports JS_GetDataView* APIs.
 */
    #[link_name = "?JS_IsDataViewObject@@YA_NPEAVJSObject@@@Z"]
    pub fn JS_IsDataViewObject(obj: *mut JSObject) -> bool;
    /**
 * Create a new DataView using the given ArrayBuffer for storage. The given
 * buffer must be an ArrayBuffer (or a cross-compartment wrapper of an
 * ArrayBuffer), and the offset and length must fit within the bounds of the
 * arrayBuffer. Currently, nullptr will be returned and an exception will be
 * thrown if these conditions do not hold, but do not depend on that behavior.
 */
    #[link_name =
          "?JS_NewDataView@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@IH@Z"]
    pub fn JS_NewDataView(cx: *mut JSContext, arrayBuffer: HandleObject,
                          byteOffset: u32, byteLength: i32) -> *mut JSObject;
    /**
 * Return the byte offset of a data view into its array buffer. |obj| must be a
 * DataView.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed.
 */
    #[link_name = "?JS_GetDataViewByteOffset@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetDataViewByteOffset(obj: *mut JSObject) -> u32;
    /**
 * Return the byte length of a data view.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
 * unable to assert when unwrapping should be disallowed.
 */
    #[link_name = "?JS_GetDataViewByteLength@@YAIPEAVJSObject@@@Z"]
    pub fn JS_GetDataViewByteLength(obj: *mut JSObject) -> u32;
    /**
 * Return a pointer to the beginning of the data referenced by a DataView.
 *
 * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 * it would pass such a test: it is a data view or a wrapper of a data view,
 * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
 * unable to assert when unwrapping should be disallowed.
 */
    #[link_name =
          "?JS_GetDataViewData@@YAPEAXPEAVJSObject@@AEBVAutoCheckCannotGC@JS@@@Z"]
    pub fn JS_GetDataViewData(obj: *mut JSObject,
                              arg1: *const AutoCheckCannotGC)
     -> *mut ::std::os::raw::c_void;
    /**
 * Add a watchpoint -- in the Object.prototype.watch sense -- to |obj| for the
 * property |id|, using the callable object |callable| as the function to be
 * called for notifications.
 *
 * This is an internal function exposed -- temporarily -- only so that DOM
 * proxies can be watchable.  Don't use it!  We'll soon kill off the
 * Object.prototype.{,un}watch functions, at which point this will go too.
 */
    #[link_name =
          "?WatchGuts@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@1@Z"]
    pub fn WatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId,
                     callable: HandleObject) -> bool;
    /**
 * Remove a watchpoint -- in the Object.prototype.watch sense -- from |obj| for
 * the property |id|.
 *
 * This is an internal function exposed -- temporarily -- only so that DOM
 * proxies can be watchable.  Don't use it!  We'll soon kill off the
 * Object.prototype.{,un}watch functions, at which point this will go too.
 */
    #[link_name =
          "?UnwatchGuts@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@@Z"]
    pub fn UnwatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId)
     -> bool;
    #[link_name =
          "?PrepareScriptEnvironmentAndInvoke@js@@YAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@AEAUClosure@ScriptEnvironmentPreparer@1@@Z"]
    pub fn PrepareScriptEnvironmentAndInvoke(cx: *mut JSContext,
                                             scope: HandleObject,
                                             closure:
                                                 *mut ScriptEnvironmentPreparer_Closure);
    #[link_name =
          "?SetScriptEnvironmentPreparer@js@@YAXPEAUJSRuntime@@PEAUScriptEnvironmentPreparer@1@@Z"]
    pub fn SetScriptEnvironmentPreparer(rt: *mut JSRuntime,
                                        preparer:
                                            *mut ScriptEnvironmentPreparer);
    /**
 * Sets a callback that is run whenever js-ctypes is about to be used when
 * calling into C.
 */
    #[link_name =
          "?SetCTypesActivityCallback@js@@YAXPEAUJSRuntime@@P6AXPEAUJSContext@@W4CTypesActivityType@1@@Z@Z"]
    pub fn SetCTypesActivityCallback(rt: *mut JSRuntime,
                                     cb: CTypesActivityCallback);
    /**
 * Specify a callback to invoke when creating each JS object in the current
 * compartment, which may return a metadata object to associate with the
 * object.
 */
    #[link_name =
          "?SetObjectMetadataCallback@js@@YAXPEAUJSContext@@P6APEAVJSObject@@0V?$Handle@PEAVJSObject@@@JS@@@Z@Z"]
    pub fn SetObjectMetadataCallback(cx: *mut JSContext,
                                     callback: ObjectMetadataCallback);
    /** Get the metadata associated with an object. */
    #[link_name = "?GetObjectMetadata@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn GetObjectMetadata(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?GetElementsWithAdder@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1IIPEAVElementAdder@1@@Z"]
    pub fn GetElementsWithAdder(cx: *mut JSContext, obj: HandleObject,
                                receiver: HandleObject, begin: u32, end: u32,
                                adder: *mut ElementAdder) -> bool;
    #[link_name =
          "?ForwardToNative@js@@YA_NPEAUJSContext@@P6A_N0IPEAVValue@JS@@@ZAEBVCallArgs@4@@Z"]
    pub fn ForwardToNative(cx: *mut JSContext, native: JSNative,
                           args: *const CallArgs) -> bool;
    /**
 * Helper function for HTMLDocument and HTMLFormElement.
 *
 * These are the only two interfaces that have [OverrideBuiltins], a named
 * getter, and no named setter. They're implemented as proxies with a custom
 * getOwnPropertyDescriptor() method. Unfortunately, overriding
 * getOwnPropertyDescriptor() automatically affects the behavior of set(),
 * which normally is just common sense but is *not* desired for these two
 * interfaces.
 *
 * The fix is for these two interfaces to override set() to ignore the
 * getOwnPropertyDescriptor() override.
 *
 * SetPropertyIgnoringNamedGetter is exposed to make it easier to override
 * set() in this way.  It carries out all the steps of BaseProxyHandler::set()
 * except the initial getOwnPropertyDescriptor() call.  The caller must supply
 * that descriptor as the 'ownDesc' parameter.
 *
 * Implemented in proxy/BaseProxyHandler.cpp.
 */
    #[link_name =
          "?SetPropertyIgnoringNamedGetter@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@Ujsid@@@4@V?$Handle@VValue@JS@@@4@3V?$Handle@UPropertyDescriptor@JS@@@4@AEAVObjectOpResult@4@@Z"]
    pub fn SetPropertyIgnoringNamedGetter(cx: *mut JSContext,
                                          obj: HandleObject, id: HandleId,
                                          v: HandleValue,
                                          receiver: HandleValue,
                                          ownDesc: Handle<PropertyDescriptor>,
                                          result: *mut ObjectOpResult)
     -> bool;
    #[link_name =
          "?ReportErrorWithId@js@@YAXPEAUJSContext@@PEBDV?$Handle@Ujsid@@@JS@@@Z"]
    pub fn ReportErrorWithId(cx: *mut JSContext,
                             msg: *const ::std::os::raw::c_char,
                             id: HandleId);
    #[link_name =
          "?ExecuteInGlobalAndReturnScope@js@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@V?$Handle@PEAVJSScript@@@4@V?$MutableHandle@PEAVJSObject@@@4@@Z"]
    pub fn ExecuteInGlobalAndReturnScope(cx: *mut JSContext,
                                         obj: HandleObject,
                                         script: HandleScript,
                                         scope: MutableHandleObject) -> bool;
    /**
 * Get the nearest enclosing with scope object for a given function. If the
 * function is not scripted or is not enclosed by a with scope, returns the
 * global.
 */
    #[link_name =
          "?GetNearestEnclosingWithScopeObjectForFunction@js@@YAPEAVJSObject@@PEAVJSFunction@@@Z"]
    pub fn GetNearestEnclosingWithScopeObjectForFunction(fun: *mut JSFunction)
     -> *mut JSObject;
    /**
 * Get the first SavedFrame object in this SavedFrame stack whose principals are
 * subsumed by the cx's principals. If there is no such frame, return nullptr.
 *
 * Do NOT pass a non-SavedFrame object here.
 *
 * The savedFrame and cx do not need to be in the same compartment.
 */
    #[link_name =
          "?GetFirstSubsumedSavedFrame@js@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@W4SavedFrameSelfHosted@5@@Z"]
    pub fn GetFirstSubsumedSavedFrame(cx: *mut JSContext,
                                      savedFrame: HandleObject,
                                      selfHosted: SavedFrameSelfHosted)
     -> *mut JSObject;
    #[link_name =
          "?ReportIsNotFunction@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn ReportIsNotFunction(cx: *mut JSContext, v: HandleValue) -> bool;
    #[link_name =
          "?ConvertArgsToArray@js@@YAPEAVJSObject@@PEAUJSContext@@AEBVCallArgs@JS@@@Z"]
    pub fn ConvertArgsToArray(cx: *mut JSContext, args: *const CallArgs)
     -> *mut JSObject;
    /**
 * Tell the JS engine which Class is used for WindowProxy objects. Used by the
 * functions below.
 */
    #[link_name = "?SetWindowProxyClass@js@@YAXPEAUJSRuntime@@PEBUClass@1@@Z"]
    pub fn SetWindowProxyClass(rt: *mut JSRuntime, clasp: *const Class);
    /**
 * Associates a WindowProxy with a Window (global object). `windowProxy` must
 * have the Class set by SetWindowProxyClass.
 */
    #[link_name =
          "?SetWindowProxy@js@@YAXPEAUJSContext@@V?$Handle@PEAVJSObject@@@JS@@1@Z"]
    pub fn SetWindowProxy(cx: *mut JSContext, global: HandleObject,
                          windowProxy: HandleObject);
    #[link_name = "?IsWindowSlow@detail@js@@YA_NPEAVJSObject@@@Z"]
    pub fn IsWindowSlow(obj: *mut JSObject) -> bool;
    /**
 * Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass).
 */
    #[link_name = "?IsWindowProxy@js@@YA_NPEAVJSObject@@@Z"]
    pub fn IsWindowProxy(obj: *mut JSObject) -> bool;
    /**
 * If `obj` is a Window, get its associated WindowProxy (or a CCW or dead
 * wrapper if the page was navigated away from), else return `obj`. This
 * function is infallible and never returns nullptr.
 */
    #[link_name = "?ToWindowProxyIfWindow@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn ToWindowProxyIfWindow(obj: *mut JSObject) -> *mut JSObject;
    /**
 * If `obj` is a WindowProxy, get its associated Window (the compartment's
 * global), else return `obj`. This function is infallible and never returns
 * nullptr.
 */
    #[link_name = "?ToWindowIfWindowProxy@js@@YAPEAVJSObject@@PEAV2@@Z"]
    pub fn ToWindowIfWindowProxy(obj: *mut JSObject) -> *mut JSObject;
    #[link_name =
          "?JS_StoreObjectPostBarrierCallback@@YAXPEAUJSContext@@P6AXPEAVJSTracer@@PEAVJSObject@@PEAX@Z23@Z"]
    pub fn JS_StoreObjectPostBarrierCallback(cx: *mut JSContext,
                                             callback:
                                                 ::std::option::Option<unsafe extern "C" fn(trc:
                                                                                                *mut JSTracer,
                                                                                            key:
                                                                                                *mut JSObject,
                                                                                            data:
                                                                                                *mut ::std::os::raw::c_void)>,
                                             key: *mut JSObject,
                                             data:
                                                 *mut ::std::os::raw::c_void);
    #[link_name =
          "?JS_StoreStringPostBarrierCallback@@YAXPEAUJSContext@@P6AXPEAVJSTracer@@PEAVJSString@@PEAX@Z23@Z"]
    pub fn JS_StoreStringPostBarrierCallback(cx: *mut JSContext,
                                             callback:
                                                 ::std::option::Option<unsafe extern "C" fn(trc:
                                                                                                *mut JSTracer,
                                                                                            key:
                                                                                                *mut JSString,
                                                                                            data:
                                                                                                *mut ::std::os::raw::c_void)>,
                                             key: *mut JSString,
                                             data:
                                                 *mut ::std::os::raw::c_void);
    /**
 * Forcibly clear postbarrier callbacks queued by the previous two methods.
 * This should be used when the object owning the postbarriered pointers is
 * being destroyed outside of a garbage collection.
 *
 * This currently works by performing a minor GC.
 */
    #[link_name = "?JS_ClearAllPostBarrierCallbacks@@YAXPEAUJSRuntime@@@Z"]
    pub fn JS_ClearAllPostBarrierCallbacks(rt: *mut JSRuntime);
    #[link_name = "?ToBooleanSlow@js@@YA_NV?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn ToBooleanSlow(v: HandleValue) -> bool;
    #[link_name = "?ToNumberSlow@js@@YA_NPEAUJSContext@@VValue@JS@@PEAN@Z"]
    pub fn ToNumberSlow(cx: *mut JSContext, v: Value, dp: *mut f64) -> bool;
    #[link_name =
          "?ToInt8Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAC@Z"]
    pub fn ToInt8Slow(cx: *mut JSContext, v: HandleValue, out: *mut i8)
     -> bool;
    #[link_name =
          "?ToUint8Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAE@Z"]
    pub fn ToUint8Slow(cx: *mut JSContext, v: HandleValue, out: *mut u8)
     -> bool;
    #[link_name =
          "?ToInt16Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAF@Z"]
    pub fn ToInt16Slow(cx: *mut JSContext, v: HandleValue, out: *mut i16)
     -> bool;
    #[link_name =
          "?ToInt32Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAH@Z"]
    pub fn ToInt32Slow(cx: *mut JSContext, v: HandleValue, out: *mut i32)
     -> bool;
    #[link_name =
          "?ToUint32Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAI@Z"]
    pub fn ToUint32Slow(cx: *mut JSContext, v: HandleValue, out: *mut u32)
     -> bool;
    #[link_name =
          "?ToUint16Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEAG@Z"]
    pub fn ToUint16Slow(cx: *mut JSContext, v: HandleValue, out: *mut u16)
     -> bool;
    #[link_name =
          "?ToInt64Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEA_J@Z"]
    pub fn ToInt64Slow(cx: *mut JSContext, v: HandleValue, out: *mut i64)
     -> bool;
    #[link_name =
          "?ToUint64Slow@js@@YA_NPEAUJSContext@@V?$Handle@VValue@JS@@@JS@@PEA_K@Z"]
    pub fn ToUint64Slow(cx: *mut JSContext, v: HandleValue, out: *mut u64)
     -> bool;
    #[link_name =
          "?ToStringSlow@js@@YAPEAVJSString@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@@Z"]
    pub fn ToStringSlow(cx: *mut JSContext, v: HandleValue) -> *mut JSString;
    #[link_name =
          "?ToObjectSlow@js@@YAPEAVJSObject@@PEAUJSContext@@V?$Handle@VValue@JS@@@JS@@_N@Z"]
    pub fn ToObjectSlow(cx: *mut JSContext, v: HandleValue,
                        reportScanStack: bool) -> *mut JSObject;
    /**
 * Assert that we're not doing GC on cx, that we're in a request as
 * needed, and that the compartments for cx and v are correct.
 * Also check that GC would be safe at this point.
 */
    #[link_name =
          "?AssertArgumentsAreSane@detail@JS@@YAXPEAUJSContext@@V?$Handle@VValue@JS@@@2@@Z"]
    pub fn AssertArgumentsAreSane(cx: *mut JSContext, v: HandleValue);
    /**
 * ES6 draft 20141224, 7.1.1, second algorithm.
 *
 * Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString
 * instead.  This will typically only be called from custom convert hooks that
 * wish to fall back to the ES6 default conversion behavior shared by most
 * objects in JS, codified as OrdinaryToPrimitive.
 */
    #[link_name =
          "?OrdinaryToPrimitive@JS@@YA_NPEAUJSContext@@V?$Handle@PEAVJSObject@@@1@W4JSType@@V?$MutableHandle@VValue@JS@@@1@@Z"]
    pub fn OrdinaryToPrimitive(cx: *mut JSContext, obj: HandleObject,
                               type_: JSType, vp: MutableHandleValue) -> bool;
    /**
 * This function can be used to track memory used by ICU.  If it is called, it
 * *must* be called before JS_Init.  Don't use it unless you know what you're
 * doing!
 */
    #[link_name =
          "?JS_SetICUMemoryFunctions@@YA_NP6APEAXPEBX_K@ZP6APEAX0PEAX1@ZP6AX03@Z@Z"]
    pub fn JS_SetICUMemoryFunctions(allocFn: JS_ICUAllocFn,
                                    reallocFn: JS_ICUReallocFn,
                                    freeFn: JS_ICUFreeFn) -> bool;
    /**
 * Initialize SpiderMonkey, returning true only if initialization succeeded.
 * Once this method has succeeded, it is safe to call JS_NewRuntime and other
 * JSAPI methods.
 *
 * This method must be called before any other JSAPI method is used on any
 * thread.  Once it has been used, it is safe to call any JSAPI method, and it
 * remains safe to do so until JS_ShutDown is correctly called.
 *
 * It is currently not possible to initialize SpiderMonkey multiple times (that
 * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
 * again).  This restriction may eventually be lifted.
 */
    #[link_name = "?JS_Init@@YA_NXZ"]
    pub fn JS_Init() -> bool;
    /**
 * Destroy free-standing resources allocated by SpiderMonkey, not associated
 * with any runtime, context, or other structure.
 *
 * This method should be called after all other JSAPI data has been properly
 * cleaned up: every new runtime must have been destroyed, every new context
 * must have been destroyed, and so on.  Calling this method before all other
 * resources have been destroyed has undefined behavior.
 *
 * Failure to call this method, at present, has no adverse effects other than
 * leaking memory.  This may not always be the case; it's recommended that all
 * embedders call this method when all other JSAPI operations have completed.
 *
 * It is currently not possible to initialize SpiderMonkey multiple times (that
 * is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
 * again).  This restriction may eventually be lifted.
 */
    #[link_name = "?JS_ShutDown@@YAXXZ"]
    pub fn JS_ShutDown();
    /**
 * In memory reporting, we have concept of "sundries", line items which are too
 * small to be worth reporting individually.  Under some circumstances, a memory
 * reporter gets tossed into the sundries bucket if it's smaller than
 * MemoryReportingSundriesThreshold() bytes.
 *
 * We need to define this value here, rather than in the code which actually
 * generates the memory reports, because NotableStringInfo uses this value.
 */
    #[link_name = "?MemoryReportingSundriesThreshold@js@@YA_KXZ"]
    pub fn MemoryReportingSundriesThreshold() -> usize;
    #[link_name =
          "?CollectRuntimeStats@JS@@YA_NPEAUJSRuntime@@PEAURuntimeStats@1@PEAVObjectPrivateVisitor@1@_N@Z"]
    pub fn CollectRuntimeStats(rt: *mut JSRuntime, rtStats: *mut RuntimeStats,
                               opv: *mut ObjectPrivateVisitor,
                               anonymize: bool) -> bool;
    #[link_name = "?SystemCompartmentCount@JS@@YA_KPEAUJSRuntime@@@Z"]
    pub fn SystemCompartmentCount(rt: *mut JSRuntime) -> usize;
    #[link_name = "?UserCompartmentCount@JS@@YA_KPEAUJSRuntime@@@Z"]
    pub fn UserCompartmentCount(rt: *mut JSRuntime) -> usize;
    #[link_name = "?PeakSizeOfTemporary@JS@@YA_KPEBUJSRuntime@@@Z"]
    pub fn PeakSizeOfTemporary(rt: *const JSRuntime) -> usize;
    #[link_name =
          "?AddSizeOfTab@JS@@YA_NPEAUJSRuntime@@V?$Handle@PEAVJSObject@@@1@P6A_KPEBX@ZPEAVObjectPrivateVisitor@1@PEAUTabSizes@1@@Z"]
    pub fn AddSizeOfTab(rt: *mut JSRuntime, obj: HandleObject,
                        mallocSizeOf: MallocSizeOf,
                        opv: *mut ObjectPrivateVisitor, sizes: *mut TabSizes)
     -> bool;
    #[link_name =
          "?AddServoSizeOf@JS@@YA_NPEAUJSRuntime@@P6A_KPEBX@ZPEAVObjectPrivateVisitor@1@PEAUServoSizes@1@@Z"]
    pub fn AddServoSizeOf(rt: *mut JSRuntime, mallocSizeOf: MallocSizeOf,
                          opv: *mut ObjectPrivateVisitor,
                          sizes: *mut ServoSizes) -> bool;
}
